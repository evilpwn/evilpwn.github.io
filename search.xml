<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>王卡热点ml踩坑小记</title>
      <link href="/2019/wangka-ml/"/>
      <url>/2019/wangka-ml/</url>
      
        <content type="html"><![CDATA[<p><strong>本文仅为学习笔记，不得用于非法用途，否则后果自负。</strong></p><h1 id="王卡ml"><a href="#王卡ml" class="headerlink" title="王卡ml"></a>王卡ml</h1><p>从上周五开始，eduroam的信号竟然莫名消失了，王卡开热点ml，可动不动就跳点了，突发奇想，写个python防止跑流量吧。</p><a id="more"></a><h2 id="获取ml参数"><a href="#获取ml参数" class="headerlink" title="获取ml参数"></a>获取ml参数</h2><p>抓包，或者从 <a href="http://www.dtpwxn.top" target="_blank" rel="noopener">http://www.dtpwxn.top</a> 上爬</p><h2 id="获取ip"><a href="#获取ip" class="headerlink" title="获取ip"></a>获取ip</h2><p>获取外网ip：</p><ol><li><a href="http://2019.ip138.com/ic.asp" target="_blank" rel="noopener">http://2019.ip138.com/ic.asp</a></li><li><a href="http://www.ip.cn" target="_blank" rel="noopener">http://www.ip.cn</a></li><li><a href="http://ip.3322.org" target="_blank" rel="noopener">http://ip.3322.org</a></li></ol><p>3322只能获取到ip地址，不能得到归属地，强迫症表示不喜欢。</p><p>ml中，放行其中一个，让其获得真实的ip地址，另一个则是代理的ip地址。</p><p>利用requests库，得到response。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">while</span>(response.status_code!=<span class="number">200</span>):</span><br><span class="line">            print(url,response.status_code,<span class="string">"Get failed，retrying......"</span>)</span><br><span class="line">            response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> (requests.exceptions.ConnectionError,requests.exceptions.ReadTimeout):</span><br><span class="line">        print(url,<span class="string">"ConnectionError or ReadTimeout,retrying......"</span>)</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">while</span> (response.status_code != <span class="number">200</span>):</span><br><span class="line">            print(<span class="string">"except:"</span>,url, response.status_code, <span class="string">"Get failed，retrying......"</span>)</span><br><span class="line">            response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># print("print:",url,response.status_code,response.text)</span></span><br><span class="line">    response.close()</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><blockquote><p>坑点：</p><ol><li>ip138在header中没有指定charset，不手动指定编码的话会乱码，re就无法识别了。</li><li>ip.cn需要ssl，可能因为代理的问题，经常卡在ReadTimeout:HTTPSConnectionPool， <del>干脆关掉ssl，忽略warning</del> header中加入UA，解决了这个问题，详见后面的完整代码。</li><li>即使try-except下，ip138有时还是不返回response，状态码竟然是823，这又是个什么鬼……加了一个while循环，验证状态码。</li></ol></blockquote><h2 id="正则表达提取ip"><a href="#正则表达提取ip" class="headerlink" title="正则表达提取ip"></a>正则表达提取ip</h2><p>利用re库，提取到ip地址和归属地</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proxy_ip ip.cn</span></span><br><span class="line">proxy_regex=<span class="string">r"&lt;code&gt;(.*?)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所在地理位置：&lt;code&gt;(.*?)&lt;/code&gt;"</span></span><br><span class="line"><span class="comment"># real_ip ip138</span></span><br><span class="line">real_regex=<span class="string">r"\[(.*?)\] 来自\：(.*?)&lt;/center&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip</span><span class="params">(url,encoding,regex)</span>:</span></span><br><span class="line">    response = get_response(url)</span><br><span class="line">    response.encoding = encoding</span><br><span class="line">    regex = search(regex, response.text)</span><br><span class="line">    ip=[regex.group(<span class="number">1</span>),regex.group(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">return</span> ip</span><br></pre></td></tr></table></figure><blockquote><p>坑点：提取ip时，gbk编码下的中文“：”竟然需要转义！而utf-8就不需要，长见识了。</p></blockquote><h2 id="判断ml"><a href="#判断ml" class="headerlink" title="判断ml"></a>判断ml</h2><p>通过得到代理ip和真实ip来判断当前是否还在ml中。<br>不免流的话，使用cmd命令释放ip <code>ipconfig /release</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ip[<span class="number">0</span>]!=real_ip[<span class="number">0</span>]): <span class="comment"># ml</span></span><br><span class="line">    ip=get_ip(<span class="string">"http://ip.cn"</span>,<span class="string">"utf-8"</span>,proxy_regex)</span><br><span class="line">    real_ip=get_ip(<span class="string">"http://2019.ip138.com/ic.asp"</span>,<span class="string">"gbk"</span>,real_regex)</span><br><span class="line">    print(localtime(),ip,real_ip) <span class="comment"># 当前时间，代理ip，真实ip</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(localtime())</span><br><span class="line">    print(<span class="string">"Release ip...."</span>)</span><br><span class="line">    system(<span class="string">"ipconfig /release"</span>)</span><br><span class="line">    system(<span class="string">"pause"</span>)</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> search</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="comment"># requests.packages.urllib3.disable_warnings() # 忽略缺少证书的警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># proxy_ip ip.cn</span></span><br><span class="line">proxy_regex=<span class="string">r"&lt;code&gt;(.*?)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所在地理位置：&lt;code&gt;(.*?)&lt;/code&gt;"</span></span><br><span class="line"><span class="comment"># real_ip ip138</span></span><br><span class="line">real_regex=<span class="string">r"\[(.*?)\] 来自\：(.*?)&lt;/center&gt;"</span></span><br><span class="line"><span class="comment"># headers</span></span><br><span class="line">headers = requests.utils.default_headers()</span><br><span class="line">headers[<span class="string">'User-Agent'</span>] = <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">localtime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> time.asctime(time.localtime(time.time()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">while</span>(response.status_code!=<span class="number">200</span>):</span><br><span class="line">            print(url,response.status_code,<span class="string">"Get failed，retrying......"</span>)</span><br><span class="line">            response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> (requests.exceptions.ConnectionError,requests.exceptions.ReadTimeout):</span><br><span class="line">        print(url,<span class="string">"ConnectionError or ReadTimeout,retrying......"</span>)</span><br><span class="line">        response = requests.get(url, headers=headers, timeout=<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">while</span> (response.status_code != <span class="number">200</span>):</span><br><span class="line">            print(<span class="string">"except:"</span>,url, response.status_code, <span class="string">"Get failed，retrying......"</span>)</span><br><span class="line">            response = requests.get(url, headers=headers, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># print("print:",url,response.status_code,response.text)</span></span><br><span class="line">    response.close()</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip</span><span class="params">(url,encoding,regex)</span>:</span></span><br><span class="line">    response = get_response(url)</span><br><span class="line">    response.encoding = encoding</span><br><span class="line">    <span class="comment"># regex=search(r"&lt;code&gt;(.*?)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所在地理位置：&lt;code&gt;(.*?)&lt;/code&gt;",response.text)</span></span><br><span class="line">    regex = search(regex, response.text)</span><br><span class="line">    ip=[regex.group(<span class="number">1</span>),regex.group(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">banner</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Version:0.3\nFrequency: 5 times/minute"</span>)</span><br><span class="line">    print(<span class="string">"Time,ProxyIP,RealIP"</span>)</span><br><span class="line">    print(<span class="string">"-----------------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    banner()</span><br><span class="line">    ip =[<span class="string">"1"</span>]</span><br><span class="line">    real_ip =[<span class="string">"2"</span>]</span><br><span class="line">    <span class="keyword">while</span>(ip[<span class="number">0</span>]!=real_ip[<span class="number">0</span>]): <span class="comment"># ml</span></span><br><span class="line">        ip=get_ip(<span class="string">"http://ip.cn"</span>,<span class="string">"utf-8"</span>,proxy_regex)</span><br><span class="line">        real_ip=get_ip(<span class="string">"http://2019.ip138.com/ic.asp"</span>,<span class="string">"gbk"</span>,real_regex)</span><br><span class="line">        print(localtime(),ip,real_ip) <span class="comment"># 当前时间，代理ip，真实ip</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(localtime())</span><br><span class="line">        print(<span class="string">"Release ip...."</span>)</span><br><span class="line">        print(<span class="string">"Please reset portable Wi-Fi hotspot and reconnect"</span>)</span><br><span class="line">        system(<span class="string">"ipconfig /release"</span>)</span><br><span class="line">        system(<span class="string">"msg %username% /time:10 \"Release ip......Please reset portable Wi-Fi hotspot and reconnect\""</span>)</span><br><span class="line">        system(<span class="string">"pause"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://image.evilpwn.me/blog/wangka-ml-01.png-sign" alt="wangka-ml-01"></p>]]></content>
      
      
      <categories>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日志审计基础</title>
      <link href="/2019/Log-Audit/"/>
      <url>/2019/Log-Audit/</url>
      
        <content type="html"><![CDATA[<h1 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h1><ul><li>操作系统日志（windows、Linux）</li><li>网络设备日志（路由交换设备、安全设备）</li><li>应用系统日志（Web等网络安全应用）</li></ul><a id="more"></a><h2 id="Linux-Unix-系统日志"><a href="#Linux-Unix-系统日志" class="headerlink" title="Linux/Unix 系统日志"></a>Linux/Unix 系统日志</h2><ol><li>登录时间日志子系统<br>一般记录在<code>/var/log/wtm</code>和<code>/var/run/utmp</code>中，一旦触发login等程序，就会进行相应更新</li><li>进程统计日志子系统<br>主要由系统内核来完成记录操作，记录系统中各个基本的服务。</li><li>错误日志子系统<br>主要由系统进程syslogd（Linux新发行版采用rsyslogd服务）实现，由各个应用系统（Http、FTP、Samba等）守护进程、系统内核来自动利用syslog向<code>/var/log/messages</code>文件进行记录添加，用来向用户报告不同级别的事件。</li></ol><h3 id="主要日志格式"><a href="#主要日志格式" class="headerlink" title="主要日志格式"></a>主要日志格式</h3><ol><li><p>基于syslog的日志<br>采用Syslog协议和POSIX标准，以ASCII文本形式存在，一般由：日期、时间、主机名、IP地址和优先级等组成，优先级分为0~8个级别，每个级别对应不同的核心程序所产生的日志。</p></li><li><p>日志程序产生的日志文件<br>ASCII文本形式存在，大多数Linux系统中，应用程序会自动将对应的日志文件向syslogd进行统一发送，并由syslogd统一处理。默认存储在<code>/var/log/messages</code>下，如Apache产生的<code>/var/log/httpd/access_log</code>；Samba服务产生的<code>/var/log/samba</code>。</p></li><li><p>操作记录日志文件<br>主要包括两类：</p><ol><li>各个终端登录日志lastlog,二进制形式存储，记录内容主要有：用户名、终端号、登入IP、登入时间等。</li><li>邮件服务齐maillog，文件格式比较复杂，ASCII文本形式存储，记录有：进程名、邮件代号、日期、时间、操作过程的各种相关信息。</li></ol></li></ol><h2 id="Windows日志"><a href="#Windows日志" class="headerlink" title="Windows日志"></a>Windows日志</h2><ul><li><p>系统日志<br>系统中各种驱动、组件以及应用软件在运行中出现的重大问题，即重要数据丢失、错误，甚至系统崩溃的行为。</p></li><li><p>安全日志<br>主要记录安全相关的事件：系统登录成功或失败的信息，对各种重要资源进行的各种操作（如：对系统文件进行创建、删除、更改等不同操作）。</p></li><li><p>应用程序日志<br>应用程序产生，如SQL Server数据库程序进行备份设定，一旦完成备份操作，就立即向指定的日志发送记录，记录中包含与对应实践相关的详细信息。</p></li></ul><blockquote><p>Windows主要采用二进制格式存储日志，需要使用对应的查看器读取。</p></blockquote><h3 id="常见系统日志"><a href="#常见系统日志" class="headerlink" title="常见系统日志"></a>常见系统日志</h3><p>。。。。。。</p><h2 id="网络设备日志"><a href="#网络设备日志" class="headerlink" title="网络设备日志"></a>网络设备日志</h2><p>。。。。。。</p><h2 id="应用系统日志"><a href="#应用系统日志" class="headerlink" title="应用系统日志"></a>应用系统日志</h2><p>。。。。。。</p><!--# Web日志# FTP服务器日志# 用LogParser分析Windows日志# Squid服务日志# NFS服务日志# iptables日志# Samba日志# DNS日志# DHCP服务器日志!--><h1 id="邮件服务器日志"><a href="#邮件服务器日志" class="headerlink" title="邮件服务器日志"></a>邮件服务器日志</h1><p>Sendmail和Postfix两个著名开源邮件系统为例。</p><h2 id="Sendmail"><a href="#Sendmail" class="headerlink" title="Sendmail"></a>Sendmail</h2><p>Sendmail服务启动后，邮件收发日志保存在<code>/var/log/maillog</code>中，日志分析工具是Sendmail Analyzer，它能监控sendmail使用，并生成HTML和图形报表，包含网络流量、邮箱使用报告等。（AWStats也可用于分析邮件日志）</p><h2 id="Postfix"><a href="#Postfix" class="headerlink" title="Postfix"></a>Postfix</h2><p>日志同样存放在<code>/var/log/maillog</code>中，分析工具可以使用<a href="http://jimsun.linxnet.com/postfix_contrib.html" target="_blank" rel="noopener">pflogsumm.pl脚本</a>，可以在crontab中添加以下内容来定时把分析报告发送到邮箱中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 * * * /path/to/pflogsumm.pl -d today /var/<span class="built_in">log</span>/maillog | mail -s <span class="string">"Mail Report"</span> yourmail@domian.com</span><br></pre></td></tr></table></figure></p><h1 id="AWStats监控网站流量"><a href="#AWStats监控网站流量" class="headerlink" title="AWStats监控网站流量"></a>AWStats监控网站流量</h1><p>AWStats可以分析的日志包括Apache的两种日志（NCSA combined/XLF/ELF 或 common/CLF）、WebStar、IIS（W3C）、邮件服务和一些FTP服务的日志，并产生HTML页面和图表。<br>特点如下：</p><ol><li>入门简单，首次使用仅需要修改配置文件4处即可。</li><li>输出丰富，如搜索引擎和搜索引擎的机器人。</li><li>良好扩展性，有不少真的AWStats插件。</li><li>与基于C语言的日志分析软件相比，AWStats速度稍慢。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>docs文件夹包含HTML格式的文档，叙述了AWStats的安装和用法。</p><ol><li>具有服务器控制权，并能更改Apache服务的配置文件<br>解压后执行tools下的AWStats_configure.pl脚本，指定Apache的配置文件httpd.conf的位置即可完成安装。</li><li>没有完全控制Apache的虚拟机<br>解压后，将wwwroot/AWStats文件夹放在具有CGI权限的目录下。</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>将wwwroot/AWStats目录下的AWStats.model.conf修改为<code>AWStats.www.website.com.conf</code>，然后编辑。</p><ol><li><p>LogFile<br>指定了日志文件的路径和名称，如：<br>Logfile=”/home/apache_loga/access.log.2012-07-06”<br>也可以使用动态变量指定：<br>Logfile=”/home/apache_loga/access.log.%YYYY-224-%MM-24-%DD-24”<br>如果Apache做个轮询，就可以自动取得上一天的日志。若日志文件是压缩的，也可以直接用命令读取，无需解压。<br>LogFile=”gzip-d&lt;/var/log/apache/access.log.gz&gt;”</p></li><li><p>LogType<br>指定需要分析的日志类型</p></li></ol><ul><li>W Web服务日志</li><li>S 流媒体服务日志</li><li>M 邮件服务日志</li><li>F FTP服务日志</li></ul><ol start="3"><li>LogFormat<br>指定使用的日志格式</li></ol><ul><li>1 NCSA combined/XLF/ELF 格式（Apache中的combined格式日志）</li><li>2 IIS或ISA格式</li><li>3 WebStat格式</li><li>4 NCSA common/CLF格式（Apache中的common格式日志）</li></ul><p>除了以上4种格式，还可以自定义要分析的日志格式，如：<br>LogFormat=”%host%other%logname%them1%methodurl%code%bytesd%referquot%uaquot”</p><ol start="4"><li><p>SiteDomain<br>指定站点名称，”<a href="http://www.website.com&quot;" target="_blank" rel="noopener">www.website.com&quot;</a></p></li><li><p>HostAliases<br>如果站点有其他域名，并希望得到它们的统计数据，可以用该参数一并计算之内<br>HostAliases=”localhost 127.0.0.1 REGEX<br>[website.com$]“</p></li><li><p>DirData<br>指定存放数据文件的目录，默认为当前目录。默认以月为单位，一个月对应一个文件。</p></li></ol><blockquote><p>前4项为必须项。</p></blockquote><h2 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to AWStats-7.0/wwwroot/AWStats/AWStats.pl-config=www.website.com-update</span><br></pre></td></tr></table></figure><p>对该域名的日志进行Update操作，awstats.pl会在当前目录查找名称为AWStats.<a href="http://www.website.com.conf的配置文件，根据配置中的选项对日志文件进行分析，最后将分析结果按照月份放在data目录中。" target="_blank" rel="noopener">www.website.com.conf的配置文件，根据配置中的选项对日志文件进行分析，最后将分析结果按照月份放在data目录中。</a></p><blockquote><p>可以将该命令写入crontab中，每天自动进行日志分析。</p></blockquote><p>查看当月历史统计信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.website.com/AWStats/AWStats.pl?config=www.website.com</span><br></pre></td></tr></table></figure></p><h2 id="监控邮件系统日志"><a href="#监控邮件系统日志" class="headerlink" title="监控邮件系统日志"></a>监控邮件系统日志</h2><p>分析Sendmail、Postfix日志，生成报表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/awstats</span><br><span class="line"># 从model中复制出一份配置文件(名字可以自定义)</span><br><span class="line">cp /usr/local/awstats/wwwroot/cgi-bin/awstats.model.conf awstats.mail.conf</span><br></pre></td></tr></table></figure><p>修改配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 指定邮件服务日志文件的位置</span><br><span class="line">LogFile=&quot;/usr/local/awstats/tools/maillogconvert.pl standard &lt;/var/log/maillog&quot;</span><br><span class="line"></span><br><span class="line"># 设定邮件服务器的域名</span><br><span class="line">SiteDomain=&quot;test.mail.com&quot;</span><br></pre></td></tr></table></figure></p><p>执行脚本，会生成报表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/awstats/wwwroot/cgi-bin/awstats.pl -update-config=mail</span><br></pre></td></tr></table></figure></p><p>打开浏览器：<br><a href="http://IP/awstats/awstats.pl?config=mail" target="_blank" rel="noopener">http://IP/awstats/awstats.pl?config=mail</a></p><!--## 监控FTP日志## 监控Squid日志--><h1 id="其他开源日志分析软件"><a href="#其他开源日志分析软件" class="headerlink" title="其他开源日志分析软件"></a>其他开源日志分析软件</h1><p>Webalizer、Analog</p>]]></content>
      
      
      <categories>
          
          <category> 日志审计 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志审计 </tag>
            
            <tag> 邮件日志审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>centos python2 升级 python3</title>
      <link href="/2018/python2-to-python3/"/>
      <url>/2018/python2-to-python3/</url>
      
        <content type="html"><![CDATA[<p>centos默认安装了python2.7.5 因为一些命令(如yum)要用它，升级python3需要更改yum的配置。</p><a id="more"></a><h1 id="升级python3"><a href="#升级python3" class="headerlink" title="升级python3"></a>升级python3</h1><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官网下载</a><br>当前最新版 <a href="https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz" target="_blank" rel="noopener">python3.6.5</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br><span class="line"></span><br><span class="line">./configure prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h1 id="更换python的软连接"><a href="#更换python的软连接" class="headerlink" title="更换python的软连接"></a>更换python的软连接</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python</span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/bin/pip3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/bin/pip</span><br></pre></td></tr></table></figure><h1 id="修改yum配置使用python2"><a href="#修改yum配置使用python2" class="headerlink" title="修改yum配置使用python2"></a>修改yum配置使用python2</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/bin/yum</span><br><span class="line"></span><br><span class="line">把第一行 </span><br><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line">修改为</span><br><span class="line"><span class="comment">#! /usr/bin/python2</span></span><br><span class="line"></span><br><span class="line">/usr/libexec/urlgrabber-ext-down同理</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux网络架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDCTFTF-2018-writeup</title>
      <link href="/2018/DDCTFT-2018-writeup/"/>
      <url>/2018/DDCTFT-2018-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="╯°□°）╯︵-┻━┻"><a href="#╯°□°）╯︵-┻━┻" class="headerlink" title="(╯°□°）╯︵ ┻━┻"></a>(╯°□°）╯︵ ┻━┻</h2><p>(╯°□°）╯︵ ┻━┻<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd</span><br></pre></td></tr></table></figure></p><p>一眼看出16进制，丢到winhex中无解，先转10进制看看吧<br>长度134位，转一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">"d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd"</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">a=<span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">133</span>:</span><br><span class="line">    a+=str(int(s[i:i+<span class="number">2</span>],<span class="number">16</span>))+<span class="string">" "</span></span><br><span class="line">    i+=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">212</span> <span class="number">232</span> <span class="number">225</span> <span class="number">244</span> <span class="number">160</span> <span class="number">247</span> <span class="number">225</span> <span class="number">243</span> <span class="number">160</span> <span class="number">230</span> <span class="number">225</span> <span class="number">243</span> <span class="number">244</span> <span class="number">161</span> <span class="number">160</span> <span class="number">212</span> <span class="number">232</span> <span class="number">229</span> <span class="number">160</span> <span class="number">230</span> <span class="number">236</span> <span class="number">225</span> <span class="number">231</span> <span class="number">160</span> <span class="number">233</span> <span class="number">243</span> <span class="number">186</span> <span class="number">160</span> <span class="number">196</span> <span class="number">196</span> <span class="number">195</span> <span class="number">212</span> <span class="number">198</span> <span class="number">251</span> <span class="number">185</span> <span class="number">178</span> <span class="number">178</span> <span class="number">225</span> <span class="number">226</span> <span class="number">185</span> <span class="number">185</span> <span class="number">183</span> <span class="number">180</span> <span class="number">225</span> <span class="number">180</span> <span class="number">183</span> <span class="number">227</span> <span class="number">228</span> <span class="number">179</span> <span class="number">178</span> <span class="number">178</span> <span class="number">227</span> <span class="number">230</span> <span class="number">180</span> <span class="number">179</span> <span class="number">226</span> <span class="number">181</span> <span class="number">176</span> <span class="number">182</span> <span class="number">177</span> <span class="number">176</span> <span class="number">230</span> <span class="number">225</span> <span class="number">229</span> <span class="number">225</span> <span class="number">181</span> <span class="number">253</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>都大于128，不是ASCII，直接chr依旧乱码，那减去128再试试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a+=chr(int(s[i:i+<span class="number">2</span>],<span class="number">16</span>)<span class="number">-128</span>)</span><br></pre></td></tr></table></figure></p><p><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.1.png-sign" alt="1.png-sign"></p><h2 id="第四扩展FS"><a href="#第四扩展FS" class="headerlink" title="第四扩展FS"></a>第四扩展FS</h2><p>D公司正在调查一起内部数据泄露事件，锁定嫌疑人小明，取证人员从小明手机中获取了一张图片引起了怀疑。这是一道送分题，提示已经在题目里，日常违规审计中频次有时候非常重要。<br>附件：<a href="https://image.evilpwn.me/blog/DDCTF-2018-writeup.windows.jpg" target="_blank" rel="noopener">windows.jpg</a></p><p>原图12M，binwalk看一下，发现有个zip包，foremost提取出来，发现里面一个file.txt，但被加密。密码在windows.jpg的属性中找到<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.2.png-sign" alt="2.png-sign"><br>file.txt：<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.3.png-sign" alt="3.png-sign"><br>栅栏无解。<br>题目中提示：日常违规审计中频次有时候非常重要。<br>统计一下字频吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn=open(<span class="string">"file.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">dic=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fn.read():</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">        dic[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">ziped=zip(dic.values(),dic.keys())</span><br><span class="line">print(sorted(ziped,reverse=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line">[(<span class="number">3950</span>, <span class="string">'D'</span>), (<span class="number">1900</span>, <span class="string">'C'</span>), (<span class="number">1850</span>, <span class="string">'T'</span>), (<span class="number">1800</span>, <span class="string">'F'</span>), (<span class="number">1750</span>, <span class="string">'&#123;'</span>), (<span class="number">1700</span>, <span class="string">'j'</span>), (<span class="number">1650</span>, <span class="string">'1'</span>), (<span class="number">1600</span>, <span class="string">'e'</span>), (<span class="number">1550</span>, <span class="string">'s'</span>), (<span class="number">1500</span>, <span class="string">'H'</span>), (<span class="number">1450</span>, <span class="string">'0'</span>), (<span class="number">1400</span>, <span class="string">'u'</span>), (<span class="number">1350</span>, <span class="string">'t'</span>), (<span class="number">1300</span>, <span class="string">'i'</span>), (<span class="number">1250</span>, <span class="string">'4'</span>), (<span class="number">1200</span>, <span class="string">'o'</span>), (<span class="number">1150</span>, <span class="string">'z'</span>), (<span class="number">1100</span>, <span class="string">'h'</span>), (<span class="number">1050</span>, <span class="string">'a'</span>), (<span class="number">1000</span>, <span class="string">'n'</span>), (<span class="number">950</span>, <span class="string">'&#125;'</span>)]</span><br></pre></td></tr></table></figure></p><p>百度找下看看有没有更好的字频统计，发现有个库可以直接用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">fn=open(<span class="string">"file.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">print(collections.Counter(fn.read()))</span><br><span class="line"></span><br><span class="line">Counter(&#123;<span class="string">'D'</span>: <span class="number">3950</span>, <span class="string">'C'</span>: <span class="number">1900</span>, <span class="string">'T'</span>: <span class="number">1850</span>, <span class="string">'F'</span>: <span class="number">1800</span>, <span class="string">'&#123;'</span>: <span class="number">1750</span>, <span class="string">'j'</span>: <span class="number">1700</span>, <span class="string">'1'</span>: <span class="number">1650</span>, <span class="string">'e'</span>: <span class="number">1600</span>, <span class="string">'s'</span>: <span class="number">1550</span>, <span class="string">'H'</span>: <span class="number">1500</span>, <span class="string">'0'</span>: <span class="number">1450</span>, <span class="string">'u'</span>: <span class="number">1400</span>, <span class="string">'t'</span>: <span class="number">1350</span>, <span class="string">'i'</span>: <span class="number">1300</span>, <span class="string">'4'</span>: <span class="number">1250</span>, <span class="string">'o'</span>: <span class="number">1200</span>, <span class="string">'z'</span>: <span class="number">1150</span>, <span class="string">'h'</span>: <span class="number">1100</span>, <span class="string">'a'</span>: <span class="number">1050</span>, <span class="string">'n'</span>: <span class="number">1000</span>, <span class="string">'&#125;'</span>: <span class="number">950</span>&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>题目中的提示，第四拓展FS，ext4</p></blockquote><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>提示一：若感觉在中间某个容易出错的步骤，若有需要检验是否正确时，可以比较MD5: 90c490781f9c320cd1ba671fcb112d1c<br>提示二：注意补齐私钥格式<br>—–BEGIN RSA PRIVATE KEY—–<br>XXXXXXX<br>—–END RSA PRIVATE KEY—–</p><p>附件：<a href="http://p7j8ys54q.bkt.clouddn.com/1cMYNO2TCQHSfJwxnvm4z.pcap" target="_blank" rel="noopener">PCAP包</a></p><p>丢到wireshark中，找到两个ftp传输的zip文件，但是导不出来<br>能导出来的只有一些email文件，只有个别可以打开（其中一封貌似还是个广告），其他的应该ssl加密了。<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.4.png-sign" alt="4.png-sign"><br>(5).eml中发现了有用的信息。<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.5.png-sign" alt="5.png-sign"><br>WTF！是个图！OneNote OCR识别后，还是各种错，和题中给的MD5死活对不上，一个一个对吧（深夜1点多写这个题，眼睛都快瞎了。）</p><p>补齐私钥格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQDCm6vZmclJrVH1AAyGuCuSSZ8O+mIQiOUQCvN0HYbj8153JfSQ</span><br><span class="line">LsJIhbRYS7+zZ1oXvPemWQDv/u/tzegt58q4ciNmcVnq1uKiygc6QOtvT7oiSTyO</span><br><span class="line">vMX/q5iE2iClYUIHZEKX3BjjNDxrYvLQzPyGD1EY2DZIO6T45FNKYC2VDwIDAQAB</span><br><span class="line">AoGAbtWUKUkx37lLfRq7B5sqjZVKdpBZe4tL0jg6cX5Djd3Uhk1inR9UXVNw4/y4</span><br><span class="line">QGfzYqOn8+Cq7QSoBysHOeXSiPztW2cL09ktPgSlfTQyN6ELNGuiUOYnaTWYZpp/</span><br><span class="line">QbRcZ/eHBulVQLlk5M6RVs9BLI9X08RAl7EcwumiRfWas6kCQQDvqC0dxl2wIjwN</span><br><span class="line">czILcoWLig2c2u71Nev9DrWjWHU8eHDuzCJWvOUAHIrkexddWEK2VHd+F13GBCOQ</span><br><span class="line">ZCM4prBjAkEAz+ENahsEjBE4+7H1HdIaw0+goe/45d6A2ewO/lYH6dDZTAzTW9z9</span><br><span class="line">kzV8uz+Mmo5163/JtvwYQcKF39DJGGtqZQJBAKa18XR16fQ9TFL64EQwTQ+tYBzN</span><br><span class="line">+04eTWQCmH3haeQ/0Cd9XyHBUveJ42Be8/jeDcIx7dGLxZKajHbEAfBFnAsCQGq1</span><br><span class="line">AnbJ4Z6opJCGu+UP2c8SC8m0bhZJDelPRC8IKE28eB6SotgP61ZqaVmQ+HLJ1/wH</span><br><span class="line">/5pfc3AmEyRdfyx6zwUCQCAH4SLJv/kprRz1a1gx8FR5tj4NeHEFFNEgq1gmiwmH</span><br><span class="line">2STT5qZWzQFz8NRe+/otNOHBR2Xk4e8IS+ehIJ3TvyE=</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p><p>好了，私钥有了，先看一下ssl协议传了哪些数据<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.6.png-sign" alt="6.png-sign"></p><p>导入证书<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.7.png-sign" alt="7.png-sign"><br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.8.png-sign" alt="8.png-sign"></p><p>出来两条http<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.9.png-sign" alt="9.png-sign"></p><p>话说，前面那俩ftp传输的zip包和剩下的邮件就是干扰信息喽？</p><h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><p>请通过nc 116.85.48.103 5002答题，mission key是b9ba15b341c847c8beba85273f9b7f90，agent id随意填就可以<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_padding</span><span class="params">(rawstr)</span>:</span></span><br><span class="line">    remainder = len(rawstr) % <span class="number">16</span></span><br><span class="line">    <span class="keyword">if</span> remainder != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span> * (<span class="number">16</span> - remainder)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aes_encrypt</span><span class="params">(key, plaintext)</span>:</span></span><br><span class="line">    plaintext += get_padding(plaintext)</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cipher_text = aes.encrypt(plaintext).encode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_hello</span><span class="params">(key, name, flag)</span>:</span></span><br><span class="line">    message = <span class="string">"Connection for mission: &#123;&#125;, your mission's flag is: &#123;&#125;"</span>.format(name, flag)</span><br><span class="line">    <span class="keyword">return</span> aes_encrypt(key, message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_input</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> raw_input()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_output</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">()</span>:</span></span><br><span class="line">    print_output(<span class="string">"Please enter mission key:"</span>)</span><br><span class="line">    mission_key = get_input().rstrip()</span><br><span class="line"></span><br><span class="line">    print_output(<span class="string">"Please enter your Agent ID to secure communications:"</span>)</span><br><span class="line">    agentid = get_input().rstrip()</span><br><span class="line">    rnd = Random.new()</span><br><span class="line">    session_key = rnd.read(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    flag = <span class="string">'&lt;secret&gt;'</span></span><br><span class="line">    print_output(generate_hello(session_key, agentid, flag))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print_output(<span class="string">"Please send some messages to be encrypted, 'quit' to exit:"</span>)</span><br><span class="line">        msg = get_input().rstrip()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">'quit'</span>:</span><br><span class="line">            print_output(<span class="string">"Bye!"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        enc = aes_encrypt(session_key, msg)</span><br><span class="line">        print_output(enc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    handle()</span><br></pre></td></tr></table></figure></p><p>先尝试一下nc<br><img src="https://image.evilpwn.me/blog/DDCTF-2018-writeup.10.png-sign" alt="10.png-sign"></p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="数据库的秘密"><a href="#数据库的秘密" class="headerlink" title="数据库的秘密"></a>数据库的秘密</h2><p>[注意] 本次DDCTF所有WEB题无需使用也禁止使用扫描器</p><p><a href="http://116.85.43.88:8080/UNWROBCEZRCYCMKH/dfe3ia/index.php" target="_blank" rel="noopener">http://116.85.43.88:8080/UNWROBCEZRCYCMKH/dfe3ia/index.php</a></p><p>直接打开提示“非法链接，只允许来自 123.232.23.245 的访问”<br>伪造ip头<br>X-Forwarded-For: 123.232.23.245</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDCTF </tag>
            
            <tag> CTF </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python爬虫</title>
      <link href="/2018/Python_crawler/"/>
      <url>/2018/Python_crawler/</url>
      
        <content type="html"><![CDATA[<h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><p>目的一般为编纂网络索引。</p><p>网络搜索引擎等站点通过爬虫软件更新自身的网站内容或其对其他网站的索引。网络爬虫可以将自己所访问的页面保存下来，以便搜索引擎事后生成索引供用户搜索。</p><a id="more"></a><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><p>自动爬取html页面<br>自动网络请求提交</p><h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>网络爬虫排除标准</p><h2 id="beautiful-Soup-库"><a href="#beautiful-Soup-库" class="headerlink" title="beautiful Soup 库"></a>beautiful Soup 库</h2><p>解析html页面</p><h2 id="Re-库"><a href="#Re-库" class="headerlink" title="Re 库"></a>Re 库</h2><p>正则表达式，提取信息</p><h2 id="Scrapy-爬虫框架"><a href="#Scrapy-爬虫框架" class="headerlink" title="Scrapy* 爬虫框架"></a>Scrapy* 爬虫框架</h2><h1 id="request-库"><a href="#request-库" class="headerlink" title="request 库"></a>request 库</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install requests</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r=requests.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(r)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">requests</span>.<span class="title">models</span>.<span class="title">Response</span>'&gt;  # 返回的是<span class="title">Response</span>对象</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>.<span class="title">status_code</span>  # 状态码</span></span><br><span class="line"><span class="class">200</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>.<span class="title">headers</span>   # 头部信息</span></span><br><span class="line">&#123;'Cache-Control':....</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding=<span class="string">'utf-8'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line"><span class="string">'&lt;!DOCTYPE html&gt;.......  # 源代码</span></span><br></pre></td></tr></table></figure><h2 id="requests库主要方法"><a href="#requests库主要方法" class="headerlink" title="requests库主要方法"></a>requests库主要方法</h2><ul><li><p>requests.request() </p><p>  构造请求，支撑以下各种方法的基础方法</p></li><li><p>request.get()、request.put()、requests.post()</p><p>  对html网页的主要方法，对应http的GET、PUT、POST</p></li><li><p>requests.head()</p><p> 只获取html网页头信息的方法，对应http的HEAD，此时的Response的text属性为空。</p></li><li><p>request.patch()</p><p>  向html网页提交局部修改请求，对应http的PATCH</p></li><li><p>requests.delete()</p><p>  向html页面提交删除请求，对应于http的DELETE</p></li></ul><p>源代码中发现，request库中的所有方法都是基于request()方法的。</p><p><img src="https://image.evilpwn.me/blog/Python_crawler_01.png-sign" alt="HTTP协议对资源的操作"></p><blockquote><ol><li>源代码中发现，request库中的所有方法都是基于request()方法的。</li><li>PATCH 和 PUT 区别：<br>假设URL位置上有一组数据UserInfo，包括UserID、UserName等20个字段，用户只想修改UserName，其他不变。</li></ol></blockquote><blockquote><p>  采用PATCH，仅向URL提交UserName的局部更新请求。<br>  采用PUT，必须将所有20个字段一并提交到URL，未提交的字段会被删除。<br>PATCH的最主要好处：节省网络带宽。</p></blockquote><h3 id="POST方法的使用"><a href="#POST方法的使用" class="headerlink" title="POST方法的使用"></a>POST方法的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=&#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r=requests.post(<span class="string">'http://xxxxx/post'</span>,data=payload)</span><br><span class="line">print(r.text)</span><br><span class="line">&#123;  ...</span><br><span class="line">   <span class="string">"form"</span>:&#123;</span><br><span class="line">     <span class="string">"key2"</span>:<span class="string">"value2"</span>,</span><br><span class="line">     <span class="string">"key1"</span>:<span class="string">"value1"</span></span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r=requests.post(<span class="string">'http://xxxxx/post'</span>,data=<span class="string">'ABC'</span>)</span><br><span class="line">print(r.text)</span><br><span class="line">&#123;  ...</span><br><span class="line">   <span class="string">"data"</span>:<span class="string">"ABC"</span></span><br><span class="line">   <span class="string">"form"</span>:&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向URL POST一个字典，会自动编码为表单<br>向URL POST一个字符串，会自动编码为data</p><h2 id="Response对象的属性"><a href="#Response对象的属性" class="headerlink" title="Response对象的属性"></a>Response对象的属性</h2><ul><li><p>r.status_code</p><p>  HTTP请求的返回状态，200成功，404失败</p></li><li><p>r.text</p><p>  HTTP响应内容的字符串形式，即，url对应的页面内容</p></li><li><p>r.encoding</p><p>  从HTTP header中的charset猜测的响应内容编码方式，如果不存在charset，则认为编码为ISO-8859-1</p></li><li><p>r.apparent_encoding</p><p>  从内容中分析出的响应内容编码方式（备选编码方式）<br>  因为这个是从网页内容中分析出的编码方式，所以在header中没有charset字段时，该备选编码比encoding准确。</p></li><li><p>r.content</p><p>  HTTP响应内容的二进制形式，例如，可用来还原图片视频等。</p></li></ul><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><h3 id="requests-request-method-url-kwargs"><a href="#requests-request-method-url-kwargs" class="headerlink" title="requests.request(method,url,**kwargs)"></a>requests.request(method,url,**kwargs)</h3><ul><li>method：请求方式，对应 get/head/put/post/patch/delete/options 7种</li><li><p>**kwargs：13个控制访问参数</p><ul><li><p>params：把字典或字节序列，作为<b>参数添加到url中</b>去get。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kv=&#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r=requests.request(<span class="string">'GET'</span>,<span class="string">'http://xxxxx/abc'</span>,params=kv)</span><br><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line">http://xxxxx/abc?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure></li><li><p>data：把字典、字节序列或文件对象，作为<b>Request的内容</b>去post等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kv=&#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r=requests.request(<span class="string">'POST'</span>,<span class="string">'http://xxxxx/abc'</span>,data=kv)</span><br><span class="line"></span><br><span class="line">body=<span class="string">'内容'</span></span><br><span class="line">r=requests.request(<span class="string">'POST'</span>,<span class="string">'http://xxxxx/abc'</span>,data=body)</span><br></pre></td></tr></table></figure></li><li><p>json：JSON格式的数据，作为<b>Request的内容</b>传给json域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kv=&#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>&#125;</span><br><span class="line">r=requests.request(<span class="string">'POST'</span>,<span class="string">'http://xxxxx/abc'</span>,json=kv)</span><br></pre></td></tr></table></figure></li><li><p>headers：字典，定制HTTP头字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hd=&#123;<span class="string">'user-agent'</span>:<span class="string">'Chrome/10'</span>&#125;</span><br><span class="line">r=requests.request(<span class="string">'POST'</span>,<span class="string">'http://xxxxx/abc'</span>,headers=hd)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="requests-get-url-params-None-kwargs"><a href="#requests-get-url-params-None-kwargs" class="headerlink" title="requests.get(url,params=None,**kwargs)"></a>requests.get(url,params=None,**kwargs)</h3><p>构造一个向服务器请求资源的Request对象<br>返回一个包含服务器资源的Response对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url,params=<span class="keyword">None</span>,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>params：字典或字节流格式，可选</li><li>**kwargs：12个控制访问的参数</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>网络连接有风险<br>异常处理很重要</p><h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><ul><li><p>requests.ConnectionError</p><p>  网络连接错误异常，如DNS查询失败、拒绝连接等</p></li><li><p>requests.HTTPError</p><p>  HTTP错误异常，HTTP协议层面</p></li><li><p>requests.URLRequired</p><p>  URL缺失异常</p></li><li><p>requests.TooManyRedirects</p><p>  超过requests库最大重定向次数，产生重定向异常</p></li><li><p>requests.ConnectTimeout</p><p>  连接远程服务器超时异常</p></li><li><p>requests.Timeout</p><p>  请求URL超时，产生超时异常。即，发出url请求到获得内容整个过程超时。</p></li></ul><h3 id="Response提供的异常检测方法"><a href="#Response提供的异常检测方法" class="headerlink" title="Response提供的异常检测方法"></a>Response提供的异常检测方法</h3><ul><li><p>r.raise_for_status()</p><p>  如果不是200，产生异常requests.HTTPError</p></li></ul><h1 id="爬取网页代码的通用代码框架"><a href="#爬取网页代码的通用代码框架" class="headerlink" title="爬取网页代码的通用代码框架"></a>爬取网页代码的通用代码框架</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLext</span><span class="params">(url)</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    r=requessts.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding=r.apparent_encoding</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  url=<span class="string">"http://www.baidu.com"</span></span><br><span class="line">  print(getHTMLText(url))</span><br></pre></td></tr></table></figure><p><img src="https://image.evilpwn.me/blog/Python_crawler_02.png-sign" alt="异常处理"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> requests库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python_OS模块</title>
      <link href="/2018/Python-OS/"/>
      <url>/2018/Python-OS/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &lt;库名&gt;</span><br><span class="line">&lt;库名&gt;.&lt;函数名&gt;</span><br><span class="line"></span><br><span class="line">from &lt;库名&gt; import *</span><br><span class="line">from &lt;库名&gt; import &lt;函数名&gt;</span><br><span class="line">&lt;函数名&gt;</span><br><span class="line"></span><br><span class="line">from的这两种方式调用函数时，不再需要库名。注意此时代码中不能再创建与库函数名一样的变量或函数。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="os-walk"><a href="#os-walk" class="headerlink" title="os.walk()"></a>os.walk()</h1><p>在目录树中，遍历得到文件名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">os.walk(top[, topdown=<span class="keyword">True</span>[, onerror=<span class="keyword">None</span>[, followlinks=<span class="keyword">False</span>]]])</span><br><span class="line"></span><br><span class="line">- top：指定的根目录，包含自身，产生一个三元组，(root,dirs,files)</span><br><span class="line">- topdown：可选，默认true，自上而下遍历，设为false时，自下而上遍历。</span><br><span class="line">- onerror：可选，调用一个OSError实例，报错时继续walk或者抛出exception后终止。</span><br><span class="line">- followlinks：可选，默认flase，设为true时会遍历快捷方式实际所指向的目录。</span><br></pre></td></tr></table></figure></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">"D:\\blog\source"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> os.walk(path):</span><br><span class="line">    print(root,dirs,files)</span><br><span class="line"></span><br><span class="line">会遍历输出【当前目录，文件夹名，文件名】</span><br><span class="line">dirs、files为列表，不包含子目录</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> os模块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>extundelete数据恢复</title>
      <link href="/2017/extundelete/"/>
      <url>/2017/extundelete/</url>
      
        <content type="html"><![CDATA[<h1 id="extundelete简介"><a href="#extundelete简介" class="headerlink" title="extundelete简介"></a>extundelete简介</h1><p>extundelete通过分析文件系统的日志，解析出所有文件的inode信息，从而恢复ext3，ext4文件系统下被误删的文件。</p><a id="more"></a><h1 id="恢复原理"><a href="#恢复原理" class="headerlink" title="恢复原理"></a>恢复原理</h1><p>利用extundelete恢复文件时并不依赖特定文件格式，首先extundelete会通过文件系统的inode信息来获得当前文件系统下所有文件的信息，包括存在的和已经删除的文件，这些信息包括文件名和inode，然后利用inode信息结合日志去查询inode所在的block位置，包括直接块、间接块等信息。最后利用dd命令将这些信息备份出来，从而恢复数据文件。</p><h1 id="安装extundelete"><a href="#安装extundelete" class="headerlink" title="安装extundelete"></a>安装extundelete</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install extundelete</span><br></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>在数据被误删除后，第一时间要做的是<font color="red">卸载被删除数据所在的磁盘或磁盘分区</font>，如果是系统根分区数据被误删，就需要进入单用户，并将根分区以只读模式挂载。</p><blockquote><p>文件删除后，仅仅是将文件的inode节点中的扇区指针清零，实际文件还存在磁盘上。</p></blockquote><h1 id="恢复单个文件"><a href="#恢复单个文件" class="headerlink" title="恢复单个文件"></a>恢复单个文件</h1><h2 id="建立模拟环境"><a href="#建立模拟环境" class="headerlink" title="建立模拟环境"></a>建立模拟环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /data</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkfs.ext4 /dev/sdb</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount /dev/sdb /data</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /etc/passwd /data</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd /data</span></span><br><span class="line">[root@localhost data]<span class="comment"># md5sum passwd</span></span><br><span class="line">77f4627b23066853af5f2b375be7162d  passwd</span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir /data/test</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "extundelete test" &gt; /data/test/mytest.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 误删除</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf /data/*</span></span><br></pre></td></tr></table></figure><p>以上操作模拟误删除，删除前查看了文件的md5</p><h2 id="卸载磁盘分区"><a href="#卸载磁盘分区" class="headerlink" title="卸载磁盘分区"></a>卸载磁盘分区</h2><p>[root@localhost ~]# umount /dev/data</p><h2 id="查询可恢复的数据信息"><a href="#查询可恢复的数据信息" class="headerlink" title="查询可恢复的数据信息"></a>查询可恢复的数据信息</h2><p>[root@localhost ~]# extundelete /dev/sdb –inode 2<br><img src="https://image.evilpwn.me/blog/extundelete_01.png-sign" alt="可恢复的数据信息"></p><h2 id="恢复单个文件-1"><a href="#恢复单个文件-1" class="headerlink" title="恢复单个文件"></a>恢复单个文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># extundelete /dev/sdb --restore-file passwd</span></span><br></pre></td></tr></table></figure><p><font color="red">–restore-file</font>用来恢复单个文件<br>恢复成功后会在当前目录下，建立一个RECOVERED_FILES目录，用于存放恢复的文件，所有执行extundelete命令的当前目录必须是可写的。<br>恢复后的文件可以对比md5来验证一致性。</p><h1 id="恢复单个目录"><a href="#恢复单个目录" class="headerlink" title="恢复单个目录"></a>恢复单个目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># extundelete /dev/sdb --restore-directory /test</span></span><br></pre></td></tr></table></figure><p><font color="red">--restore-file</font>用来恢复单个目录</p><h1 id="恢复所有误删除的数据"><a href="#恢复所有误删除的数据" class="headerlink" title="恢复所有误删除的数据"></a>恢复所有误删除的数据</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># extundelete /dev/sdb --restore-all</span></span><br></pre></td></tr></table></figure><p><font color="red">--restore-file</font>用来恢复所有被删除的文件或文件夹</p><h1 id="恢复某个时间段的数据"><a href="#恢复某个时间段的数据" class="headerlink" title="恢复某个时间段的数据"></a>恢复某个时间段的数据</h1><h2 id="模拟删除环境"><a href="#模拟删除环境" class="headerlink" title="模拟删除环境"></a>模拟删除环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /data</span></span><br><span class="line">[root@localhost data]<span class="comment"># cp ~/abc.tar.gz /data</span></span><br><span class="line"><span class="comment"># 查看当前时间</span></span><br><span class="line">[root@localhost data]<span class="comment"># date +%s  </span></span><br><span class="line">2319150319</span><br><span class="line"></span><br><span class="line">[root@localhost data]<span class="comment"># rm -rf abc.tar.gz</span></span><br></pre></td></tr></table></figure><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost data]<span class="comment"># cd /mnt</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># umount /data</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># date +%s</span></span><br><span class="line">2319150350</span><br><span class="line"></span><br><span class="line">[root@localhost mnt] extundelete --after 2319150319 --restore-all /dev/sdb</span><br></pre></td></tr></table></figure><p><font color="red">--after和--before</font>用来恢复某个时间段内的数据，后跟的是总秒数（起算时间为1970-01-01 00:00:00 UTC）</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络架构 </category>
          
          <category> 安全运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器集群 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> 数据恢复 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python字典详解</title>
      <link href="/2017/Python-dict/"/>
      <url>/2017/Python-dict/</url>
      
        <content type="html"><![CDATA[<p>字典是一种可变容器模型，python中特有的高级数据结构，针对非数列集合而提供的一种数据类型。</p><a id="more"></a><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>通过任意键值查找集合中值信息，字典是一个键值对的集合，该集合以键为索引，同一个键信息对应一个值。</p><p>在<a href="/2017/Python-basic/" title="[Python基础学习]">[Python基础学习]</a>中也有简单介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure><ul><li>键与值之间用冒号(:)分割，整个字典包括在花括号({})中</li><li>键必须是唯一的，但值则不必。</li><li>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</li><li>字典中键的顺序不是创建时的顺序，python自身会进行优化，使字典的效率更高。</li></ul><h1 id="字典与序列的区别"><a href="#字典与序列的区别" class="headerlink" title="字典与序列的区别"></a>字典与序列的区别</h1><ul><li>存取和访问方式</li><li>键的类型<br>序列只能用数字类型作键，字典可以是数字，字符串或元组，<font color="red">但不能用列表</font></li><li>排序方式<br>序列保持了元素的相对关系，字典为了优化进行了变动</li><li>映射方式<br>序列通过地址映射到值，字典里通过键直接映射到值</li></ul><h1 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h1><h2 id="元素增加-修改-与删除"><a href="#元素增加-修改-与删除" class="headerlink" title="元素增加(修改)与删除"></a>元素增加(修改)与删除</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictName[key]=value</span><br><span class="line"><span class="keyword">del</span> dictName[key]</span><br></pre></td></tr></table></figure><h2 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h2><h3 id="普通遍历"><a href="#普通遍历" class="headerlink" title="普通遍历"></a>普通遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dictName:</span><br><span class="line">    print(key+<span class="string">":"</span>+str(dictName[key]))</span><br></pre></td></tr></table></figure><h3 id="遍历字典的键key"><a href="#遍历字典的键key" class="headerlink" title="遍历字典的键key"></a>遍历字典的键key</h3><p>for key in dictionaryName.keys(): print.(key)</p><h3 id="遍历字典的值value"><a href="#遍历字典的值value" class="headerlink" title="遍历字典的值value"></a>遍历字典的值value</h3><p>for value in dictionaryName.values(): print.(value)</p><h3 id="遍历字典的项"><a href="#遍历字典的项" class="headerlink" title="遍历字典的项"></a>遍历字典的项</h3><p>for item in dicitonaryName.items(): print.(item)</p><h3 id="遍历字典的key-value"><a href="#遍历字典的key-value" class="headerlink" title="遍历字典的key-value"></a>遍历字典的key-value</h3><p>for item，value in adict.items(): print(item, value)</p><h2 id="判断键是否在字典中"><a href="#判断键是否在字典中" class="headerlink" title="判断键是否在字典中"></a>判断键是否在字典中</h2><p>in / not in<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key <span class="keyword">in</span> dictName</span><br></pre></td></tr></table></figure></p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>keys()</td><td>返回一个包含所有key的列表</td></tr><tr><td>values()</td><td>返回一个包含所有value的列表</td></tr><tr><td>items()</td><td>返回一个包含所有键值的列表</td></tr><tr><td>clear()</td><td>删除字典中的所有项目</td></tr><tr><td>get(key[,default=None])</td><td>返回字典中key对应的值，如果值不在字典中返回default值</td></tr><tr><td>pop(key[,default=None])</td><td>删除并返回字典中key对应的值，key值必须给出。 否则，返回default值。</td></tr><tr><td>update(dict2)</td><td>将字典dict2中的键值添加到当前字典中</td></tr></tbody></table><h1 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h1><p>词频统计<br><figure class="highlight py"><figcaption><span>词频统计.py</span><a href="/downloads/code/python/词频统计.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"> </span><br><span class="line"><span class="comment">## 全局变量 ##</span></span><br><span class="line"><span class="comment"># 词频排列显示个数</span></span><br><span class="line">count = <span class="number">10</span></span><br><span class="line"><span class="comment"># 单词频率数组-作为y轴数据</span></span><br><span class="line">data = []</span><br><span class="line"><span class="comment"># 单词数组-作为x轴数据</span></span><br><span class="line">words = []</span><br><span class="line"><span class="comment"># y轴显示放大倍数-可以根据词频数量进行调节</span></span><br><span class="line">yScale = <span class="number">6</span></span><br><span class="line"><span class="comment"># x轴显示放大倍数-可以根据count数量进行调节</span></span><br><span class="line">xScale = <span class="number">30</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">################# Turtle Start  ####################  </span></span><br><span class="line"><span class="comment">#从点(x1,y1)到(x2,y2)绘制线段</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawLine</span><span class="params">(t, x1, y1, x2, y2)</span>:</span></span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto (x1, y1)</span><br><span class="line">    t.pendown()</span><br><span class="line">    t.goto (x2, y2)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在坐标(x,y)处写文字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawText</span><span class="params">(t, x, y, text)</span>:</span></span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto (x, y)</span><br><span class="line">    t.pendown()</span><br><span class="line">    t.write(text)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawGraph</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="comment">#绘制x/y轴线</span></span><br><span class="line">    drawLine (t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">360</span>, <span class="number">0</span>)</span><br><span class="line">    drawLine (t, <span class="number">0</span>, <span class="number">300</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#x轴: 坐标及描述</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(count):</span><br><span class="line">        x=x+<span class="number">1</span> <span class="comment">#向右移一位,为了不画在原点上</span></span><br><span class="line">        drawText(t, x*xScale<span class="number">-4</span>, <span class="number">-20</span>, (words[x<span class="number">-1</span>]))</span><br><span class="line">        drawText(t, x*xScale<span class="number">-4</span>, data[x<span class="number">-1</span>]*yScale+<span class="number">10</span>, data[x<span class="number">-1</span>])</span><br><span class="line">    drawBar(t)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#绘制一个柱体</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawRectangle</span><span class="params">(t, x, y)</span>:</span></span><br><span class="line">    x = x*xScale</span><br><span class="line">    y = y*yScale<span class="comment">#放大倍数显示</span></span><br><span class="line">    drawLine(t, x<span class="number">-5</span>, <span class="number">0</span>, x<span class="number">-5</span>, y)</span><br><span class="line">    drawLine(t, x<span class="number">-5</span>, y, x+<span class="number">5</span>, y)</span><br><span class="line">    drawLine(t, x+<span class="number">5</span>, y, x+<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">    drawLine(t, x+<span class="number">5</span>, <span class="number">0</span>, x<span class="number">-5</span>, <span class="number">0</span>)</span><br><span class="line">     </span><br><span class="line"><span class="comment">#绘制多个柱体</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawBar</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        drawRectangle(t, i+<span class="number">1</span>, data[i])    </span><br><span class="line"><span class="comment">################# Turtle End  ####################</span></span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line"><span class="comment">#对文本的每一行计算词频的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processLine</span><span class="params">(line, wordCounts)</span>:</span></span><br><span class="line">    <span class="comment">#用空格替换标点符号，方便词频计算</span></span><br><span class="line">    line = replacePunctuations(line)</span><br><span class="line">    <span class="comment">#从每一行获取每个词</span></span><br><span class="line">    words = line.split() </span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> wordCounts:</span><br><span class="line">            wordCounts[word] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            wordCounts[word] = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#空格替换标点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replacePunctuations</span><span class="params">(line)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> line:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> <span class="string">"~@#$%^&amp;*()_-+=&lt;&gt;?/,.:;{}[]|\'"</span><span class="string">""</span>:</span><br><span class="line">            line = line.replace(ch, <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#用户输入一个文件名</span></span><br><span class="line">    filename = input(<span class="string">"enter a filename:"</span>).strip()</span><br><span class="line">    infile = open(filename, <span class="string">"r"</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">#建立用于计算词频的空字典</span></span><br><span class="line">    wordCounts = {}</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        processLine(line.lower(), wordCounts) <span class="comment"># 大写转小写，便于统计</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">#从字典中获取数据对</span></span><br><span class="line">    pairs = list(wordCounts.items())</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#列表中的数据对交换位置,数据对排序</span></span><br><span class="line">    items = [[x,y]<span class="keyword">for</span> (y,x)<span class="keyword">in</span> pairs] </span><br><span class="line">    items.sort() </span><br><span class="line"> </span><br><span class="line">    <span class="comment">#输出count个数词频结果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(items)<span class="number">-1</span>, len(items)-count<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        print(items[i][<span class="number">1</span>]+<span class="string">"\t"</span>+str(items[i][<span class="number">0</span>]))</span><br><span class="line">        data.append(items[i][<span class="number">0</span>])</span><br><span class="line">        words.append(items[i][<span class="number">1</span>])</span><br><span class="line">         </span><br><span class="line">    infile.close()</span><br><span class="line">     </span><br><span class="line">    <span class="comment">#根据词频结果绘制柱状图</span></span><br><span class="line">    turtle.title(<span class="string">'词频结果柱状图'</span>)</span><br><span class="line">    turtle.setup(<span class="number">900</span>, <span class="number">750</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    t = turtle.Turtle()</span><br><span class="line">    t.hideturtle()</span><br><span class="line">    t.width(<span class="number">3</span>)</span><br><span class="line">    drawGraph(t)</span><br><span class="line">         </span><br><span class="line"><span class="comment">#调用main()函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h1 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h1><p>合并通讯录（<a href="/2017/Python_file/" title="[Python文件操作]">[Python文件操作]</a>中的实例二，使用的是列表方法）<br>相比与列表，字典更方便<br><figure class="highlight py"><figcaption><span>合并通信录_字典.py</span><a href="/downloads/code/python/合并通信录_字典.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用字典将两个通讯录文本合并为一个文本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        ftele2=open(<span class="string">'TeleAddressBook.txt'</span>,<span class="string">'rb'</span>)</span><br><span class="line">        ftele1=open(<span class="string">'EmailAddressBook.txt'</span>,<span class="string">'rb'</span>)</span><br><span class="line"> </span><br><span class="line">        ftele1.readline()<span class="comment">#跳过第一行</span></span><br><span class="line">        ftele2.readline()</span><br><span class="line">        lines1 = ftele1.readlines()</span><br><span class="line">        lines2 = ftele2.readlines()</span><br><span class="line"> </span><br><span class="line">        dic1 = {}   <span class="comment">#字典方式保存</span></span><br><span class="line">        dic2 = {}</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines1:<span class="comment">#获取第一个本文中的姓名和电话信息</span></span><br><span class="line">                elements = line.split()</span><br><span class="line">                <span class="comment">#将文本读出来的bytes转换为str类型</span></span><br><span class="line">                dic1[elements[<span class="number">0</span>]] = str(elements[<span class="number">1</span>].decode(<span class="string">'gbk'</span>))  <span class="comment"># 将中文写入文本，防止乱码</span></span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines2:<span class="comment">#获取第二个本文中的姓名和电话信息</span></span><br><span class="line">                elements = line.split()</span><br><span class="line">                dic2[elements[<span class="number">0</span>]] = str(elements[<span class="number">1</span>].decode(<span class="string">'gbk'</span>))</span><br><span class="line"> </span><br><span class="line">        <span class="comment">###开始处理###</span></span><br><span class="line">        lines = []</span><br><span class="line">        lines.append(<span class="string">'姓名\t    电话   \t  邮箱\n'</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dic1:</span><br><span class="line">            s= <span class="string">''</span></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> dic2.keys():</span><br><span class="line">        <span class="comment"># 使用join将key与其值合并成一个字符串</span></span><br><span class="line">                    s = <span class="string">'\t'</span>.join([str(key.decode(<span class="string">'gbk'</span>)), dic1[key], dic2[key]])</span><br><span class="line">                    s += <span class="string">'\n'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                    s = <span class="string">'\t'</span>.join([str(key.decode(<span class="string">'gbk'</span>)), dic1[key], str(<span class="string">'   -----   '</span>)])</span><br><span class="line">                    s += <span class="string">'\n'</span></span><br><span class="line">            lines.append(s)</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dic2:</span><br><span class="line">            s= <span class="string">''</span></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> dic1.keys():</span><br><span class="line">                    s = <span class="string">'\t'</span>.join([str(key.decode(<span class="string">'gbk'</span>)), str(<span class="string">'   -----   '</span>), dic2[key]])</span><br><span class="line">                    s += <span class="string">'\n'</span>       </span><br><span class="line">            lines.append(s)</span><br><span class="line"> </span><br><span class="line">        ftele3 = open(<span class="string">'AddressBook.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">        ftele3.writelines(lines)</span><br><span class="line"> </span><br><span class="line">        ftele3.close()</span><br><span class="line">        ftele1.close()</span><br><span class="line">        ftele2.close()</span><br><span class="line">        print(<span class="string">"The addressBooks are merged!"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解OSPF开放式最短路径优先协议</title>
      <link href="/2017/deeply-OSPF/"/>
      <url>/2017/deeply-OSPF/</url>
      
        <content type="html"><![CDATA[<h1 id="RIP缺陷"><a href="#RIP缺陷" class="headerlink" title="RIP缺陷"></a>RIP缺陷</h1><ul><li>以跳数评估的路由并非最优路径</li><li>最大跳数16导致网络尺度小</li><li>收敛速度慢</li><li>更新发送全部路由表浪费网络资源</li></ul><a id="more"></a><h2 id="以跳数评估的路由并非最优路径"><a href="#以跳数评估的路由并非最优路径" class="headerlink" title="以跳数评估的路由并非最优路径"></a>以跳数评估的路由并非最优路径</h2><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_08.png-sign" alt="跳数评估的路由并非最优路径"></p><p>如果RTA选择S0/0传输，传输需时会大大缩短为3s</p><h2 id="最大跳数16导致网络尺度小"><a href="#最大跳数16导致网络尺度小" class="headerlink" title="最大跳数16导致网络尺度小"></a>最大跳数16导致网络尺度小</h2><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_09.png-sign" alt="最大跳数16导致网络尺度小"></p><p>RIP协议限制网络直径不能超过16跳！</p><h2 id="收敛速度慢"><a href="#收敛速度慢" class="headerlink" title="收敛速度慢"></a>收敛速度慢</h2><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_10.png-sign" alt="收敛速度慢"></p><p>RTA和RTB收到路由不可达信息后进入抑制时间<br>抑制时间结束前，即使有新的设备发布路由RTA和RTB的路由也不能更新</p><h2 id="更新发送全部路由表浪费网络资源"><a href="#更新发送全部路由表浪费网络资源" class="headerlink" title="更新发送全部路由表浪费网络资源"></a>更新发送全部路由表浪费网络资源</h2><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_11.png-sign" alt="收敛速度慢"></p><p>假设RTA和RTB各有1000条路由，每条路由需占用20个字节<br>每次路由更新时，RTA和RTB之间单向需消耗至少160Kb的带宽资源</p><p>由此可见，RIP协议并不适合大规模的网络，OSPF可以很好地解决了上述问题，因此得到广泛使用。</p><h1 id="链路状态路由协议的特点"><a href="#链路状态路由协议的特点" class="headerlink" title="链路状态路由协议的特点"></a>链路状态路由协议的特点</h1><ul><li>对网络发生的变化能够快速响应。</li><li>当网络发生变化的时候发送触发式更新（triggered update）。</li><li>发送周期性更新（链路状态刷新），间隔时间为30分钟。</li></ul><p>OSPF是一种链路状态路由选择协议。</p><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_01.png-sign" alt="链路状态协议"></p><p>链路状态路由协议只在网络拓扑发生变化以后产生路由更新。链路状态发生变化后，检测到变化的路由器生成并发送<font color="red">LSA（Link-State Advertisement，链路状态通告）</font>，并通过组播地址发送给所有的邻居路由器。接受到LSA的每个路由器会复制一份LSA，更新它自己的<font color="red">LSDB（Link-State Database）</font>，再将LSA转发给其他邻居。这种扩散机制被称为<font color="red">泛洪（Flooding）</font>。</p><p>OSPF必须维护以下信息：</p><ul><li><p><font color="red">邻居表（neighbor table）</font>：<br>也叫邻接数据库（adjacency database）。存储了邻居路由器的信息，如果一个OSPF路由器和它的邻居路由器失去联系，在几秒中的时间内，它会标记所有到达那条路由均为无效并且重新计算到达目标网络的路径。</p></li><li><p><font color="red">拓扑表（topology table）</font>：<br>一般叫做LSDB，OSPF路由器通过LSA学习到其他的路由器和网络状况,LSA存储在LSDB中。</p></li><li><p><font color="red">路由表（routing table）</font>：<br>也就是我们所说的路由表了，也叫forwarding database，包含了到达目标网络的最佳路径的信息。</p></li></ul><p>链路状态路由协议和距离矢量路由协议<font color="red">（OSPF和RIP）</font>的一个重要区别：距离矢量路由协议是基于流言的路由协议（Routing By Rumors）,即：距离矢量路由协议依靠邻居发给它的信息来作路由决策，而且路由器不需要保持完整的网络信息。而链路状态路由协议的路由器拥有完整的网络信息，而且每个路由器自己做出路由决策。</p><h1 id="OSPF工作机制"><a href="#OSPF工作机制" class="headerlink" title="OSPF工作机制"></a>OSPF工作机制</h1><h2 id="OSPF对比RIP"><a href="#OSPF对比RIP" class="headerlink" title="OSPF对比RIP"></a>OSPF对比RIP</h2><p>OSPF不再采用跳数的概念，而是根据接口的吞吐率、拥塞状况、往返时间、可靠性等实际链路的负载能力定出路由的代价，同时选择最短、最优路由并允许保持到达同一目标地址的多条路由，从而平衡网络负荷；<br>OSPF支持不同服务类型的不同代价，从而实现不同QoS的路由服务；<br>OSPF路由器不再交换路由表，而是同步各路由器对网络状态的认识。</p><table><thead><tr><th>特性</th><th>OSPF</th><th>RIPv2</th><th>RIPv1</th></tr></thead><tbody><tr><td>协议类型</td><td>链路状态</td><td>距离矢量</td><td>距离矢量</td></tr><tr><td>无类支持</td><td>是</td><td>是</td><td>否</td></tr><tr><td>VLSM支持</td><td>是</td><td>是</td><td>否</td></tr><tr><td>自动汇总</td><td>否</td><td>是</td><td>是</td></tr><tr><td>手动汇总</td><td>是</td><td>否</td><td>否</td></tr><tr><td>不连继支持</td><td>是</td><td>是</td><td>否</td></tr><tr><td>路由转播</td><td>可变化转播</td><td>周期性转播</td><td>周期性转播</td></tr><tr><td>路由度量</td><td>宽带</td><td>跳</td><td>跳</td></tr><tr><td>跳计数限制</td><td>无</td><td>15</td><td>15</td></tr><tr><td>会聚</td><td>快</td><td>慢</td><td>慢</td></tr><tr><td>对等认证</td><td>是</td><td>是</td><td>否</td></tr><tr><td>分层网络</td><td>是（使用地区）</td><td>否（只是平面）</td><td>否（只是平面）</td></tr><tr><td>更新</td><td>事件触发</td><td>路由表更新</td><td>路由表更新</td></tr><tr><td>路由计算</td><td>Dijkstra</td><td>Bellman-Ford</td><td>Bellman-Ford</td></tr></tbody></table><h2 id="OSPF邻居关系"><a href="#OSPF邻居关系" class="headerlink" title="OSPF邻居关系"></a>OSPF邻居关系</h2><p><b>广播网络中的Hello报文：</b><br><img src="https://image.evilpwn.me/blog/deeply_OSPF_02.png-sign" alt="广播网络中的Hello报文"><br>交换Hello报文进行邻接：</p><ol><li>路由器和别的路由器交换hello包,目标地址采用多播地址 </li><li>hello包交换完毕，邻接关系形成。</li><li>接下来通过交换LSA和对接收方的确认进行同步LSDB。对于OSPF路由器而言，进入完全邻接状态。</li><li>如果需要的话，路由器转发新的LSA给其他的邻居，来保证整个区域内LSDB的完全同步。</li></ol><h2 id="OSPF泛洪机制"><a href="#OSPF泛洪机制" class="headerlink" title="OSPF泛洪机制"></a>OSPF泛洪机制</h2><p><b>LSA工作原理：</b><br><img src="https://image.evilpwn.me/blog/deeply_OSPF_03.png-sign" alt="LSA工作原理"></p><h2 id="OSPF路由类型"><a href="#OSPF路由类型" class="headerlink" title="OSPF路由类型"></a>OSPF路由类型</h2><p>。。。。。。待补充。。。。。。</p><h2 id="LSDB"><a href="#LSDB" class="headerlink" title="LSDB"></a>LSDB</h2><p>LSA：描述本地路由器或网络的数据单元，对路由器来说，它描述了路由器的接口状态和邻接状态。 </p><table><thead><tr><th>LSA类型</th><th>描述</th></tr></thead><tbody><tr><td>1类</td><td>路由器LSA</td></tr><tr><td>2类</td><td>网络LSA</td></tr><tr><td>3类和4类</td><td>汇总LSA</td></tr><tr><td>5类</td><td>AS外部LSA</td></tr><tr><td>6类</td><td>组播OSPF LSA</td></tr><tr><td>7类</td><td>为次未节区域定义的</td></tr><tr><td>8类</td><td>BGP的外部属性LSA</td></tr><tr><td>9、10或11类</td><td>不透明LSA</td></tr></tbody></table><h2 id="SPF算法"><a href="#SPF算法" class="headerlink" title="SPF算法"></a>SPF算法</h2><blockquote><p>在地区内部,每台路由器都计算到达同一地区中每个网络的最佳/最短路径。这种计算基于拓扑数据库中收集的信息和一种称为最短路径优先(SPF)的算法。假想地区中的每台路由器都会构造一棵树,很像是一棵家谱树,在那里该路由器就是树根,而其他网络则沿树枝和树叶被编排。最短路径树被路由器用来将路由插人到路由表中。<br>如果某个路由器的接口存在于多个地区中,那么需要为每个地区都构建一棵单独的树。在路由器执行SPF算法时,一个关键标准是去往某网络的每个潜在路径的度量或开销值。</p></blockquote><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_04.png-sign" alt="SPF算法"><br>SPF算法也称Dijkstra算法（Dijkstra发明的），是OSPF路由协议的基础。</p><p>。。。。。。待补充。。。。。。</p><h1 id="OSPF报文类型"><a href="#OSPF报文类型" class="headerlink" title="OSPF报文类型"></a>OSPF报文类型</h1><h1 id="邻居状态和数据库同步"><a href="#邻居状态和数据库同步" class="headerlink" title="邻居状态和数据库同步"></a>邻居状态和数据库同步</h1><h1 id="OSPF区域"><a href="#OSPF区域" class="headerlink" title="OSPF区域"></a>OSPF区域</h1><p>将OSPF创建为层次结构的原因包括:</p><ul><li>减少路由选择的开销</li><li>加速会聚（收敛）</li><li>用单一的网络地区来缩小网络的不稳定性</li></ul><p>OSPF区域是一组逻辑上的的OSPF路由器，每个区域都是通过自己的链路状态数据库描述的，而且每台路由器也都只需要维护路由器本身所在的区域的链路状态数据库。</p><h2 id="双层层次化"><a href="#双层层次化" class="headerlink" title="双层层次化"></a>双层层次化</h2><p>OSPF的网络设计要求是双层层次化（2-layer hierarchy），包括如下2层：</p><ul><li><font color="red">中转区域（Backbone或area 0，也叫骨干区域)</font></li><li><font color="red">常规区域（Nonbackbone或areas)</font></li></ul><h3 id="中转区域（骨干区域）"><a href="#中转区域（骨干区域）" class="headerlink" title="中转区域（骨干区域）"></a>中转区域（骨干区域）</h3><p>中转区域主要功能是IP包快速和有效的传输，它互连OSPF其他区域，一般不会出现端用户。</p><h3 id="常规区域"><a href="#常规区域" class="headerlink" title="常规区域"></a>常规区域</h3><p>常规区域主要功能是连接用户和资源，一般根据功能和地理位置划分。一般不允许其他区域的流量通过它到达另一个区域，必须穿越中转区域。</p><h2 id="区域特征"><a href="#区域特征" class="headerlink" title="区域特征"></a>区域特征</h2><ul><li>减少了路由选择表条目。</li><li>将区域内拓扑变化的影响限制在本地。</li><li>将LSA扩散限制在区域内。</li><li>要求采取层次网络设计。</li></ul><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_12.png-sign" alt="OSPF区域"><br>A,B骨干路由器，C,D,E是ABR（区域边界路由器）</p><p>ABR特征：</p><ul><li>分隔LSA泛洪的区域</li><li>是区域间路由汇总的位置</li><li>为每个区域维护LSDB</li></ul><h1 id="虚链路（Virtual-Link）"><a href="#虚链路（Virtual-Link）" class="headerlink" title="虚链路（Virtual Link）"></a>虚链路（Virtual Link）</h1><p>OSPF协议中，骨干区域（Area 0）必须连续，同时也要求每个区域与骨干区域必须直接相连，但是实际组网中，网络情况非常的复杂，有时候在划分区域时，无法保证每个区域都满足这个要求。这个时候就需要使用<font color="red">虚链接（Virtual Link）</font>技术来解决这个问题。</p><blockquote><p>常规区域只能和骨干区域交换LSA，常规区域与常规区域之间即使直连也无法互换LSA，</p></blockquote><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_05.jpg" alt="虚链路"></p><p>虚连接是指在两台ABR（Area Border Routers，区域边界路由器）之间，穿过一个非骨干区域（也称为转换区域，Transit Area），建立的一条逻辑上的连接通道（须在两端的ABR上同时配置）。如上图，在路由器C和路由器E之间建立了一条虚链接，使Area 3和骨干区域Area 0之间有了逻辑连接，Area 1为转换区域。<br>“逻辑通道”是指两台ABR之间的其它运行OSPF的路由器只是转发报文，相当于在两个ABR之间形成了一个点到点的连接。因此在这个连接上，和物理接口一样可以配置接口的各类参数。</p><h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><h3 id="骨干区域被分割"><a href="#骨干区域被分割" class="headerlink" title="骨干区域被分割"></a>骨干区域被分割</h3><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_06.png-sign" alt="骨干区域被分割"></p><h3 id="非骨干区域无法和骨干区域保持连通"><a href="#非骨干区域无法和骨干区域保持连通" class="headerlink" title="非骨干区域无法和骨干区域保持连通"></a>非骨干区域无法和骨干区域保持连通</h3><p><img src="https://image.evilpwn.me/blog/deeply_OSPF_07.png-sign" alt="非骨干区域无法和骨干区域保持连通"></p><h1 id="OSPF网络类型"><a href="#OSPF网络类型" class="headerlink" title="OSPF网络类型"></a>OSPF网络类型</h1><h1 id="OSPF基本配置"><a href="#OSPF基本配置" class="headerlink" title="OSPF基本配置"></a>OSPF基本配置</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      <categories>
          
          <category> 路由与交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由 </tag>
            
            <tag> OSPF协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python文件操作</title>
      <link href="/2017/Python_file/"/>
      <url>/2017/Python_file/</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul><li>存储在外部介质上的数据或信息集合</li><li>有序的数据序列</li></ul><h1 id="常用的编码"><a href="#常用的编码" class="headerlink" title="常用的编码"></a>常用的编码</h1><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><ul><li>7位二进制位编码</li><li>表示128个字符</li><li>最通用的单字节编码</li></ul><a id="more"></a><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><ul><li>跨语言、跨平台</li><li>统一且唯一的二进制编码</li><li>每个字符两个字节长（也称宽字节集（Widechars））</li><li>65535个字符的编码空间</li></ul><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><ul><li>可变长度的Unicode</li></ul><p><b>Unicode与UTF-8编码字节范围对应关系：</b></p><table><thead><tr><th>Unicode符号范围（十六进制）</th><th>UTF-8编码方式（二进制）</th></tr></thead><tbody><tr><td>0000  0000-0000  007F</td><td>0xxxxxxx</td></tr><tr><td>0000  0080-0000  07FF</td><td>110xxxxx  10xxxxx</td></tr><tr><td>0000  0800-0000  FFFF</td><td>1110xxxx  10xxxxx  10xxxxx</td></tr><tr><td>0001  0000-0010  FFFF</td><td>11110xxx  10xxxxx  10xxxxx  10xxxxx</td></tr></tbody></table><h2 id="GBK编码"><a href="#GBK编码" class="headerlink" title="GBK编码"></a>GBK编码</h2><ul><li>《汉字内码扩展规范》</li><li>双字节编码</li></ul><p><font color="red">Python中，字符串类型未编码</font><br>编码：encode(“utf-8”)<br>解码：decode(“utf-8”)</p><h1 id="文件数据"><a href="#文件数据" class="headerlink" title="文件数据"></a>文件数据</h1><ul><li>文本文件</li><li>二进制文件</li></ul><h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><p>以ASCII码方式存储</p><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>照片、音乐、视频、计算机程序等</p><p>优点：1)更加节省空间 2)采用二进制无格式存储 3)表示更为精确</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li>文本文件是基于字符定长的ASIIC。</li><li>二进制文件编码是变长的，灵活利用率高。</li><li>不同二进制文件解码方式不同。</li></ul><h1 id="文件的处理"><a href="#文件的处理" class="headerlink" title="文件的处理"></a>文件的处理</h1><ul><li>打开文件<ul><li>建立磁盘上的文件与程序中的对象相关联</li><li>通过相关的文件对象获得</li></ul></li><li>文件操作<ul><li>读取</li><li>写入</li><li>定位</li><li>其他：追加、计算</li></ul></li><li>关闭文件<ul><li>切断文件与程序的联系</li><li>写入磁盘，并释放文件缓冲区</li></ul></li></ul><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;variable&gt; = open(&lt;name&gt;, &lt;mode&gt;)</span><br><span class="line">&lt;name&gt;磁盘文件名</span><br><span class="line">&lt;mode&gt;打开模式</span><br><span class="line"></span><br><span class="line">infile = open (“numbers.dat”, “r”)</span><br><span class="line">infile = open (“music.mp3”, “rb”)</span><br></pre></td></tr></table></figure><p><b>打开模式</b></p><table><thead><tr><th style="text-align:center"></th><th></th></tr></thead><tbody><tr><td style="text-align:center">r</td><td>只读</td></tr><tr><td style="text-align:center">w</td><td>只写</td></tr><tr><td style="text-align:center">a</td><td>附加文件末尾</td></tr><tr><td style="text-align:center">rb</td><td>只读二进制</td></tr><tr><td style="text-align:center">wb</td><td>只写二进制</td></tr><tr><td style="text-align:center">ab</td><td>附加到二进制文件末尾</td></tr><tr><td style="text-align:center">r+</td><td>读写，写时会附加在文件末尾</td></tr></tbody></table><blockquote><p>若文件不存在，w会创建，其他的（包括rw，r+）都会报错。</p></blockquote><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><ul><li>read([size])<br>从文件读取指定的字符数，如果未给定或为负则读取所有。</li><li>readline([size])<br>读取整行，包括 “\n” 字符，若size小于1行的字符，则读到size处。</li><li>readlines()<br>返回值为整个文件内容的<font color="red">列表</font>，每项是以换行符为结尾的一行字符串。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">file=open(<span class="string">"1.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    line=file.readline()</span><br><span class="line">    print(line[:<span class="number">-1</span>])    <span class="comment"># ①</span></span><br><span class="line">file.close()</span><br><span class="line">------</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">456</span></span><br><span class="line"><span class="number">789</span></span><br><span class="line">------</span><br><span class="line">① 若print(line)，则会输出“\n”：</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="number">789</span></span><br><span class="line"></span><br><span class="line">------</span><br></pre></td></tr></table></figure><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><ul><li>write(str)<br>将字符串写入文件，没有返回值。</li><li>writelines(sequence)<br>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file=open(<span class="string">"1.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">seq=[<span class="string">"123\n"</span>,<span class="string">"456\n"</span>]</span><br><span class="line">file.writelines(seq)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h2 id="文件遍历"><a href="#文件遍历" class="headerlink" title="文件遍历"></a>文件遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = open (someFile, <span class="string">"r"</span>)</span><br><span class="line">For line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="comment">#处理一行文件内容</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p><b>Copy文件实例：</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 输入文件名</span></span><br><span class="line">    f1=input(<span class="string">"souce file:"</span>).strip()</span><br><span class="line">    f2=input(<span class="string">"target file:"</span>).strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Open</span></span><br><span class="line">    infile=open(f1,<span class="string">"r"</span>)</span><br><span class="line">    outfile=open(f2,<span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Copy</span></span><br><span class="line">    countLines=countChars=<span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        countLines+=<span class="number">1</span></span><br><span class="line">        countChars+=len(line)</span><br><span class="line">        outfile.write(line)</span><br><span class="line">    print(countLines,<span class="string">"lines and"</span>,countChars,<span class="string">"chars copied"</span>)</span><br><span class="line"></span><br><span class="line">    infile.close()</span><br><span class="line">    outfile.close()</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="seek"><a href="#seek" class="headerlink" title="seek()"></a>seek()</h2><p>seek() 方法用于移动文件读取指针到指定位置。</p><p>file.seek(offset[, whence])<br>offset：开始的偏移量，也就是代表需要移动偏移的字节数<br>whence：可选，默认值为 0。给offset参数一个定义，表示要从哪个位置开始偏移；0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>file.name  返回文件对象的文件名。</p><h1 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h1><p>与turtle结合，读取文件参数进行画图<br>详见<a href="/2017/Python-turtle/" title="[Python模块——Turtle]">[Python模块——Turtle]</a>中的实例一</p><h1 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h1><p>文件合并<br>合并通讯录</p><figure class="highlight plain"><figcaption><span>TeleAddressBook.txt</span><a href="/downloads/code/python/TeleAddressBook.txt">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名电话号码</span><br><span class="line">王颐笳13691177890</span><br><span class="line">张三13529293939</span><br><span class="line">李斯15811589981</span><br><span class="line">桑迪13010026896</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>EmailAddressBook.txt</span><a href="/downloads/code/python/EmailAddressBook.txt">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名邮箱</span><br><span class="line">王颐笳57320009@qq.com</span><br><span class="line">李斯12211212@qq.com</span><br><span class="line">王五949495968@qq.com</span><br><span class="line">桑迪wqweqe@163.com</span><br></pre></td></tr></table></figure><p>思路：</p><ol><li>分别获取文件中的信息到列表1和列表2，建立合并的列表3。</li><li>遍历列表1中的人，同时在列表2中查找当前联系人的邮箱信息，写入列表3中。</li><li>把列表2中剩余的联系人信息写入列表3中。</li></ol><figure class="highlight python"><figcaption><span>合并通讯录.py</span><a href="/downloads/code/python/合并通讯录.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用字符串和列表将两个通讯录文本合并为一个文本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ftele1=open(<span class="string">'TeleAddressBook.txt'</span>,<span class="string">'rb'</span>) <span class="comment"># 因为文本中有中文，为了确保程序正确处理中文而不出现乱码，此处作为二进制读取</span></span><br><span class="line">    ftele2=open(<span class="string">'EmailAddressBook.txt'</span>,<span class="string">'rb'</span>)</span><br><span class="line"> </span><br><span class="line">    ftele1.readline()<span class="comment"># 跳过第一行</span></span><br><span class="line">    ftele2.readline()</span><br><span class="line">    lines1 = ftele1.readlines()</span><br><span class="line">    lines2 = ftele2.readlines()</span><br><span class="line"> </span><br><span class="line">    list1_name = []  </span><br><span class="line">    list1_tele = []</span><br><span class="line">    list2_name = []  </span><br><span class="line">    list2_email = []</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines1:<span class="comment"># 获取第一个文本中的姓名和电话信息</span></span><br><span class="line">        elements = line.split()</span><br><span class="line">        list1_name.append(str(elements[<span class="number">0</span>].decode(<span class="string">'gbk'</span>)))   <span class="comment"># 将文本读出来的bytes转换为str类型</span></span><br><span class="line">        list1_tele.append(str(elements[<span class="number">1</span>].decode(<span class="string">'gbk'</span>)))   <span class="comment"># 用于解码中文字符，使其正确显示</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines2:<span class="comment">#获取第二个文本中的姓名和邮件信息</span></span><br><span class="line">        elements = line.split()</span><br><span class="line">        list2_name.append(str(elements[<span class="number">0</span>].decode(<span class="string">'gbk'</span>)))  </span><br><span class="line">        list2_email.append(str(elements[<span class="number">1</span>].decode(<span class="string">'gbk'</span>)))</span><br><span class="line"> </span><br><span class="line">    <span class="comment">###开始处理###</span></span><br><span class="line">    lines = []</span><br><span class="line">    lines.append(<span class="string">'姓名\t    电话   \t  邮箱\n'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#按索引方式遍历姓名列表1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1_name)): </span><br><span class="line">        s= <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> list1_name[i] <span class="keyword">in</span> list2_name:</span><br><span class="line">                j = list2_name.index(list1_name[i]) <span class="comment">#找到姓名列表1对应列表2中的姓名索引位置</span></span><br><span class="line">                s = <span class="string">'\t'</span>.join([list1_name[i], list1_tele[i], list2_email[j]])</span><br><span class="line">                s += <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                s = <span class="string">'\t'</span>.join([list1_name[i], list1_tele[i], str(<span class="string">'   -----   '</span>)])</span><br><span class="line">                s += <span class="string">'\n'</span></span><br><span class="line">        lines.append(s)</span><br><span class="line">         </span><br><span class="line">    <span class="comment">#处理姓名列表2中剩余的姓名        </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list2_name)): </span><br><span class="line">        s= <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> list2_name[i] <span class="keyword">not</span> <span class="keyword">in</span> list1_name:</span><br><span class="line">                s = <span class="string">'\t'</span>.join([list2_name[i], str(<span class="string">'   -----   '</span>), list2_email[i]])</span><br><span class="line">                s += <span class="string">'\n'</span></span><br><span class="line">        lines.append(s)  </span><br><span class="line"> </span><br><span class="line">    ftele3 = open(<span class="string">'AddressBook.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    ftele3.writelines(lines)</span><br><span class="line">    ftele3.close()</span><br><span class="line">    ftele1.close()</span><br><span class="line">    ftele2.close()</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"The addressBooks are merged!"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGL简单示例</title>
      <link href="/2017/OpenGL_entry/"/>
      <url>/2017/OpenGL_entry/</url>
      
        <content type="html"><![CDATA[<h1 id="两点距离计算与线段绘制"><a href="#两点距离计算与线段绘制" class="headerlink" title="两点距离计算与线段绘制"></a>两点距离计算与线段绘制</h1><a id="more"></a><figure class="highlight cpp"><figcaption><span>Point.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Point();</span></span><br><span class="line">Point(<span class="keyword">float</span> x=<span class="number">0</span>,<span class="keyword">float</span> y=<span class="number">0</span>,<span class="keyword">float</span> z=<span class="number">0</span>)&#123;<span class="keyword">this</span>-&gt;x=x; <span class="keyword">this</span>-&gt;y=y; <span class="keyword">this</span>-&gt;z=z;&#125;;</span><br><span class="line">Point(Point &amp;p)&#123;x=p.x; y=p.y; z=p.z;&#125;;</span><br><span class="line">~Point()&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> y;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> z;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">float</span> dx=<span class="number">0</span>,<span class="keyword">float</span> dy=<span class="number">0</span>,<span class="keyword">float</span> dz=<span class="number">0</span>)</span></span>&#123;x+=dx; y+=dy; z+=dz;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line"><span class="keyword">float</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>Line.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Line();</span><br><span class="line">Line(Point &amp;a,Point &amp;b);</span><br><span class="line">Line(Line &amp;line);</span><br><span class="line">~Line()&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Point p1;</span><br><span class="line">Point p2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::Line():p1(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),p2(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::Line(Point &amp;a, Point &amp;b):p1(a),p2(b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::Line(Line &amp;line):p1(line.p1),p2(line.p2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Line::getLength()&#123;</span><br><span class="line"><span class="keyword">float</span> x=p1.getX()-p2.getX();</span><br><span class="line"><span class="keyword">float</span> y=p1.getY()-p2.getY();</span><br><span class="line"><span class="keyword">float</span> z=p1.getZ()-p2.getZ();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y+z*z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;  // codeblocks要导入，VS无所谓</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;      // OPenGL实用工具库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Line.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include "include/glut.h"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx=<span class="number">0</span>, dy=<span class="number">0</span>; <span class="comment">// 平移变量</span></span><br><span class="line"><span class="keyword">float</span> angle=<span class="number">0</span>;  <span class="comment">// 旋转角度</span></span><br><span class="line"><span class="keyword">int</span> mouseX=<span class="number">0</span>,mouseY=<span class="number">0</span>; <span class="comment">//鼠标位置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> XL=<span class="number">100</span>,XR=<span class="number">300</span>,YB=<span class="number">100</span>,YT=<span class="number">300</span>;</span><br><span class="line"><span class="comment">//const int LEFT=1,RIGHT=2,BOTTOM=4,TOP=8;</span></span><br><span class="line">Point A,B;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);  <span class="comment">// 设置背景颜色</span></span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_PROJECTION);       <span class="comment">// 设置投影参数</span></span><br><span class="line">    gluOrtho2D(<span class="number">-300.0</span>, <span class="number">300.0</span>, <span class="number">-200</span>, <span class="number">200.0</span>); <span class="comment">// 设置场景的大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按上下左右键移动图形</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (key)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> GLUT_KEY_LEFT:dx -= <span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GLUT_KEY_RIGHT:dx += <span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GLUT_KEY_UP:dy += <span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GLUT_KEY_DOWN:dy -= <span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按下鼠标左键记下当前位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseButtonDown</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> action,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key==GLUT_LEFT_BUTTON &amp;&amp; action==GLUT_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        mouseX=x;</span><br><span class="line">        mouseY=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动鼠标确定旋转角度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMotion</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    angle+=<span class="number">360</span>*(mouseY-y)/<span class="number">1600</span>;</span><br><span class="line">    mouseX=x;</span><br><span class="line">    mouseY=y;</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    glColor3f(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);      <span class="comment">// 设置画图颜色</span></span><br><span class="line">    glLineWidth(<span class="number">3</span>);</span><br><span class="line">    glPointSize(<span class="number">5</span>);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslatef(dx,dy,<span class="number">0</span>);</span><br><span class="line">    glRotatef(angle,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*glBegin(GL_LINE_LOOP);</span></span><br><span class="line"><span class="comment">        glVertex2i(XL,YT);</span></span><br><span class="line"><span class="comment">        glVertex2i(XL,YB);</span></span><br><span class="line"><span class="comment">        glVertex2i(XR,YB);</span></span><br><span class="line"><span class="comment">        glVertex2i(XR,YT);</span></span><br><span class="line"><span class="comment">    glEnd( );*/</span></span><br><span class="line">    <span class="comment">/*glBegin(GL_POLYGON);</span></span><br><span class="line"><span class="comment">        glVertex2i(10,10);</span></span><br><span class="line"><span class="comment">        glVertex2i(200,30);</span></span><br><span class="line"><span class="comment">        glVertex2i(100,100);</span></span><br><span class="line"><span class="comment">        glVertex2i(-10,10);</span></span><br><span class="line"><span class="comment">        glVertex2i(-200,30);</span></span><br><span class="line"><span class="comment">        glVertex2i(-100,-100);</span></span><br><span class="line"><span class="comment">    glEnd();*/</span></span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">        glVertex2f(A.getX(),A.getY());</span><br><span class="line">        glVertex2f(B.getX(),B.getY());</span><br><span class="line">    glEnd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glPopMatrix();</span><br><span class="line">    glFlush();     <span class="comment">// 处理绘图pipeLine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x1,x2,y1,y2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Input two plane Points:"</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">    Point a(x1,y1),b(x2,y2);</span><br><span class="line">    A=a,B=b;</span><br><span class="line">    <span class="function">Line <span class="title">line</span><span class="params">(a,b)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Length is "</span>&lt;&lt;line.getLength()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    glutInit(&amp;argc, argv);  <span class="comment">// 初始化GLUT环境</span></span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);   <span class="comment">// GLUT显示模式：单缓冲区、RGB颜色模型</span></span><br><span class="line">    glutInitWindowPosition(<span class="number">50</span>, <span class="number">100</span>);   <span class="comment">// 窗口左上角的位置</span></span><br><span class="line">    glutInitWindowSize(<span class="number">800</span>, <span class="number">600</span>);      <span class="comment">// 显示窗口的大小</span></span><br><span class="line">    glutCreateWindow(<span class="string">"An Example of OpenGL"</span>); <span class="comment">// 创建显示窗口，加上标题</span></span><br><span class="line"></span><br><span class="line">    init( );</span><br><span class="line">    glutDisplayFunc(draw);           <span class="comment">// 调用绘图函数</span></span><br><span class="line">    glutSpecialFunc(move); <span class="comment">// 功能键响应</span></span><br><span class="line">    glutMouseFunc(mouseButtonDown);  <span class="comment">// 鼠标按键响应</span></span><br><span class="line">    glutMotionFunc(mouseMotion);     <span class="comment">// 鼠标移动响应</span></span><br><span class="line">    glutMainLoop( ); <span class="comment">// 进入事件处理循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sudoers文件详解</title>
      <link href="/2017/sudoers_file/"/>
      <url>/2017/sudoers_file/</url>
      
        <content type="html"><![CDATA[<h1 id="sudoers文件详解"><a href="#sudoers文件详解" class="headerlink" title="sudoers文件详解"></a>sudoers文件详解</h1><p>/etc/sudoers 是sudo的配置文件</p><p>缺省配置：root    ALL=(ALL) ALL</p><p>配置方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user  ALL=(ALL) ALL</span><br><span class="line">user  ALL=(ALL) NOPASSWD: ALL</span><br><span class="line"><span class="comment">#用户 主机=(身份) 命令</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>具体如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudoers file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file MUST be edited with the 'visudo' command as root.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See the sudoers man page for the details on how to write a sudoers file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Host alias specification</span></span><br><span class="line"><span class="comment"># User alias specification</span></span><br><span class="line"><span class="comment"># Cmnd alias specification</span></span><br><span class="line"><span class="comment"># Defaults specification</span></span><br><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL) ALL</span><br><span class="line"><span class="comment"># Uncomment to allow people in group wheel to run all commands</span></span><br><span class="line"><span class="comment"># %wheel        ALL=(ALL)       ALL</span></span><br><span class="line"><span class="comment"># Same thing without a password</span></span><br><span class="line"><span class="comment"># %wheel        ALL=(ALL)       NOPASSWD: ALL</span></span><br><span class="line"><span class="comment"># Samples</span></span><br><span class="line"><span class="comment"># %users  ALL=/sbin/mount /cdrom,/sbin/umount /cdrom</span></span><br><span class="line"><span class="comment"># %users  localhost=/sbin/shutdown -h now</span></span><br></pre></td></tr></table></figure></p><h1 id="配置一"><a href="#配置一" class="headerlink" title="配置一"></a>配置一</h1><p><b>最简单的配置</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user  ALL=(ALL) ALL</span><br><span class="line">user  ALL=(ALL) NOPASSWD: ALL</span><br><span class="line">#用户 主机=(身份) 命令</span><br></pre></td></tr></table></figure></p><p>普通用户user登陆后，执行<code>sudo su -</code>输入自己的密码(或不输密码)，然后就能够执行root权限的所有命令</p><h1 id="配置二"><a href="#配置二" class="headerlink" title="配置二"></a>配置二</h1><p><b>让普通用户user只能在某几台服务器上，执行root能执行的某些命令</b><br>先配置Alias（别名），这样在配置权限时，会方便些，Alias主要分成4种：<br>Host_Alias<br>Cmnd_Alias<br>User_Alias<br>Runas_Alias</p><h2 id="Host-Alias：主机列表"><a href="#Host-Alias：主机列表" class="headerlink" title="Host_Alias：主机列表"></a>Host_Alias：主机列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host_Alias      HOST_FLAG = hostname1, hostname2, hostname3</span><br></pre></td></tr></table></figure><h2 id="Cmnd-Alias：允许执行的命令列表，命令前加上-表示不能执行此命令。"><a href="#Cmnd-Alias：允许执行的命令列表，命令前加上-表示不能执行此命令。" class="headerlink" title="Cmnd_Alias：允许执行的命令列表，命令前加上!表示不能执行此命令。"></a>Cmnd_Alias：允许执行的命令列表，命令前加上!表示不能执行此命令。</h2><p>命令一定要使用<font color="red">绝对路径</font>，避免其他目录的同名命令被执行，造成安全隐患 ,因此使用的时候也是使用绝对路径。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmnd_Alias      COMMAND_FLAG = command1, command2, command3, !command4</span><br></pre></td></tr></table></figure></p><h2 id="User-Alias：具有sudo权限的用户列表"><a href="#User-Alias：具有sudo权限的用户列表" class="headerlink" title="User_Alias：具有sudo权限的用户列表"></a>User_Alias：具有sudo权限的用户列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User_Alias      USER_FLAG = user1, user2, user3</span><br></pre></td></tr></table></figure><h2 id="Runas-Alias：用户以什么身份执行（例如root，或者oracle）的列表"><a href="#Runas-Alias：用户以什么身份执行（例如root，或者oracle）的列表" class="headerlink" title="Runas_Alias：用户以什么身份执行（例如root，或者oracle）的列表"></a>Runas_Alias：用户以什么身份执行（例如root，或者oracle）的列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runas_Alias     RUNAS_FLAG = operator1, operator2, operator3</span><br></pre></td></tr></table></figure><h2 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER_FLAG HOST_FLAG=(RUNAS_FLAG) COMMAND_FLAG</span><br><span class="line">   用户     主机   = (身份)       命令</span><br><span class="line">若不需要密码验证：</span><br><span class="line">USER_FLAG HOST_FLAG=(RUNAS_FLAG) NOPASSWD: COMMAND_FLAG</span><br></pre></td></tr></table></figure><p><b>配置示例：</b><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudoers file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This file MUST be edited with the 'visudo' command as root.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See the sudoers man page for the details on how to write a sudoers file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Host alias specification</span></span><br><span class="line">Host_Alias      HOSTS = 192.168.1.1, 192.168.1.2</span><br><span class="line"><span class="comment"># User alias specification</span></span><br><span class="line"><span class="comment"># Cmnd alias specification</span></span><br><span class="line">Cmnd_Alias      SQUID = /opt/vtbin/squid_refresh, !/sbin/service, /bin/rm</span><br><span class="line">Cmnd_Alias      ADMPW = /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd, !/usr/bin/passwd root</span><br><span class="line"><span class="comment"># Defaults specification</span></span><br><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root    ALL=(ALL) ALL</span><br><span class="line">user HOSTS=(ALL) NOPASSWD: SQUID</span><br><span class="line">user HOSTS=(ALL) NOPASSWD: ADMPW</span><br><span class="line"><span class="comment"># Uncomment to allow people in group wheel to run all commands</span></span><br><span class="line"><span class="comment"># %wheel        ALL=(ALL)       ALL</span></span><br><span class="line"><span class="comment"># Same thing without a password</span></span><br><span class="line"><span class="comment"># %wheel        ALL=(ALL)       NOPASSWD: ALL</span></span><br><span class="line"><span class="comment"># Samples</span></span><br><span class="line"><span class="comment"># %users  ALL=/sbin/mount /cdrom,/sbin/umount /cdrom</span></span><br><span class="line"><span class="comment"># %users  localhost=/sbin/shutdown -h now</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux网络架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器集群 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器安全运维</title>
      <link href="/2017/Server-security-operations/"/>
      <url>/2017/Server-security-operations/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器安全运维"><a href="#服务器安全运维" class="headerlink" title="服务器安全运维"></a>服务器安全运维</h1><h2 id="删除特殊的用户和用户组"><a href="#删除特殊的用户和用户组" class="headerlink" title="删除特殊的用户和用户组"></a>删除特殊的用户和用户组</h2><ul><li><p>可删除用户<br>adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher等。</p></li><li><p>可删除用户组<br>adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers等。</p></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# userdel games</span><br><span class="line">[root@localhost ~]# groupdel games</span><br></pre></td></tr></table></figure><p>有时，某些用户仅仅作用进程调用或者用户组调用，并不需要登陆功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# usermod -s /sbin/nologin nagios</span><br></pre></td></tr></table></figure></p><h2 id="关闭系统不需要的服务"><a href="#关闭系统不需要的服务" class="headerlink" title="关闭系统不需要的服务"></a>关闭系统不需要的服务</h2><p>运行服务越多，系统越不安全。</p><ul><li>一般可以关闭的服务<br>anacron、auditd、autofs、avahi-daemon、avahi-dnsconfd、bluetooth、cpuspeed、firstboot、gpm、haldaemon、hidd、ip6tables、ipsec、isdn、lpd、mcstrans、messagebus、netfs、nfs、nfslock、nscd、pcscd portmap、readahead_early、restorecond、rpcgssd、rpcidmapd、rstatd、sendmail、setroubleshoot、yppasswdd ypserv</li></ul><p>通过chkconfig命令关闭服务的自动启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 345 bluetooth off</span><br></pre></td></tr></table></figure></p><blockquote><p>level<br>0：关机；1：单用户；2：无网络的多用户命令行模式；3：有网络的多用户命令行模式；4：不可用；5：带推行界面的多用户模式；6：重新启动。</p></blockquote><p><b>系统运行必须的服务</b></p><table><thead><tr><th style="text-align:center">服务名称</th><th>服务内容</th></tr></thead><tbody><tr><td style="text-align:center">acpid</td><td>电源管理，建议开启</td></tr><tr><td style="text-align:center">apmd</td><td>高级电源能源管理服务，可监控电池性能</td></tr><tr><td style="text-align:center">kudzu</td><td>检测硬件是否变化的服务，建议开启</td></tr><tr><td style="text-align:center">crond</td><td>为Linux下自动安排的进程提供运行服务，建议开启</td></tr><tr><td style="text-align:center">atd</td><td>类似crond，提供在指定的时间做指定的事情的服务，与windows下的计划任务功能相同</td></tr><tr><td style="text-align:center">keytables</td><td>用于装载入镜像键盘</td></tr><tr><td style="text-align:center">iptables</td><td>Linux内置的访华强软件，为了系统安全，必须开启</td></tr><tr><td style="text-align:center">xinetd</td><td>支持多种网络服务的核心守候进程，建议开启</td></tr><tr><td style="text-align:center">xfs</td><td>使用X Windows 桌面系统必需的服务</td></tr><tr><td style="text-align:center">network</td><td>激活已配置网络接口的脚本程序，也就是启动网络服务，必须必须要启动</td></tr><tr><td style="text-align:center">sshd</td><td>提供远程登陆Linux上的服务，为了系统维护方便，一般建议开启</td></tr><tr><td style="text-align:center">syslog</td><td>记录系统日志的服务，很重要，建议开启</td></tr></tbody></table><h2 id="密码安全策略"><a href="#密码安全策略" class="headerlink" title="密码安全策略"></a>密码安全策略</h2><p>Linux远程登陆有两种认证方式：密码认证和密钥认证。<br>密钥认证：公钥存储在远程服务器上，专用密钥保存在本地，登陆时进行配对认证。</p><blockquote><p>SSH 全称Secure SHell</p></blockquote><p>配置方法：</p><ol><li><p>使用rz命令将公钥上传到服务器，然后导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[user@localhost ~]$ ssh-keygen -i -f Identity.pub &gt;&gt; ~/.ssh/authorized_key2</span><br></pre></td></tr></table></figure></li><li><p>修改SSH2的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd-config</span><br><span class="line"></span><br><span class="line">修改如下几个配置：</span><br><span class="line">Protocol 2  # 仅允许使用SSH2</span><br><span class="line">PubkeyAuthentication yes  # 启用PublicKey认证</span><br><span class="line">AuthorizedkeyFile .ssh/authorized_key2   # PublicKey文件路径</span><br><span class="line">PasswordAuthentication no   # 不使用口令认证</span><br></pre></td></tr></table></figure></li><li><p>重启sshd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br><span class="line">或</span><br><span class="line">/etc/rc.d/init.d/sshd restart</span><br></pre></td></tr></table></figure></li></ol><h2 id="合理使用su，sudo命令"><a href="#合理使用su，sudo命令" class="headerlink" title="合理使用su，sudo命令"></a>合理使用su，sudo命令</h2><p>为了保证服务器的安全，几乎所有服务器都禁止了超级用户直接登陆系统，而是通过普通用户登陆系统，然后通过su命令切换超级用户下，执行一些需要超级权限的工作。</p><p>sudo命令允许系统管理员分配给普通用户一些合理的“权力”，并且不需要普通用户指导超级用户密码。sudo相对于权限无限制的su命令来说，比较安全，所以，sudo也成为受限制的su。</p><h3 id="sudoers文件"><a href="#sudoers文件" class="headerlink" title="sudoers文件"></a>sudoers文件</h3><p>/etc/sudoers 是sudo的配置文件</p><p>缺省配置：root    ALL=(ALL) ALL</p><a href="/2017/sudoers_file/" title="[sudoers文件详解]">[sudoers文件详解]</a><p>配置/etc/sudoers来使普通用户具有特殊权限。</p><p><b>设计sudo的宗旨是：赋予用户尽可能少的权限但仍允许他们完成自己的工作。</b>兼顾了安全性和易用性。</p><hr><h1 id="网络安全运维"><a href="#网络安全运维" class="headerlink" title="网络安全运维"></a>网络安全运维</h1><p>test</p><h1 id="数据安全工具-DRBD、extundelete"><a href="#数据安全工具-DRBD、extundelete" class="headerlink" title="数据安全工具 DRBD、extundelete"></a>数据安全工具 DRBD、extundelete</h1><p>test</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络架构 </category>
          
          <category> 安全运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器集群 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python模块——Turtle</title>
      <link href="/2017/Python-turtle/"/>
      <url>/2017/Python-turtle/</url>
      
        <content type="html"><![CDATA[<h1 id="turtle简介"><a href="#turtle简介" class="headerlink" title="turtle简介"></a>turtle简介</h1><p>turtle 海龟绘图</p><a id="more"></a><h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><p>用turtle画一个python小蟒蛇<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawSnake</span><span class="params">(rad,angle,len,neckrad)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len):</span><br><span class="line">        turtle.circle(rad,angle)   <span class="comment"># 圆形轨迹爬行，rad半径（找到原点，开始画圆）   </span></span><br><span class="line">        turtle.circle(-rad,angle)  <span class="comment"># 正表示原点在轨迹左侧，负表示在轨迹右侧</span></span><br><span class="line">    turtle.circle(rad,angel/<span class="number">2</span>)     <span class="comment"># angle表示沿圆形爬行的弧度值</span></span><br><span class="line"></span><br><span class="line">    turtle.fd(rad)             <span class="comment"># turtle.forward();表示向前直线爬行，参数表距离</span></span><br><span class="line">    turtle.circle(neckrad+<span class="number">1</span>,<span class="number">180</span>)</span><br><span class="line">    turtle.fd(rad*<span class="number">2</span>/<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    turtle.setup(<span class="number">1300</span>,<span class="number">800</span>,<span class="number">0</span>,<span class="number">0</span>)  <span class="comment"># 在屏幕左上角创建一个1300x800的画布</span></span><br><span class="line">    pythonsize=<span class="number">30</span>               <span class="comment"># 轨迹宽度为30像素</span></span><br><span class="line">    turtle.pensize(pythonsize)</span><br><span class="line">    turtle.pencolor(<span class="string">"blue"</span>)     <span class="comment"># 轨迹颜色,也可输入RPG，如："#3B9909"</span></span><br><span class="line">    turtle.seth(<span class="number">-40</span>)            <span class="comment"># 初始轨迹方向，参数为角度值</span></span><br><span class="line">    drawSnake(<span class="number">40</span>,<span class="number">80</span>,<span class="number">5</span>,pythonsize/<span class="number">2</span>)   <span class="comment"># 绘制</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p><img src="https://image.evilpwn.me/blog/Python_turtle_01.gif" alt="小蟒蛇"></p><h1 id="库函数详解"><a href="#库函数详解" class="headerlink" title="库函数详解"></a>库函数详解</h1><h2 id="画笔绘制状态函数（共3个）"><a href="#画笔绘制状态函数（共3个）" class="headerlink" title="画笔绘制状态函数（共3个）"></a>画笔绘制状态函数（共3个）</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pendown()</td><td>放下画笔</td></tr><tr><td>pendup()</td><td>提起画笔，与pendown()配对使用</td></tr><tr><td>pensize(width)</td><td>设置画笔线条的粗细为指定大小</td></tr></tbody></table><h2 id="画笔运动函数（共13个）"><a href="#画笔运动函数（共13个）" class="headerlink" title="画笔运动函数（共13个）"></a>画笔运动函数（共13个）</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>forward()</td><td>沿着当前方向前进指定距离</td></tr><tr><td>backward()</td><td>沿着当前相反方向后退指定距离</td></tr><tr><td>right(angle)</td><td>向右旋转angle角度</td></tr><tr><td>left(angle)</td><td>向左旋转angle角度</td></tr><tr><td>goto(x,y)</td><td>移动到绝对坐标（x,y）处</td></tr><tr><td>setx()</td><td>将当前x轴移动到指定位置</td></tr><tr><td>sety()</td><td>将当前y轴移动到指定位置</td></tr><tr><td>setheading(angle)</td><td>设置当前朝向为angle角度</td></tr><tr><td>home()</td><td>设置当前画笔位置为原点，朝向东</td></tr><tr><td>circle(step)</td><td>绘制一个指定半径，角度、以及绘制步骤step的圆</td></tr><tr><td>dot(r,color)</td><td>绘制一个指定半径r和颜色color的圆点</td></tr><tr><td>undo()</td><td>撤销画笔最后一步动作</td></tr><tr><td>speed()</td><td>设置画笔的绘制速度，参数为0-10之间</td></tr></tbody></table><h2 id="画笔颜色和字体函数（共11个）"><a href="#画笔颜色和字体函数（共11个）" class="headerlink" title="画笔颜色和字体函数（共11个）"></a>画笔颜色和字体函数（共11个）</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>color()</td><td>设置画笔的颜色</td></tr><tr><td>begin_fill()</td><td>填充图形前，调用该方法</td></tr><tr><td>end_fill()</td><td>填充图形结束</td></tr><tr><td>filling()</td><td>返回填充的状态，True为填充，False为未填充</td></tr><tr><td>clear()</td><td>清空当前窗口，但不改变当前画笔的位置</td></tr><tr><td>reset()</td><td>清空当前窗口，并重置位置等状态为默认值</td></tr><tr><td>screensize()</td><td>设置画布的长和宽</td></tr><tr><td>hideturtle()</td><td>隐藏画笔的turtle形状</td></tr><tr><td>showturtle()</td><td>显示画笔的turtle形状</td></tr><tr><td>isvisible()</td><td>如果turtle 可见，则返回True</td></tr><tr><td>write(str,font=None)</td><td>输出font字体的字符串</td></tr></tbody></table><h1 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h1><p>根据数据文件在窗口中动态路径绘制<br><figure class="highlight python"><figcaption><span>动态路径绘制.py</span><a href="/downloads/code/python/动态路径绘制.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#设置窗口信息</span></span><br><span class="line">    turtle.title(<span class="string">'数据驱动的动态路径绘制'</span>)</span><br><span class="line">    turtle.setup(<span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">#设置画笔</span></span><br><span class="line">    pen = turtle.Turtle()</span><br><span class="line">    pen.color(<span class="string">"red"</span>)</span><br><span class="line">    pen.width(<span class="number">5</span>)</span><br><span class="line">    pen.shape(<span class="string">"turtle"</span>)</span><br><span class="line">    pen.speed(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">#读取文件</span></span><br><span class="line">    result=[]</span><br><span class="line">    file = open(<span class="string">"data.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        result.append(list(map(float, line.split(<span class="string">','</span>))))</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment">#动态绘制</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)):</span><br><span class="line">        pen.color((result[i][<span class="number">3</span>],result[i][<span class="number">4</span>],result[i][<span class="number">5</span>]))</span><br><span class="line">        pen.forward(result[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> result[i][<span class="number">1</span>]:</span><br><span class="line">            pen.rt(result[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pen.lt(result[i][<span class="number">2</span>])</span><br><span class="line">    pen.goto(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><figcaption><span>data.txt</span><a href="/downloads/code/python/data01.txt">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">300,0,144,1,0,0</span><br><span class="line">300,0,144,0,1,0</span><br><span class="line">300,0,144,0,0,1</span><br><span class="line">300,0,144,1,1,0</span><br><span class="line">300,0,108,0,1,1</span><br><span class="line">184,0,72,1,0,1</span><br><span class="line">184,0,72,0,0,0</span><br><span class="line">184,0,72,0,0,0</span><br><span class="line">184,0,72,0,0,0</span><br><span class="line">184,1,72,1,0,1</span><br><span class="line">184,1,72,0,0,0</span><br><span class="line">184,1,72,0,0,0</span><br><span class="line">184,1,72,0,0,0</span><br><span class="line">184,1,72,0,0,0</span><br><span class="line">184,1,720,0,0,0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> Python </tag>
            
            <tag> turtle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>H3C-NAPT配置</title>
      <link href="/2017/H3C-NAPT/"/>
      <url>/2017/H3C-NAPT/</url>
      
        <content type="html"><![CDATA[<h1 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h1><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><img src="https://image.evilpwn.me/blog/H3C-NAPT-01.png-sign" alt="拓扑图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 全网互通 ###</span><br><span class="line">[RT1]ip route-static 0.0.0.0 0 192.68.0.2</span><br><span class="line">[RT2]ip route-static 0.0.0.0 0 192.68.0.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">### NAPT配置 ###</span><br><span class="line">[RT1]acl basic 2001</span><br><span class="line">[RT1-acl-ipv4-basic-2001]rule permit source 10.0.0.0 0.0.0.255</span><br><span class="line">[RT1]nat address-group 1</span><br><span class="line">[RT1-address-group-1]address 192.68.0.11 192.68.0.20</span><br><span class="line">[RT1-address-group-1]int g 0/1</span><br><span class="line">[RT1-GigabitEthernet0/1]nat outbound 2001 address-group 1</span><br><span class="line"></span><br><span class="line">[RT2]acl basic 2001</span><br><span class="line">[RT2-acl-ipv4-basic-2001]rule permit source 20.0.0.0 0.0.0.255</span><br><span class="line">[RT2]nat address-group 1</span><br><span class="line">[RT2-address-group-1]address 192.68.0.21 192.68.0.30</span><br><span class="line">[RT2-address-group-1]int g 0/1</span><br><span class="line">[RT2-GigabitEthernet0/1]nat outbound 2001 address-group 1</span><br></pre></td></tr></table></figure><ul><li>结果验证：<br>dis nat session verbose<br><img src="https://image.evilpwn.me/blog/H3C-NAPT-02.png-sign" alt="RT1"><br>PC1报文：<br><img src="https://image.evilpwn.me/blog/H3C-NAPT-03.png-sign" alt="PC1"><br>PC2报文：<br><img src="https://image.evilpwn.me/blog/H3C-NAPT-04.png-sign" alt="PC2"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路由与交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H3C </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>H3C基础配置</title>
      <link href="/2017/H3C-cmd/"/>
      <url>/2017/H3C-cmd/</url>
      
        <content type="html"><![CDATA[<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="信息查看命令"><a href="#信息查看命令" class="headerlink" title="信息查看命令"></a>信息查看命令</h2><ul><li><font color="red">查看当前配置</font>：display current-configuration</li><li><font color="red">显示接口信息</font>：display interface</li><li><font color="red">显示接口ip状态与配置</font>：display ip interface brief</li><li>显示系统统计信息：display diagnostic-information</li><li>查看历史命令记录：display history-command</li></ul><a id="more"></a><h2 id="设备管理命令"><a href="#设备管理命令" class="headerlink" title="设备管理命令"></a>设备管理命令</h2><ul><li>进入系统视图：system-view</li><li>配置设备名称：sysname</li><li>配置系统时间：clock datetime</li><li>显示系统时间：display clock</li><li>配置欢迎/提示信息：header</li></ul><h1 id="Telnet配置"><a href="#Telnet配置" class="headerlink" title="Telnet配置"></a>Telnet配置</h1><p><img src="https://image.evilpwn.me/blog/h3c-basic-01.png-sign" alt="实验一"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;RT1&gt;system-view</span><br><span class="line">[RT1]sysname client</span><br><span class="line">[client]interface GigabitEthernet 0/0/0</span><br><span class="line">[client-GigabitEthernet0/0/0]ip add 192.168.1.1 24</span><br><span class="line">[client-GigabitEthernet0/0/0]quit</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;RT2&gt;system-view</span><br><span class="line">[RT2]sysname server</span><br><span class="line">[server]int GigabitEthernet 0/0/0</span><br><span class="line">[server-GigabitEthernet0/0/0]ip add 192.168.1.2 24</span><br><span class="line">[server-GigabitEthernet0/0/0]quit</span><br><span class="line">[server]ping 192.168.1.1</span><br><span class="line">  PING 192.168.1.1: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=1 ttl=255 time=34 ms</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=2 ttl=255 time=16 ms</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=3 ttl=255 time=15 ms</span><br><span class="line">    Reply from 192.168.1.1: bytes=56 Sequence=4 ttl=255 time=16 ms</span><br><span class="line">Reply from 192.168.1.1: bytes=56 Sequence=5 ttl=255 time=16 ms</span><br><span class="line">[server]telnet server enable                         # 开启telnet</span><br><span class="line">[server]local-user test                              # 添加本地用户</span><br><span class="line">[server-luser-test]password simple admin             # 设置密码</span><br><span class="line">[server-luser-test]service-type telnet               # 设置服务类型</span><br><span class="line">[server-luser-test]authorization-attribute level 3   # 设置用户级别（新版最高为15）</span><br><span class="line">[server-luser-test]quit</span><br><span class="line">[server]user-interface vty 0 4                       # 虚拟用户数量</span><br><span class="line">[server-ui-vty0-4]authentication-mode scheme         # 验证模式设为混合验证</span><br></pre></td></tr></table></figure><h1 id="VLAN与链路聚合"><a href="#VLAN与链路聚合" class="headerlink" title="VLAN与链路聚合"></a>VLAN与链路聚合</h1><p><img src="https://image.evilpwn.me/blog/h3c-basic-02.png-sign" alt="实验二"><br>SW2为网关设备，SW2和SW1之间采用端口聚合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;SW1&gt;system-view</span><br><span class="line">[SW1]vl 10                                        # 进入vl视图（不是int vl 10）</span><br><span class="line">[SW1-vlan10]port E 0/4/1                          # 把接口接入vl</span><br><span class="line">[SW1-vlan10]quit</span><br><span class="line">[SW1]int e 0/4/0</span><br><span class="line">[SW1-Ethernet0/4/0]port link-type trunk           # 配置trunk</span><br><span class="line">[SW1-Ethernet0/4/0]port trunk permit vl all       # 允许所有vl通过</span><br><span class="line"> Please wait........................................... Done.</span><br><span class="line"></span><br><span class="line">### 端口聚合 ###</span><br><span class="line">[SW1]int Bridge-Aggregation 1                     # 创建链路聚合组</span><br><span class="line">[SW1-Bridge-Aggregation1]int e 0/4/3</span><br><span class="line">[SW1-Ethernet0/4/3]port link-aggregation group 1  # 接入聚合组1</span><br><span class="line">[SW1-Ethernet0/4/3]int e 0/4/4                  </span><br><span class="line">[SW1-Ethernet0/4/4]port link-aggregation group 1</span><br><span class="line">[SW1-Ethernet0/4/4]int e 0/4/5                  </span><br><span class="line">[SW1-Ethernet0/4/5]port link-aggregation group 1</span><br><span class="line">[SW1-Ethernet0/4/5]quit</span><br><span class="line">[SW1]int Bridge-Aggregation 1 </span><br><span class="line">[SW1-Bridge-Aggregation1]port link-type trunk           # 配置聚合端口trunk</span><br><span class="line">[SW1-Bridge-Aggregation1]port trunk permit vl all       # 允许所有vl通过</span><br></pre></td></tr></table></figure></p><h2 id="其他配置："><a href="#其他配置：" class="headerlink" title="其他配置："></a>其他配置：</h2><ul><li>设置trunk端口的缺省vlan<br>[Switch-Ethernet1/0/1] port trunk pvid vlan vlan-id</li><li>配置端口的链路类型为Hybrid类型<br>[Switch-Ethernet1/0/1] port link-type hybrid</li><li>允许指定的VLAN通过当前Hybrid端口<br>[Switch-Ethernet1/0/1] port hybrid vlan vlan-id-list { tagged | untagged }</li><li>设置Hybrid端口的缺省VLAN<br>[Switch-Ethernet1/0/1] port hybrid pvid vlan vlan-id</li></ul><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p><img src="https://image.evilpwn.me/blog/h3c-basic-03.png-sign" alt="实验三"><br>在交换机SW2上配置多个dhcp地址池，分配给不同vlan，利用静态路由实现全网互通，RT2和RT3使用dhcp分配ip。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">### DHCP配置 ###</span><br><span class="line">[SW2]dhcp server forbidden-ip 192.168.10.1 192.168.10.10   # DHCP服务中不参与分配的地址（范围）</span><br><span class="line"></span><br><span class="line">[SW2]dhcp server ip-pool 1                                 # 创建DHCP地址池1</span><br><span class="line">[SW2-dhcp-pool-1]network 192.168.10.0 mask 255.255.255.0   # 配置动态分配的ip地址范围</span><br><span class="line">[SW2-dhcp-pool-1]gateway-list 192.168.10.254     # 配置DHCP客户端分配的网关地址</span><br><span class="line">[SW2-dhcp-pool-1]dns-list 10.10.10.10            # 配置DHCP客户端分配的DNS服务器地址</span><br><span class="line">[SW2-dhcp-pool-1]expired day 1                   # 配置动态分配的IP地址的租用有效期限</span><br><span class="line">[SW2-dhcp-pool-1]qu</span><br><span class="line"></span><br><span class="line">[SW2]dhcp server ip-pool 2                                 # 创建DHCP地址池2</span><br><span class="line">[SW2-dhcp-pool-1]network 192.168.20.0 mask 255.255.255.0   # 配置动态分配的ip地址范围</span><br><span class="line">[SW2-dhcp-pool-1]gateway-list 192.168.20.254     # 配置DHCP客户端分配的网关地址</span><br><span class="line">[SW2-dhcp-pool-1]dns-list 20.20.20.20            # 配置DHCP客户端分配的DNS服务器地址</span><br><span class="line">[SW2-dhcp-pool-1]expired day 1                   # 配置动态分配的IP地址的租用有效期限</span><br><span class="line">[SW2-dhcp-pool-1]qu</span><br><span class="line"></span><br><span class="line">[SW2]dhcp enable     # dhcp开启</span><br><span class="line"></span><br><span class="line">### vl配置 ###</span><br><span class="line"># vl10 虚拟接口配dhcp地址池1中的地址，这里兼网关192.168.10.254 #</span><br><span class="line"># vl20 虚拟接口配dhcp地址池2中的地址，这里兼网关192.168.20.254 #</span><br><span class="line"># E 0/4/0 配置trunk，允许所有vl通过 #</span><br><span class="line"></span><br><span class="line">### 配置 G 0/0/0 ###</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RT2/RT3端口开启dhcp自动获取</span><br><span class="line">[RT-GigabitEthernet0/0/×]ip add dhcp-alloc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RT4配置ip和静态路由到172.16.10.254</span><br></pre></td></tr></table></figure><h1 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h1><p><img src="https://image.evilpwn.me/blog/h3c-basic-04.png-sign" alt="单臂路由"><br>RT2,3,4模拟PC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vlan-type dot1q vid 10  # 单臂路由协议封装</span><br></pre></td></tr></table></figure></p><h1 id="OSPF单、多区域"><a href="#OSPF单、多区域" class="headerlink" title="OSPF单、多区域"></a>OSPF单、多区域</h1><h2 id="单区域配置"><a href="#单区域配置" class="headerlink" title="单区域配置"></a>单区域配置</h2><p><img src="https://image.evilpwn.me/blog/h3c-basic-05.png-sign" alt="OSPF单区域"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[RTA] interface loopback 0</span><br><span class="line">[RTA-loopback-0]ip address 1.1.1.1 255.255.255.255</span><br><span class="line">[RTA-loopback-0]quit</span><br><span class="line">[RTA] router id 1.1.1.1    # 配置路由id</span><br><span class="line">[RTA] ospf                 # 启动ospf进程</span><br><span class="line">[RTA-ospf-1] area 0        # 配置ospf区域</span><br><span class="line">[RTA-ospf-1-area-0.0.0.0] network 1.1.1.1 0.0.0.0   # 在指定接口上启动ospf</span><br><span class="line">[RTA-ospf-1-area-0.0.0.0] network 10.0.0.0 0.0.0.255</span><br><span class="line">[RTA-ospf-1-area-0.0.0.0] network 20.0.0.0 0.0.0.255</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[RTB]interface loopback 0</span><br><span class="line">[RTB-loopback-0]ip address 2.2.2.2 255.255.255.255</span><br><span class="line">[RTB-loopback-0]quit</span><br><span class="line">[RTB]route id 2.2.2.2</span><br><span class="line">[RTB]ospf 1</span><br><span class="line">[RTB-ospf-1]area 0</span><br><span class="line">[RTB-ospf-1-area-0.0.0.0]network 2.2.2.2 0.0.0.0</span><br><span class="line">[RTB-ospf-1-area-0.0.0.0]network 10.0.0.0 0.0.0.255</span><br><span class="line">[RTB-ospf-1-area-0.0.0.0]network 30.0.0.0 0.0.0.255</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[RTC]interface loopback 0</span><br><span class="line">[RTC-loopback-0]ip address 3.3.3.3 255.255.255.255</span><br><span class="line">[RTC-loopback-0]quit</span><br><span class="line">[RTC]router id 3.3.3.3</span><br><span class="line">[RTC]ospf 1</span><br><span class="line">[RTC-ospf-1]area 0</span><br><span class="line">[RTC-ospf-1-area-0.0.0.0]network 3.3.3.3 0.0.0.0</span><br><span class="line">[RTC-ospf-1-area-0.0.0.0]network 20.0.0.0 0.0.0.255</span><br><span class="line">[RTC-ospf-1-area-0.0.0.0]network 30.0.0.0 0.0.0.255</span><br></pre></td></tr></table></figure><h2 id="多区域-1"><a href="#多区域-1" class="headerlink" title="多区域 1"></a>多区域 1</h2><p><img src="https://image.evilpwn.me/blog/h3c-basic-06.png-sign" alt="OSPF多区域"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RTA和RTC配置域单区域OSPF配置相同。</span><br><span class="line">RTB需要加入两个区域，RTA和RTC有到达彼此的路由。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[RTB] interface loopback 0</span><br><span class="line">[RTB-loopback-0] ip address 2.2.2.2 255.255.255.255</span><br><span class="line">[RTB-loopback-0] quit</span><br><span class="line">[RTB] route id 2.2.2.2</span><br><span class="line">[RTB] ospf 100</span><br><span class="line">[RTB-ospf-100] area 0</span><br><span class="line">[RTB-ospf-100-area-0.0.0.0] network 2.2.2.2 0.0.0.0</span><br><span class="line">[RTB-ospf-100-area-0.0.0.0] network 10.0.0.0 0.0.0.255</span><br><span class="line">[RTB-ospf-100-area-0.0.0.0] quit</span><br><span class="line">[RTB-ospf-100] area 192.168.10.1</span><br><span class="line">[RTB-ospf-100-area-192.168.10.1] network 20.0.0.0 0.0.0.255</span><br></pre></td></tr></table></figure><h2 id="多区域-2"><a href="#多区域-2" class="headerlink" title="多区域 2"></a>多区域 2</h2><p>虚链接（Virtual Link）建立</p><ul><li>解决骨干区域被分割的问题<br><img src="https://image.evilpwn.me/blog/h3c-basic-07.png-sign" alt="OSPF多区域"></li><li><p>解决非骨干区域无法和骨干区域保持连通的问题<br><img src="https://image.evilpwn.me/blog/h3c-basic-08.png-sign" alt="OSPF多区域"></p></li><li><p><font color="red">配置虚连接命令</font><br>[Router-ospf-area-0.0.0.1] vlink-peer router-id [hello seconds | retransmit seconds | trans-delay seconds | dead seconds]</p></li></ul><p><img src="https://image.evilpwn.me/blog/h3c-basic-09.png-sign" alt="OSPF多区域"></p><h2 id="其他配置：-1"><a href="#其他配置：-1" class="headerlink" title="其他配置："></a>其他配置：</h2><ul><li>配置OSPF接口优先级：<br>[Router-Ethernet0/0] ospf dr-priority priority </li><li>配置OSPF接口cost：<br>[Router-Ethernet0/0] ospf cost value </li><li>显示OSPF摘要<br>[Router] display ospf brief</li><li>显示启动OSPF的接口信息<br>[Router] display ospf interface</li><li>显示OSPF的出错信息<br>[Router] display ospf error</li><li>显示OSPF的进程信息<br>[Router] display ospf INTEGER<1-16635></1-16635></li><li>OSPF事件调试信息<br><router> debugging ospf event</router></li><li>OSPF链路状态通告调试<br><router> debugging ospf lsa</router></li><li>OSPF包调试信息<br><router> debugging ospf packet</router></li><li>OSPF路由计算调试信息<br><router> debugging ospf spf</router></li><li>OSPF进程调试信息<br><router> debugging ospf INTEGER<1-65535></1-65535></router></li></ul><h1 id="ACL访问列表详解"><a href="#ACL访问列表详解" class="headerlink" title="ACL访问列表详解"></a>ACL访问列表详解</h1><h2 id="通配符掩码"><a href="#通配符掩码" class="headerlink" title="通配符掩码"></a>通配符掩码</h2><ul><li>通配符号掩码和IP地址结合使用以描述一个地址范围</li><li>通配符掩码和子网掩码相似，但含义不同<br>0表示对应位须比较<br>1表示对应位不比较</li></ul><table><thead><tr><th style="text-align:center">IP地址</th><th style="text-align:center">通配符掩码</th><th style="text-align:center">表示的地址范围</th></tr></thead><tbody><tr><td style="text-align:center">192.168.0.1</td><td style="text-align:center">0.0.0.255</td><td style="text-align:center">192.168.0.0/24</td></tr><tr><td style="text-align:center">192.168.0.1</td><td style="text-align:center">0.0.3.255</td><td style="text-align:center">192.168.0.0/22</td></tr><tr><td style="text-align:center">192.168.0.1</td><td style="text-align:center">0.255.255.255</td><td style="text-align:center">192.168.0.0/8</td></tr><tr><td style="text-align:center">192.168.0.1</td><td style="text-align:center">0.0.0.0</td><td style="text-align:center">192.168.0.0</td></tr><tr><td style="text-align:center">192.168.0.1</td><td style="text-align:center">255.255.255.255</td><td style="text-align:center">0.0.0.0/0</td></tr><tr><td style="text-align:center">192.168.0.1</td><td style="text-align:center">0.0.2.255</td><td style="text-align:center">192.168.0.0/24 或 192.168.2.0/24<br>有歧义，一般没这种情况</td></tr></tbody></table><h2 id="ACL标识"><a href="#ACL标识" class="headerlink" title="ACL标识"></a>ACL标识</h2><ul><li>数字序号标识</li></ul><table><thead><tr><th style="text-align:center">访问控制列表的分类</th><th style="text-align:center">数字序号的范围</th></tr></thead><tbody><tr><td style="text-align:center">基本访问控制列表</td><td style="text-align:center">2000-2999</td></tr><tr><td style="text-align:center">扩展访问控制列表</td><td style="text-align:center">3000-3999</td></tr><tr><td style="text-align:center">基于二层的访问控制列表</td><td style="text-align:center">4000-4999</td></tr><tr><td style="text-align:center">用户自定义的访问控制列表</td><td style="text-align:center">5000-5999</td></tr></tbody></table><ul><li>名称标识</li></ul><blockquote><p>基本ACL：根据报文的源MAC地址、目的MAC地址、802.1p优先级、二层协议类型等二层信息制定匹配规则<br>高级ACL：根据报文的源IP地址、目的IP地址、IP承载的协议类型、协议特性等三、四层信息制定规则<br>二层ACL：根据报文的源MAC地址、目的MAC地址、802.1p优先级、二层协议类型等二层信息制定匹配规则<br>用户自定义ACL：根据任意位置的任意字串制定匹配规则（报文的报文头、IP头等为基准，指定从第几个字节开始与掩码进行“与”操作，将从报文提取出来的字符串和用户定义的字符串进行比较，找到匹配的报文。）</p></blockquote><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a><font color="red">配置流程</font></h2><ul><li>启动包过滤防火墙功能，设置默认的过滤规则 </li><li>根据需要选择合适的ACL分类</li><li>创建正确的规则<br>设置匹配条件<br>设置合适的动作（Permit/Deny)</li><li>在路由器的接口上应用ACL，并指明过滤报文的方向（入站/出站）</li></ul><h2 id="ACL配置"><a href="#ACL配置" class="headerlink" title="ACL配置"></a>ACL配置</h2><p>要求PCA不能访问NetworkA和NetworkB，但可以访问其他所有网络<br>两种部署方案：</p><ol><li><p>高级ACL部署：<br><img src="https://image.evilpwn.me/blog/h3c-basic-11.png-sign" alt="高级ACL"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[RTC] firewall enable      # 开启防火墙   </span><br><span class="line">### firewall default &#123; permit | deny &#125; # 防火墙默认是permit，此处可以不更改</span><br><span class="line">[RTC] acl number 3000      # 指定ACL序号</span><br><span class="line">[RTC-acl-adv-3000] rule deny ip source 172.16.0.1 0 destination 192.168.0.0 0.0.1.255  # 定义规则</span><br><span class="line">[RTC-Ethernet0/0] firewall packet-filter 3000 inbound  # 应用到接口</span><br></pre></td></tr></table></figure></li><li><p>基本ACL部署：<br><img src="https://image.evilpwn.me/blog/h3c-basic-12.png-sign" alt="基本ACL"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[RTA] firewall enable</span><br><span class="line">[RTA] acl number 2000</span><br><span class="line">[RTA-acl-basic-2000] rule deny source 172.16.0.1 0</span><br><span class="line">[RTA-Ethernet0/1] firewall packet-filter 2000 inbound</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul><li><p>配置高级IPv4 ACL<br>高级IPv4 ACL的序号取值范围为3000～3999<br>定义规则来匹配源IP地址、目的IP地址、IP承载的协议类型、协议端口号等信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sysname-acl-adv-3000] rule [ rule-id ] &#123; deny | permit &#125; protocol [ destination &#123; dest-addr dest-wildcard | any &#125; | destination-port operator port1 [ port2 ] established | fragment | source &#123; sour-addr sour-wildcard | any &#125; | source-port operator port1 [ port2 ] | time-range time-name]</span><br></pre></td></tr></table></figure></li><li><p>配置二层 ACL，<br>二层ACL的序号取值范围为4000～4999<br>定义规则来匹配源MAC地址、目的MAC地址、802.1p优先级、二层协议类型等二层信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sysname-acl-ethernetframe-3000] rule [ rule-id ] &#123; deny | permit &#125; [ cos vlan-pri | dest-mac dest-addr dest-mask | lsap lsap-code lsap-wildcard | source-mac sour-addr source-mask | time-range time-name]</span><br></pre></td></tr></table></figure></li><li><p>禁止FTP、telnet等协议<br>[SW1-acl-adv-3001]rule 0 deny tcp source 192.168.10.0 0.0.0.255 destination 192.168.1.2 0.0.0.255 destination-port eq telnet</p></li></ul><h2 id="ACL包过滤的局限性"><a href="#ACL包过滤的局限性" class="headerlink" title="ACL包过滤的局限性"></a>ACL包过滤的局限性</h2><ol><li>ACL包过滤防火墙是根据数据包头中的二、三、四层信息来进行报文过滤的，对应用层的信息无法识别<ul><li>无法根据用户名来决定数据是否通过</li><li>无法给不同的用户授予不同的权限级别</li></ul></li><li>ACL包过滤防火墙是静态防火墙，无法对应用层协议进行动态检测</li></ol><h1 id="综合实验1"><a href="#综合实验1" class="headerlink" title="综合实验1"></a>综合实验1</h1><p>在学校内部署一个小型中心机房，组网如下图，RT1、RT2属于不同VLAN，并且能够通过自动湖区地址的方式配置IP地址，网关在核心层交换机上，并且与下行链路构成聚合链路，在所有交换机和路由器上配置telnet服务器，能够远程通过自己电脑登陆上去，配置合理的路由协议达到全网互通。<br><img src="https://image.evilpwn.me/blog/h3c-basic-10.png-sign" alt="综合实验1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">SW1</span><br><span class="line">[SW1]vl 10</span><br><span class="line">[SW1-vlan10]int vl 10</span><br><span class="line">[SW1-Vlan-interface10]ip add 192.168.10.254 24</span><br><span class="line">[SW1-Vlan-interface10]vl 20</span><br><span class="line">[SW1-vlan20]int vl 20</span><br><span class="line">[SW1-Vlan-interface20]ip add 192.168.20.254 24</span><br><span class="line">[SW1-Vlan-interface20]qu</span><br><span class="line">[SW1]</span><br><span class="line">[SW1]dhcp server ip-pool 1</span><br><span class="line">[SW1-dhcp-pool-1]net 192.168.10.0 24</span><br><span class="line">[SW1-dhcp-pool-1]gateway-list 192.168.10.254</span><br><span class="line">[SW1-dhcp-pool-1]dns-list 10.10.10.10</span><br><span class="line">[SW1-dhcp-pool-1]expired day 1</span><br><span class="line">[SW1-dhcp-pool-1]qu</span><br><span class="line">[SW1]</span><br><span class="line">[SW1]dhcp server ip-pool 2</span><br><span class="line">[SW1-dhcp-pool-2]net 192.168.20.0 24</span><br><span class="line">[SW1-dhcp-pool-2]gateway-list 192.168.20.254</span><br><span class="line">[SW1-dhcp-pool-2]dns-list 20.20.20.20</span><br><span class="line">[SW1-dhcp-pool-2]qu</span><br><span class="line">[SW1]</span><br><span class="line">[SW1]dhcp enable</span><br><span class="line">DHCP is enabled successfully!</span><br><span class="line"></span><br><span class="line">[SW1]int g 0/0/0</span><br><span class="line">[SW1-GigabitEthernet0/0/0]ip add 192.168.1.1 24</span><br><span class="line">[SW1-GigabitEthernet0/0/0]qu</span><br><span class="line">[SW1]</span><br><span class="line">[SW1]</span><br><span class="line">[SW1]int Bridge-Aggregation 1</span><br><span class="line">[SW1-Bridge-Aggregation1]int e 0/4/2</span><br><span class="line">[SW1-Ethernet0/4/2]port link-aggregation group 1</span><br><span class="line">%Sep  8 08:25:47:453 2011 SW1 LAGG/5/LAGG_ACTIVE: Member port Ethernet0/4/2 of aggregation group BAGG1 becomes ACTIVE.</span><br><span class="line">%Sep  8 08:25:47:453 2011 SW1 IFNET/3/LINK_UPDOWN: Bridge-Aggregation1 link status is UP.</span><br><span class="line">[SW1-Ethernet0/4/2]int e 0/4/3                  </span><br><span class="line">[SW1-Ethernet0/4/3]port link-aggregation group 1</span><br><span class="line">%Sep  8 08:25:52:515 2011 SW1 LAGG/5/LAGG_ACTIVE: Member port Ethernet0/4/3 of aggregation group BAGG1 becomes ACTIVE.</span><br><span class="line">[SW1-Ethernet0/4/3]int Bridge-Aggregation 1     </span><br><span class="line">[SW1-Bridge-Aggregation1]port link-type trunk </span><br><span class="line">[SW1-Bridge-Aggregation1]port trunk permit vl all</span><br><span class="line"> Please wait...</span><br><span class="line">%Sep  8 08:26:14:422 2011 SW1 IFNET/3/LINK_UPDOWN: Vlan-interface10 link status is UP.</span><br><span class="line">%Sep  8 08:26:14:422 2011 SW1 IFNET/5/LINEPROTO_UPDOWN: Line protocol on the interface Vlan-interface10 is UP.</span><br><span class="line">%Sep  8 08:26:14:422 2011 SW1 IFNET/3/LINK_UPDOWN: Vlan-interface20 link status is UP.</span><br><span class="line">%Sep  8 08:26:14:422 2011 SW1 IFNET/5/LINEPROTO_UPDOWN: Line protocol on the interface Vlan-interface20 is UP......................................... Done.</span><br><span class="line"> Configuring Ethernet0/4/2........................................... Done.</span><br><span class="line"> Configuring Ethernet0/4/3........................................... Done.</span><br><span class="line">[SW1-Bridge-Aggregation1]qu</span><br><span class="line">[SW1]</span><br><span class="line">[SW1] </span><br><span class="line">[SW1]ospf </span><br><span class="line">[SW1-ospf-1]a 0</span><br><span class="line">[SW1-ospf-1-area-0.0.0.0]net 192.168.10.0 0.0.0.255</span><br><span class="line">[SW1-ospf-1-area-0.0.0.0]net 192.168.20.0 0.0.0.255</span><br><span class="line">[SW1-ospf-1-area-0.0.0.0]qu</span><br><span class="line">[SW1-ospf-1]a 1 </span><br><span class="line">[SW1-ospf-1-area-0.0.0.1]net 192.168.1.0 0.0.0.255</span><br><span class="line">[SW1-ospf-1-area-0.0.0.1]qu</span><br><span class="line">[SW1-ospf-1]qu</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SW2</span><br><span class="line">[SW2]vl 10</span><br><span class="line">[SW2-vlan10]port e 0/4/0</span><br><span class="line">[SW2-vlan10]vl 20</span><br><span class="line">[SW2-vlan20]port e 0/4/1</span><br><span class="line">[SW2-vlan20]qu</span><br><span class="line">[SW2]</span><br><span class="line">[SW2]int Bridge-Aggregation 1 </span><br><span class="line">[SW2-Bridge-Aggregation1]int e 0/4/2</span><br><span class="line">[SW2-Ethernet0/4/2]port link-aggregation group 1</span><br><span class="line">[SW2-Ethernet0/4/2]</span><br><span class="line">[SW2-Ethernet0/4/2]int e 0/4/3</span><br><span class="line">[SW2-Ethernet0/4/3]port link-aggregation group 1</span><br><span class="line">[SW2-Ethernet0/4/3]qu    </span><br><span class="line">[SW2]</span><br><span class="line">[SW2]int Bridge-Aggregation 1</span><br><span class="line">[SW2-Bridge-Aggregation1]port link-type trunk </span><br><span class="line">[SW2-Bridge-Aggregation1]port trunk permit vl all</span><br><span class="line"> Please wait........................................... Done.</span><br><span class="line"> Configuring Ethernet0/4/2........................................... Done.</span><br><span class="line"> Configuring Ethernet0/4/3........................................... Done.</span><br><span class="line">[SW2-Bridge-Aggregation1]</span><br><span class="line">[SW2]</span><br><span class="line">[SW2]</span><br><span class="line">[SW2]int vl 10</span><br><span class="line">[SW2-Vlan-interface10]ip add 192.168.10.100 24</span><br><span class="line">[SW2-Vlan-interface10]qu</span><br><span class="line">[SW2]ip route-static 0.0.0.0 0  192.168.10.254          </span><br><span class="line">[SW2]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RT1</span><br><span class="line">[RT1-GigabitEthernet0/0/0]ip add dhcp-alloc</span><br><span class="line"></span><br><span class="line">RT2</span><br><span class="line">[RT2-GigabitEthernet0/0/1]ip add dhcp-alloc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RT3</span><br><span class="line">[RT3]int g 0/0/0 </span><br><span class="line">[RT3-GigabitEthernet0/0/0]ip ad 192.168.1.2 24</span><br><span class="line">[RT3-GigabitEthernet0/0/0]int g 0/0/1</span><br><span class="line">[RT3-GigabitEthernet0/0/1]ip add 172.16.10.1 26</span><br><span class="line">[RT3-GigabitEthernet0/0/1]qu</span><br><span class="line">[RT3]</span><br><span class="line">[RT3]</span><br><span class="line">[RT3]ospf</span><br><span class="line">[RT3-ospf-1]a 1</span><br><span class="line">[RT3-ospf-1-area-0.0.0.1]net 172.16.10.0 0.0.0.63</span><br><span class="line">[RT3-ospf-1-area-0.0.0.1]net 192.168.1.0 0.0.0.255</span><br><span class="line">[RT3-ospf-1-area-0.0.0.1]qu</span><br><span class="line">[RT3-ospf-1]qu</span><br><span class="line">[RT3]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RT4</span><br><span class="line">[RT4]int g 0/0/1</span><br><span class="line">[RT4-GigabitEthernet0/0/1]ip add 172.16.10.2 26</span><br><span class="line">[RT4-GigabitEthernet0/0/1]qu</span><br><span class="line">[RT4]</span><br><span class="line">[RT4]ospf </span><br><span class="line">[RT4-ospf-1]a 1</span><br><span class="line">[RT4-ospf-1-area-0.0.0.1]net 172.16.10.0 0.0.0.63</span><br><span class="line">[RT4-ospf-1-area-0.0.0.1]int g 0/0/0 </span><br><span class="line">[RT4-GigabitEthernet0/0/0]ip add 202.114.10.1 24</span><br><span class="line">[RT4-GigabitEthernet0/0/0]qu</span><br><span class="line">[RT4]ospf</span><br><span class="line">[RT4-ospf-1]a 1</span><br><span class="line">[RT4-ospf-1-area-0.0.0.1]net 202.114.10.0 0.0.0.255</span><br><span class="line">[RT4-ospf-1-area-0.0.0.1]qu</span><br><span class="line">[RT4-ospf-1]</span><br><span class="line">[RT4-ospf-1]</span><br><span class="line">[RT4-ospf-1]int g 0/0/0               </span><br><span class="line">[RT4-GigabitEthernet0/0/0]ip add 202.114.10.1 24</span><br><span class="line">[RT4-GigabitEthernet0/0/0]qu</span><br><span class="line">[RT4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RT1-telnet配置</span><br><span class="line">[RT1]telnet server enable</span><br><span class="line">% Start Telnet server</span><br><span class="line">[RT1]user-interface vty 0 4</span><br><span class="line">[RT1-ui-vty0-4]set authentication password simple 123456</span><br><span class="line">[RT1-ui-vty0-4]authentication-mode password</span><br><span class="line">[RT1-ui-vty0-4]user privilege level 3</span><br><span class="line">[RT1-ui-vty0-4]qu</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 路由与交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H3C </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python内置函数</title>
      <link href="/2017/Python-built-in-functions/"/>
      <url>/2017/Python-built-in-functions/</url>
      
        <content type="html"><![CDATA[<p>内置函数<br><a id="more"></a></p><h1 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(*objects, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=sys.stdout)</span><br><span class="line"></span><br><span class="line">- objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。</span><br><span class="line">- sep -- 用来间隔多个对象，默认值是一个空格。</span><br><span class="line">- end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。</span><br><span class="line">- file -- 要写入的文件对象。</span><br></pre></td></tr></table></figure><h1 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h1><p>str.format()<br>格式化字符串，通过<code>{}</code>和<code>:</code>代替以前的<code>%</code>。<br><b>format 函数可以接受不限个参数，位置可以不按顺序。</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'world hello world'</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment"># 设置参数</span></span><br><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(name=<span class="string">"百度"</span>, url=<span class="string">"www.baidu.com"</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">"name"</span>: <span class="string">"百度"</span>, <span class="string">"url"</span>: <span class="string">"www.baidu.com"</span>&#125;</span><br><span class="line">print(<span class="string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">'百度'</span>, <span class="string">'www.baidu.com'</span>]</span><br><span class="line">print(<span class="string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span>.format(my_list))  <span class="comment"># "0" 是可选的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上输出结果均为：</span></span><br><span class="line">网站名：百度, 地址 www.baidu.com</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment"># 向 str.format() 传入对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignValue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line">print(<span class="string">'value 为: &#123;0.value&#125;'</span>.format(my_value))  <span class="comment"># "0" 是可选的</span></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">value 为: <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p><b>数字格式化</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:.2f&#125;"</span>.format(<span class="number">3.1415926</span>));</span><br><span class="line"><span class="number">3.14</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>数字</th><th>格式</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>3.1415926</td><td>{:.2f}</td><td>3.14</td><td>保留小数点后两位</td></tr><tr><td>3.1415926</td><td>{:+.2f}</td><td>+3.14</td><td>带符号保留小数点后两位</td></tr><tr><td>-1</td><td>{:+.2f}</td><td>-1.00</td><td>带符号保留小数点后两位</td></tr><tr><td>2.71828</td><td>{:.0f}</td><td>3</td><td>不带小数</td></tr><tr><td>5</td><td>{:0&gt;2d}</td><td>05</td><td>数字补零 (填充左边, 宽度为2)</td></tr><tr><td>5</td><td>{:x&lt;4d}</td><td>5xxx</td><td>数字补x (填充右边, 宽度为4)</td></tr><tr><td>10</td><td>{:x&lt;4d}</td><td>10xx</td><td>数字补x (填充右边, 宽度为4)</td></tr><tr><td>1000000</td><td>{:,}</td><td>1,000,000</td><td>以逗号分隔的数字格式</td></tr><tr><td>0.25</td><td>{:.2%}</td><td>25.00%</td><td>百分比格式</td></tr><tr><td>1000000000</td><td>{:.2e}</td><td>1.00e+09</td><td>指数记法</td></tr><tr><td>13</td><td>{:10d}</td><td>13</td><td>右对齐 (默认, 宽度为10)</td></tr><tr><td>13</td><td>{:&lt;10d}</td><td>13</td><td>左对齐 (宽度为10)</td></tr><tr><td>13</td><td>{:^10d}</td><td>13</td><td>中间对齐 (宽度为10)</td></tr><tr><td>11</td><td>‘{:b}’.format(11)<br>‘{:d}’.format(11)<br>‘{:o}’.format(11)<br>‘{:x}’.format(11)<br>‘{:#x}’.format(11)<br>‘{:#X}’.format(11)<br></td><td>1011<br>11<br>13<br>b<br>0xb<br>0XB<br></td><td>进制转换</td></tr></tbody></table><p><code>^</code>, <code>&lt;</code>, <code>&gt;</code>分别是居中、左对齐、右对齐，后面带宽度<br><code>:</code>后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。<br><code>+</code>表示在正数前显示<code>+</code>，负数前显示<code>-</code>；<code></code>（空格）表示在正数前加空格<br>b、d、o、x 分别是二进制、十进制、八进制、十六进制。<br>其他：<br>c 输出整数对应的Unicode字符<br>e 输出浮点数对应的小写字母e的指数形式<br>E 输出浮点数对应的大写字母E的指数形式</p><p>此外，还可以使用大括号<code>{}</code>来转义大括号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;"</span>.format(<span class="string">"abc"</span>))</span><br><span class="line"><span class="comment"># abc 对应的位置是 &#123;0&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="eval-和-repr"><a href="#eval-和-repr" class="headerlink" title="eval() 和 repr()"></a>eval() 和 repr()</h1><p>eval()：将字符串当成有效的Python表达式来求值并返回计算结果。<br>repr()：将Python的变量和表达式转换为字符串表示<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">eval(<span class="string">'x+1'</span>)</span><br><span class="line">eval(<span class="string">'x==1'</span>)</span><br><span class="line"></span><br><span class="line">s=<span class="string">"123+456"</span></span><br><span class="line">eval(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(x==<span class="number">1</span>)</span><br><span class="line"><span class="string">'True'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line"><span class="string">'3'</span></span><br></pre></td></tr></table></figure></p><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><p>根据提供的函数对指定序列做映射。<br>map()函数接收两个参数，一个是<font color="red">函数</font>，一个是<font color="red">序列</font>，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br><span class="line">function -- 函数</span><br><span class="line">iterable -- 一个或多个序列</span><br></pre></td></tr></table></figure><p><b>举例：</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span> :</span>            <span class="comment"># 计算平方数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表和：1+2+3+4+5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供了两个列表，对相同位置的列表数据进行相加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure></p><h1 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h1><p>把分隔符加入到序列（或str）中，结果为str<br>分隔符.jion(str)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">"-"</span></span><br><span class="line">a=<span class="string">"abc"</span> <span class="comment"># str、list、tuple、dic 都行</span></span><br><span class="line">        <span class="comment"># 但字典只能对键操作、序列里元素必须是str</span></span><br><span class="line">print(x.join(a)) <span class="comment"># join后结果为str</span></span><br><span class="line">----------------------------</span><br><span class="line">a-b-c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python基础学习</title>
      <link href="/2017/Python-basic/"/>
      <url>/2017/Python-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-简介"><a href="#Python-简介" class="headerlink" title="Python 简介"></a>Python 简介</h1><ul><li>Python是一种解释型语言：没有编译这个环节，类似与PHP和Perl</li><li>Python是交互式语言：可以在Python提示符中，直接互动执行写的程序</li><li>Python是面向对象语言：支持面向对象的风格或代码封装在对象的编程技术</li></ul><a id="more"></a><h2 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h2><ul><li>编译<br>将高级语言源代码转换成目标代码（机器语言），程序便可执行。<br>优点：目标代码执行速度更快，在相同操作系统上使用灵活。</li></ul><p><img src="https://image.evilpwn.me/blog/python-basic-02.png-sign" alt="编译"></p><ul><li>解释<br>将源代码逐条转换成目标代码同时逐条执行，每次运行程序都需要源代码和解释器。<br>优点：便于维护源代码，良好的可移植性。</li></ul><p><img src="https://image.evilpwn.me/blog/python-basic-03.png-sign" alt="解释"></p><p>编译执行的编程语言叫静态语言，如C，JAVA<br>解释执行的编程语言叫脚本语言，如PHP，JavaScript</p><h2 id="程序的基本编写方法"><a href="#程序的基本编写方法" class="headerlink" title="程序的基本编写方法"></a>程序的基本编写方法</h2><p>IPO模式<br>I：Input<br>P：Process  处理<br>O：Output</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>常用方法：<br>upper(),lower(),relace(old,new),find(“abc”)</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td>upper(),lower()</td><td>大小写转换</td></tr><tr><td>capitalize()</td><td>首字母大写，如：’Abc def dfe.dfe’</td></tr><tr><td>title()</td><td>标题化（所有单词首字母大写），如：’Abc def dfe.dfe’</td></tr><tr><td>strip()</td><td>去两边空格及去指定字符</td></tr><tr><td>lstrip()、rstrip()</td><td>去左/右边空格及去指定字符</td></tr><tr><td>split()</td><td>按指定字符分割字符串为数组</td></tr><tr><td>isdigit()</td><td>判读是否为数字类型</td></tr><tr><td>find(“abc”)</td><td>搜索字符串</td></tr><tr><td>relace(old,new)</td><td>字符串替换</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历字符串中每个字符</span></span><br><span class="line"><span class="keyword">for</span> &lt;var&gt; <span class="keyword">in</span> &lt;string&gt;:</span><br></pre></td></tr></table></figure><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>用<code>[]</code>标识，加号<code>+</code>是列表连接运算符，星号<code>*</code>是重复操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">list = [ <span class="string">'runoob'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">'john'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> list               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个的元素 </span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="keyword">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="keyword">print</span> list + tinylist    <span class="comment"># 打印组合的列表</span></span><br><span class="line"></span><br><span class="line">list.append(<span class="number">21</span>)          <span class="comment"># 末尾添加元素21</span></span><br><span class="line">list.remove(<span class="number">21</span>)          <span class="comment"># 删除元素21</span></span><br><span class="line">list.reverse()           <span class="comment"># 反转元素</span></span><br><span class="line">list.sort()              <span class="comment"># 给列表元素排序</span></span><br><span class="line">pos=list.index(<span class="number">21</span>)       <span class="comment"># 找出指定元素的索引</span></span><br><span class="line">list.insert(i,x)         <span class="comment"># 位置i中插入新元素x</span></span><br><span class="line">list.count(x)            <span class="comment"># 元素x在列表中的数量</span></span><br><span class="line">list.pop(i)              <span class="comment"># 取出列表中位置为i的元素，并删除</span></span><br><span class="line">len(list)                <span class="comment"># 获取元素个数</span></span><br><span class="line"><span class="number">21</span> <span class="keyword">in</span> list               <span class="comment"># 检查是否在序列中</span></span><br></pre></td></tr></table></figure></p><p><b>字符串拆分成列表：</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"python is an excellent language"</span>.split()</span><br><span class="line">[<span class="string">'python'</span>, <span class="string">'is'</span>, <span class="string">'an'</span>, <span class="string">'excellent'</span>, <span class="string">'language'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h2><p>类似于列表，但不能二次赋值，相当于只读列表。<br>元组用<code>()</code>标识，也可以不使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = ( <span class="string">'runoob'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> )</span><br><span class="line">tuple2 = <span class="string">"abc"</span>,<span class="number">123</span></span><br><span class="line">tuple1 = <span class="string">"ssd"</span>,<span class="number">123</span>,(<span class="string">"找你"</span>,<span class="number">31</span>)  <span class="comment"># 元组中包含元组</span></span><br></pre></td></tr></table></figure></p><font color="red">元组中元素不可修改、删除和添加；列表可以。但两者都可以使用<code>+</code>,<code>*</code>,<code>=</code>来扩展。</font><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><p>字典（dictionary）是除列表以外python中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。<br>两者区别在于：字典中元素通过键来存取，而不是通过偏移存取。<br>字典用<code>{}</code>标识，由索引（key）和它对应的值value组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dict=&#123;<span class="string">'ftp'</span>:<span class="number">21</span>,<span class="string">'ssh'</span>:<span class="number">22</span>,<span class="string">'telnet'</span>:<span class="number">23</span>,<span class="number">123</span>:<span class="number">666</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dict[<span class="string">'ftp'</span>]        <span class="comment"># 输出键为“ftp”的值</span></span><br><span class="line"><span class="keyword">print</span> dict[<span class="number">123</span>]          <span class="comment"># 输出键为123的值</span></span><br><span class="line"><span class="keyword">print</span> dict               <span class="comment"># 输出完整字典</span></span><br><span class="line"><span class="comment"># &#123;'ftp': 21, 123: 666, 'ssh': 22, 'telnet': 23&#125;</span></span><br><span class="line"><span class="keyword">print</span> dict.keys()        <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="comment"># ['ftp', 123, 'ssh', 'telnet']</span></span><br><span class="line"><span class="keyword">print</span> dict.values()      <span class="comment"># 输出所有值</span></span><br><span class="line"><span class="comment"># [21, 666, 22, 23]</span></span><br><span class="line"><span class="keyword">print</span> dict.items()       <span class="comment"># .items()方法返回字典中所有向的完整信息的列表</span></span><br><span class="line"><span class="comment"># [('ftp', 21), (123, 666), ('ssh', 22), ('telnet', 23)]</span></span><br></pre></td></tr></table></figure><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int(x [,base])</td><td style="text-align:center">将x转换为一个整数</td></tr><tr><td style="text-align:center">long(x [,base] )</td><td style="text-align:center">将x转换为一个长整数</td></tr><tr><td style="text-align:center">float(x)</td><td style="text-align:center">将x转换到一个浮点数</td></tr><tr><td style="text-align:center">complex(real [,imag])</td><td style="text-align:center">创建一个复数</td></tr><tr><td style="text-align:center">str(x)</td><td style="text-align:center">将对象 x 转换为字符串</td></tr><tr><td style="text-align:center">repr(x)</td><td style="text-align:center">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:center">eval(str)</td><td style="text-align:center">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:center">tuple(s)</td><td style="text-align:center">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:center">list(s)</td><td style="text-align:center">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:center">set(s)</td><td style="text-align:center">转换为可变集合</td></tr><tr><td style="text-align:center">dict(d)</td><td style="text-align:center">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td style="text-align:center">frozenset(s)</td><td style="text-align:center">转换为不可变集合</td></tr><tr><td style="text-align:center">chr(x)</td><td style="text-align:center">将一个整数转换为一个字符</td></tr><tr><td style="text-align:center">unichr(x)</td><td style="text-align:center">将一个整数转换为Unicode字符</td></tr><tr><td style="text-align:center">ord(x)</td><td style="text-align:center">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:center">hex(x)</td><td style="text-align:center">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:center">oct(x)</td><td style="text-align:center">将一个整数转换为一个八进制字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int(<span class="number">10.3</span>)       <span class="comment"># 10</span></span><br><span class="line">int(<span class="string">'F'</span>,<span class="number">16</span>)     <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul><li>算数运算符</li><li>比较运算符</li><li>赋值运算符</li><li>位运算符</li><li>逻辑运算符</li><li>成员运算符</li><li>身份运算符</li></ul><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">4</span>    <span class="comment"># 16 幂</span></span><br><span class="line"><span class="number">12</span>%<span class="number">10</span>   <span class="comment"># 2 取模</span></span><br><span class="line"><span class="number">12</span>//<span class="number">10</span>  <span class="comment"># 1 取整除</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>/<span class="number">2</span>     <span class="comment"># 0</span></span><br><span class="line"><span class="number">1.0</span>/<span class="number">2</span>   <span class="comment"># 0.5</span></span><br><span class="line"><span class="number">1</span>/float(<span class="number">2</span>) <span class="comment"># 0.5</span></span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>按位运算符是把数字看成二进制进行计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a为60，b为13</span><br><span class="line">  a = 0011 1100</span><br><span class="line">  b = 0000 1101</span><br><span class="line">-----------------</span><br><span class="line">a&amp;b = 0000 1100  # 输出结果12</span><br><span class="line">a|b = 0011 1101  # 输出结果61</span><br><span class="line">a^b = 0011 0001  # 按位异或，相异为1，相同为0;输出结果49</span><br><span class="line">~a  = 1100 0011  # 按位取反;输出结果-61</span><br><span class="line">a&lt;&lt;2= 1111 0000  # 左移动运算符，输出结果240；高位丢弃，低位补0</span><br><span class="line">a&gt;&gt;2= 0000 1111  # 输出15</span><br></pre></td></tr></table></figure></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>a=10,b=20</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">逻辑表达式</th><th style="text-align:center">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">and</td><td style="text-align:center">x and y</td><td style="text-align:center">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td style="text-align:center">(a and b) 返回 20。</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">x or y</td><td style="text-align:center">布尔”或”    - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td><td style="text-align:center">(a or b) 返回 10。</td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">not x</td><td style="text-align:center">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td style="text-align:center">not(a and b) 返回 False</td></tr></tbody></table><p>先从前往后判断，判断出Ture或False的位置就是返回结果。<br>not只返回True或False。</p><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><p><code>in</code>,<code>not in</code>，返回 True 或 False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">a <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure></p><h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><p>判断两个标识符是不是引用自一个对象。<br><code>is</code>：x is y 类似 id(x) == id(y)<br><code>is not</code>：x is not y 类似 id(a) != id(b)<br>也就是is传递了指针，判断是否指向同一地址块，==传递了值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">6666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">6666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">6666</span>;b=<span class="number">6666</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><blockquote><p>python中会为每个出现的对象分配内存，哪怕他们的值完全相等（注意是相等不是相同）。<br>但是为了提高内存利用效率对于一些简单的对象，如一些数值较小的int对象，python采取重用对象内存的办法。<br>如但果赋值的不是2而是大的数值，情况就跟前面的一样了<br>变量写在同一行,将会指向同一个对象<br>这点可以细细体会 (●’◡’●)</p></blockquote><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>由高到低：<br><img src="https://image.evilpwn.me/blog/python-basic-01.png-sign" alt="运算符优先级"></p><hr><h1 id="函数库的引用"><a href="#函数库的引用" class="headerlink" title="函数库的引用"></a>函数库的引用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;库名&gt;</span><br><span class="line">&lt;库名&gt;.&lt;函数名&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.fd(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="keyword">from</span> &lt;库名&gt; <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> &lt;库名&gt; <span class="keyword">import</span> &lt;函数名&gt;</span><br><span class="line">fd(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>的这两种方式调用函数时，不再需要库名。注意此时代码中不能再创建与库函数名一样的变量或函数。</span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>try…except…<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"><span class="keyword">except</span> &lt;ErrorType1&gt;:</span><br><span class="line">  &lt;handler1&gt;</span><br><span class="line"><span class="keyword">except</span> &lt;ErrorType2&gt;:</span><br><span class="line">  &lt;handler2&gt;</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  &lt;handler0&gt;</span><br><span class="line">[</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  无异常时执行</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  无论有无异常均执行</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>异常会在未处理时，打印处理，从而找到异常，如： ZeroDivisionError，NameError，TypeError。<br>一个except子句可以处理多个异常：except (RuntimeError, TypeError, NameError):<br>raise 语句可以抛出一个指定的异常：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure></p><hr><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><a href="/2017/Python-built-in-functions/" title="[Python内置函数]">[Python内置函数]</a>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PE文件格式</title>
      <link href="/2017/PE-file/"/>
      <url>/2017/PE-file/</url>
      
        <content type="html"><![CDATA[<h1 id="PE文件概念"><a href="#PE文件概念" class="headerlink" title="PE文件概念"></a>PE文件概念</h1><p>PE(Portable Executable File Format)，可移植的执行体，常见的有<font color="red">EXE文件</font>、动态链接库文件<font color="red">DLL文件</font>以及许多DLL的扩展组件，如<font color="red">OCX控件</font>已经控制面板程序（<font color="red">.CPL</font>）。<br>Windows PE文件主要源自Unix操作系统常用的<font color="red">COFF文件</font>（Commom Object File Format，通用目标文件格式）规范。为保证MS-DOS和windows的兼容性，PE文件格式保留了<font color="red">MS-DOS程序的MZ头</font>和<font color="red">MS-DOS stub</font>。<br>描述PE格式以及COFF文件的主要文件是<font color="red">winnt.h</font>文件。</p><a id="more"></a><p>当PE文件通过Windows加载器被装入内存后，内存中的版本被称作<font color="red">模块(Module)</font>。映射文件的起始地址被称为<font color="red">模块句柄（hModule）</font>，可以通过模块句柄访问内存中的其他数据结构。这个<font color="red">初始内存地址</font>也称为<font color="red">基地址</font>（ImageBase）。<br>在32位Windows系统中可直接调用<font color="red">GetModuleHandle函数</font>以取得指向DLL的指针，通过指针访问该DLL Module的内容。<br>基地址的值是由PE文件本身设定。默认设置中，用VC++建立的<font color="red">EXE</font>文件基地址是<font color="red">0040 0000h</font>，<font color="red">DLL</font>文件基地址是<font color="red">1000 0000h</font>。</p><p><font color="red">文件虚拟地址</font>（Relative Virtual Address，简称RVA）是内存中的一个简单的相对与PE文件<font color="red">装入地址</font>（<font color="red">即基地址</font>）的<font color="red">偏移位置</font>，是一个<font color="red">相对地址（偏移量）</font>。实际的内存地址被称为<font color="red">虚拟地址（VA）</font>。<br><b><font color="red">虚拟地址（VA）=基地址（ImageBase）+相对虚拟地址（RVA）</font></b><br><img src="https://image.evilpwn.me/blog/PE-file-01.png-sign" alt="PE文件结构"></p><p>待更</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> PE文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows逆向基础</title>
      <link href="/2017/windows_reverse/"/>
      <url>/2017/windows_reverse/</url>
      
        <content type="html"><![CDATA[<h1 id="ASCII与UNICODE字符集"><a href="#ASCII与UNICODE字符集" class="headerlink" title="ASCII与UNICODE字符集"></a>ASCII与UNICODE字符集</h1><ul><li><p>ASCII（美国信息交换标准码）<br><font color="red">7位</font>编码，共128个代码，最通用的<font color="red">单字节</font>编码，主要用于显示现代英语和其他西欧语言。<br>如：“good”的ASCII编码：67h 6fh 6fh 64h</p></li><li><p>Unicode<br>是ASCII的扩展，Windows中，用<font color="red">两个字节（16位）</font>对其进行编码，也称<font color="red">宽字节集（Widechars）</font>。高位填充0。<br>如：“good”的Unicode编码：67 00 6f 00 6f 00 64 00 （左低右高）</p></li></ul><blockquote><p>更多编码详解见我的另一篇文章： 中“常用的编码”。</p></blockquote><h1 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h1><p>Windows 提供了应用程序可利用的丰富的函数调用，这些函数采用<font color="red">动态链接库(即DLL)</font>的形式实现。<br>三个主要的动态链接库：<font color="red">kernel32.dll、user32.dll、gdi32.dll</font>，分别提供操作系统核心功能服务、用户接口、图形设备接口。</p><a id="more"></a><h1 id="API常见函数"><a href="#API常见函数" class="headerlink" title="API常见函数"></a>API常见函数</h1><h2 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h2><p>在user32.dll用户模块中，<font color="red">创建和显示信息框</font>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hWnd,         <span class="comment">//父窗口句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR IpTest,    <span class="comment">//消息框文本地址（内容）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR IpCation,  <span class="comment">//消息框标题地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">  UNIT uType         <span class="comment">//消息框样式</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>根据用户单击了的按钮返回一个整数值。<br>ANSI版是MessageBoxA，Unicode版是MessageBoxW。</p><blockquote><p><b>句柄</b><br>Windows程序中，用来标识应用程序中的不同对象和同类中的不同的实例，如：一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。<br>应用程序能够通过句柄访问相应的对象的信息，但句柄不是指针，程序不能利用句柄来直接阅读文件中的信息。<br>句柄是Windows用来标志应用程序中建立的或是使用的唯一整数，Windows大量使用了句柄来标识对象。</p></blockquote><h2 id="GetDlgItemText"><a href="#GetDlgItemText" class="headerlink" title="GetDlgItemText"></a>GetDlgItemText</h2><p>在user32.dll用户模块中，<font color="red">获取对话框文本</font>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Unit <span class="title">GetDlgItemText</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HWND hDlg,         <span class="comment">//对话框句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nlDDlgItem,    <span class="comment">//控件标识（ID号）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR IpString,  <span class="comment">//文本缓冲区指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> nMaxCount      <span class="comment">//字符缓冲区的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>执行成功返回缓冲区字符个数，失败返回0<br>ANSI版是GetDlgItemTexA，Unicode版是GetDlgItemTexW。</p><h1 id="Windows消息机制"><a href="#Windows消息机制" class="headerlink" title="Windows消息机制"></a>Windows消息机制</h1><p>Windows是一个<font color="red">消息（Message）驱动</font>的系统。<br>Windows消息提供应用程序与应用程序之间、应用程序与Windows操作系统之间进行通信的手段。<br>应用程序想要实现的功能<font color="red">由消息来触发</font>，并且靠<font color="red">对消息的相应和处理</font>来完成功能。<br>Windows中，有两种消息队列：系统队列、应用程序消息队列。<br>一个事件的发生，到达处理它的窗口函数，必须经过如下过程：<br><img src="https://image.evilpwn.me/blog/Windows-reverse-01.png-sign" alt="Windows消息机制"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编基础</title>
      <link href="/2017/Assembly-Language/"/>
      <url>/2017/Assembly-Language/</url>
      
        <content type="html"><![CDATA[<h1 id="机器语言、机器指令、目标程序"><a href="#机器语言、机器指令、目标程序" class="headerlink" title="机器语言、机器指令、目标程序"></a>机器语言、机器指令、目标程序</h1><p>机器指令：操作码和操作数两部分构成，CPU能直接识别并遵照执行的指令。<br>机器语言：二进制编码的<font color="red">机器指令的集合</font>及一组使用机器指令的规则。是CPU能直接识别的唯一语言。<br>目标程序：是指用机器语言描述的程序。</p><a id="more"></a><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>80x86中，常见寄存器（32位）有16个，包括4个数据寄存器、2个变址寄存器、2个指针寄存器、6个段寄存器、1个指令寄存器、1个标志寄存器。</p><p><b>寄存器分类如下（FS、GS未列出）：</b><br><img src="https://image.evilpwn.me/blog/huibian-01.png-sign" alt="寄存器分类"></p><ul><li><p>数据寄存器<br>EAX/EBX/ECX/EDX<br>作用：存放程序运行中间数据，其中ECX常用做计数器<br>特点：可分割存取（EAX—AX—AL and AH）</p></li><li><p>变址寄存器<br>ESI(源地址)/EDI(目的地址)<br>作用：存放存储单元段内偏移量，用于寻址</p></li><li><p>指针寄存器<br>EBP(栈底)/ESP(栈顶)<br>作用：EBP是基地址指针寄存器，可以直接访问栈中数据，ESP指向堆栈栈顶</p></li><li><p>段寄存器<br>CS/DS/ES/SS/FS/GS<br>说明：32位CPU中，段寄存器作用根据工作方式不同而不同，在保护模式下，段寄存器中存放的不再是段值，而是称为“选择子(Selector)”的某个值<br>CS：代码段寄存器，用于存放应用程序代码所在的段的基址<br>DS：数据段寄存器，存放数据段的段基址<br>ES：附加段寄存器，存放程序使用的附加段基址<br>SS：堆栈段寄存器，存放栈段的段基址<br>FS：标志段寄存器，windows下，用于处理程序异常<br>GS：全局段寄存器，和附加段类似<br><b>表示方法：</b><br>段值：偏移<br><b>计算方法：</b><br>物理地址 = 段值×16 + 偏移<br><b>示例：</b><br>用16进制表示的逻辑地址1234：3456H所对应的存储单元的物理地址为15796H。<br><img src="https://image.evilpwn.me/blog/huibian-02.png-sign?imageView2/2/w/300/h/200/q/75|imageslim" alt="物理地址转换"></p></li></ul><ul><li><p>指令寄存器<br>指令寄存器：EIP，存放下次要执行的指令的地址</p></li><li><p>标志寄存器<br>PSW<br>16位，包含9个标志位，主要用于反映处理器的状态和运算结果的某些特征。<br>9个标志位分为两组：<br>运算结果标志位：OF、SF、ZF、AF、PF、CF<br>状态控制标志位：DF、IF、TF<br><img src="https://image.evilpwn.me/blog/huibian-03.png-sign" alt="各标志位含义"><br><a href="https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8#1" target="_blank" rel="noopener">各标志位含义</a></p></li></ul><h1 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h1><table><thead><tr><th>指令</th><th>示例</th><th>含义</th><th>特殊说明</th></tr></thead><tbody><tr><td>MOV</td><td>MOV EAX,ECX</td><td>EAX=ECX</td><td></td></tr><tr><td>ADD</td><td>ADD EAX,ECX</td><td>EAX+=ECX</td><td></td></tr><tr><td>SUB</td><td>SUB EAX,ECX</td><td>EAX-=ECX</td><td></td></tr><tr><td>INC</td><td>INC EAX</td><td>EAX++</td><td></td></tr><tr><td>DEC</td><td>DEC EAX</td><td>EAX- -</td><td></td></tr><tr><td>LEA</td><td>LEA EAX,[ECX+4]</td><td>EAX=ECX+4</td><td>效率比MOV高</td></tr><tr><td>CMP</td><td>CMP EAX,ECX</td><td>if(EAX==ECX) ZF=1<br>else ZF=0</td><td>比较两个值<br>设置0标志位</td></tr><tr><td>AND</td><td>AND EAX,ECX</td><td></td><td>按位相与，结果送到EAX</td></tr><tr><td>TEST</td><td>TEST EAX,EAX</td><td>if(EAX==0) ZF=1<br>else ZF=0</td><td>与AND类似，但结果不送回，只影响标志位<br>常用于测试寄存器是否为空</td></tr><tr><td>JZ(JE)</td><td>JZ 02001000</td><td>if(ZF==1)<br>GOTO 02001000</td><td></td></tr><tr><td>JNZ(JNE)</td><td>JNZ 02001000</td><td>if(ZF==0)<br>GOTO 02001000</td><td></td></tr><tr><td>JMP</td><td>JMP 02001000</td><td>GOTO 02001000</td><td></td></tr><tr><td>CALL</td><td>CALL abc</td><td></td><td>调用abc</td></tr><tr><td>PUSH</td><td>PUSH 000000001</td><td></td><td>000000001入栈</td></tr><tr><td>POP</td><td>POP EAX</td><td></td><td>出栈并将获取值存入EAX</td></tr></tbody></table><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>8086共7种寻址方式：</p><ul><li>立即寻址</li><li>直接寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>寄存器相对寻址</li><li>基址加变址寻址</li><li>相对基址加变址寻址</li></ul><h2 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h2><p>立即寻址方式是指操作数就包含在<font color="blue">指令中</font>，它作为指令的一部分，跟在操作码后存放在代码段。这种操作数称为立即数。<br>立即寻址方式主要用于给<font color="red">寄存器或存储单元赋初值</font>的场合。<br>示例：<br>MOV  AX,  1234H<br><img src="https://image.evilpwn.me/blog/huibian-04.png-sign" alt="立即寻址"></p><h2 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h2><p>直接寻址方式是指操作数在<font color="blue">存储器中</font>，指令直接包含有操作数的有效地址。<br>操作数一般存放在数据段，所以操作数的地址由DS加上指令中直接给出的16位偏移得到。<br>直接寻址方式用于处理单个存储器变量的情况。它可以实现在64K字节的段内寻找操作数。直接寻址的操作数通常是<font color="red">程序使用的变量</font>。<br>示例：<br>MOV  AX,[1234H] (DS为5000H)<br><img src="https://image.evilpwn.me/blog/huibian-05.png-sign" alt="直接寻址"></p><h2 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h2><p>寄存器寻址方式是指操作数在<font color="blue">CPU内部的寄存器中</font>，指令中指定寄存器号。如立即寻址方式示例中指令“MOV  AX,  1234H”目的操作数采用寄存器寻址。<br>寄存器寻址中16位操作数的寄存器可以有AX、BX、CX、DX、SI、DI、SP和BP等；对于8位操作数，寄存器可以是AL、AH、BL、BH、CL、CH、DL和DH。<br>由于操作数在寄存器中，不需要通过访问存储器来取得操作数，所以采用这种寻址方式的<font color="red">指令执行速度较快</font>。</p><h2 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h2><p>寄存器间接寻址方式是指操作数在<font color="blue">存储器中</font>，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。<br>如果有效地址在SI、DI和BX中，则以DS段寄存器的内容为段值；如果有效地址在BP中，则以SS段寄存器的内容为段值。<br>注意与寄存器寻址方式的区别，例如指令“MOV [SI],AX”和“MOV SI,AX”的区别。<br>示例：<br>MOV  AX,[SI] (DS为5000H,SI为1234H)<br><img src="https://image.evilpwn.me/blog/huibian-06.png-sign" alt="寄存器间接寻址"></p><h2 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h2><p>寄存器相对寻址方式是指操作数在<font color="blue">存储器中</font>，操作数的有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、DI)内容加上指令中给定的8位或16位位移量之和。<br><img src="https://image.evilpwn.me/blog/huibian-07.png-sign" alt="寄存器相对寻址"><br>示例：<br>MOV  AX,[DI+1223H] (DS为5000H,DI为3678H)<br><img src="https://image.evilpwn.me/blog/huibian-08.png-sign" alt="寄存器相对寻址"></p><h2 id="基址加变址寻址方式"><a href="#基址加变址寻址方式" class="headerlink" title="基址加变址寻址方式"></a>基址加变址寻址方式</h2><p>基址加变址寻址方式是指操作数在<font color="blue">存储器中</font>，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到。<br><img src="https://image.evilpwn.me/blog/huibian-09.png-sign" alt="基址加变址寻址方式"><br>示例：<br>MOV  AX,[BX+DI] (DS为5000H,BX为1223H,DI为54H)<br><img src="https://image.evilpwn.me/blog/huibian-10.png-sign" alt="基址加变址寻址方式"></p><h2 id="相对基址加变址寻址方式"><a href="#相对基址加变址寻址方式" class="headerlink" title="相对基址加变址寻址方式"></a>相对基址加变址寻址方式</h2><p>相对基址加变址寻址方式是指操作数在<font color="blue">存储器中</font>，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或者16位位移量相加得到。<br><img src="https://image.evilpwn.me/blog/huibian-11.png-sign" alt="相对基址加变址寻址方式"><br>示例：<br>MOV  AX,[BX+DI-2] (DS为5000H,BX为1223H,DI为54H)<br><img src="https://image.evilpwn.me/blog/huibian-12.png-sign" alt="相对基址加变址寻址方式"></p><h1 id="汇编代码的调试"><a href="#汇编代码的调试" class="headerlink" title="汇编代码的调试"></a>汇编代码的调试</h1><p>debug命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">debug 1.exe</span><br><span class="line">-r，查看、改变寄存器内容</span><br><span class="line">-d，查看内存中的内容</span><br><span class="line">-e，改写内存中的内容</span><br><span class="line">-u，将内存中的机器指令翻译成汇编指令</span><br><span class="line">-t， 执行一条机器指令</span><br><span class="line">-p，执行int指令</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法03-贪心算法</title>
      <link href="/2017/s03/"/>
      <url>/2017/s03/</url>
      
        <content type="html"><![CDATA[<h2 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h2><p>写出活动安排问题的贪心算法。<br>输入：先输入活动的个数n，然后依次输入每个活动的开始时间si及结束时间fi。如：时间输入格式为：8：30输入为830。注意：所有值都不能随机生成！！！<br>输出：活动的选择向量，即0，1的集合。如： 1 0 1 0 1或（1，0，1，0，1）<br>示例：<br>输入：9 800 1030 900 1130 700 1100 1130 1400 1200 1330 1300 1530 1500 1600 1430 1600 1600 1800<br>输出：1 0 0 0 1 0 1 0 1</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">active</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,s,f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> active &amp;a,<span class="keyword">const</span> active &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.f&lt;b.f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n,active act[],<span class="keyword">bool</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[act[<span class="number">0</span>].id]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(act[i].s&gt;=act[j].f) &#123;a[act[i].id]=<span class="literal">true</span>;j=i;&#125;</span><br><span class="line">        <span class="keyword">else</span> a[act[i].id]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    active act[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">bool</span> a[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;act[i].s&gt;&gt;act[i].f;</span><br><span class="line">        act[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(act,act+n,cmp);</span><br><span class="line">    GreedySelector(n,act,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一般背包"><a href="#一般背包" class="headerlink" title="一般背包"></a>一般背包</h2><p>写出一般背包问题的贪心算法。<br>输入：先输入物品的个数n，再输入背包的容量c，然后依次输入物品的重量wi，最后依次输入物品的价值vi。注意：所有值都不能随机生成！！！<br>输出：物品的选择向量xi，0=&lt;xi=&lt;1。<br>示例：<br>输入：3 20  18 15 10 25 24 15<br>输出：0.0   1.0    0.5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">good</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">float</span> w,v,r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> good &amp;a,<span class="keyword">const</span> good &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.r&gt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> c,<span class="keyword">float</span> x[],good a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        x[a[i].id]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].w&gt;c) <span class="keyword">break</span>;</span><br><span class="line">        x[a[i].id]=<span class="number">1</span>;</span><br><span class="line">        c=c-a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n)</span><br><span class="line">        x[a[i].id]=c/a[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    good a[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">float</span> x[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i].w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;a[i].v;</span><br><span class="line">       a[i].id=i;</span><br><span class="line">       a[i].r=a[i].v/a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    fun(c,x,a,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f "</span>,<span class="keyword">int</span>(x[i]*<span class="number">10</span>)/<span class="number">10.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法02-动态规划</title>
      <link href="/2017/s02/"/>
      <url>/2017/s02/</url>
      
        <content type="html"><![CDATA[<h2 id="菲波拉契数列"><a href="#菲波拉契数列" class="headerlink" title="菲波拉契数列"></a>菲波拉契数列</h2><p>写出菲波拉契数列自底向上的非递归动态规划算法或自顶向下的递归动态规划算法（备忘录方法）。<br>输入：输入一个数字。<br>输出：输出为Fibonacci数列的值。<br>示例：输入：5  ，输出：8</p><a id="more"></a><p>Fibonacci数列可以递归地定义为：<br><img src="https://image.evilpwn.me/blog/suan02-1.png-sign" alt="菲波拉契数列"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> b[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//备忘录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上的非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">long</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f0,f1,f2;</span><br><span class="line">    f0=f1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f2=f0+f1;</span><br><span class="line">        f0=f1;</span><br><span class="line">        f1=f2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自顶向下备忘录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b[n]!=<span class="number">0</span>) <span class="keyword">return</span> b[n];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) b[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) b[n]=fun2(n<span class="number">-1</span>)+fun2(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> b[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> a[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fun(a,n);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;fun2(n);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><p>写出矩阵连乘的自底向上非递归的动态规划算法或自顶向下递归的动态规划算法（备忘录方法）。<br>输入：先输入矩阵连乘的个数n，然后依次手动输入（不能随机生成！）矩阵的维数pi（数字）。注意，6个矩阵，需输7个维数值。<br>输出：矩阵连乘的次序，如：((A1(A2A3))((A4A5A6))。<br>示例：输入：6  30  35  15  5  10  20  25，输出：((A1(A2A3))((A4A5)A6))<br><img src="https://image.evilpwn.me/blog/suan02-2.png-sign" alt="矩阵连乘"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n,<span class="keyword">int</span> **m,<span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//m[][]最小乘次数</span></span><br><span class="line">    <span class="comment">//s[][]最小乘数时的断开点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) m[i][i]=<span class="number">0</span>;    <span class="comment">//单一矩阵的最小乘次都置为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">2</span>;r&lt;=n;r++)   <span class="comment">//r为连乘矩阵的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)   <span class="comment">//i表示连乘矩阵中的第一个</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j=i+r<span class="number">-1</span>;    <span class="comment">//j表示连乘矩阵中的最后一个</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//取第一个可取位置，即断开位置为i</span></span><br><span class="line">            m[i][j]=m[i+<span class="number">1</span>][j]+p[i<span class="number">-1</span>]*p[i]*p[j];</span><br><span class="line">            s[i][j]=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环取k的可取位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=m[i][k]+m[k+<span class="number">1</span>][j]+p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span>(t&lt;m[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j]=t;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A"</span>&lt;&lt;i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>==j)               <span class="comment">//两个矩阵，加括号输出</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"(A"</span>&lt;&lt;i&lt;&lt;<span class="string">"A"</span>&lt;&lt;j&lt;&lt;<span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>;</span><br><span class="line">        Traceback(i,s[i][j],s);</span><br><span class="line">        Traceback(s[i][j]+<span class="number">1</span>,j,s);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,*p,**m,**s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p,m,s初始化</span></span><br><span class="line">    p=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    m=<span class="keyword">new</span> <span class="keyword">int</span>*[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        m[i]=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    s=<span class="keyword">new</span> <span class="keyword">int</span>*[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        s[i]=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"></span><br><span class="line">    MatrixChain(p,n,m,s);</span><br><span class="line">    <span class="comment">//Look(1,n);  //备忘录算法</span></span><br><span class="line"><span class="comment">//Recur(0,n); //直接递归算法</span></span><br><span class="line">    Traceback(<span class="number">1</span>,n,(<span class="keyword">int</span>**)s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==============我是分隔符==============</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//备忘录和直接递归</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">int</span> n,m[N][N],s[N][N],p[N+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//矩阵连乘的最优数乘次数为m[1][n]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//备忘录计算最优值（自顶向下递归的动态规划算法）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Look</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[i][j]&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> m[i][j];</span><br><span class="line">    <span class="keyword">if</span>(i==j)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=Look(i,i)+Look(i+<span class="number">1</span>,j)+p[i<span class="number">-1</span>]*p[i]*p[j];</span><br><span class="line">    s[i][j]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=Look(i,k)+Look(k+<span class="number">1</span>,j)+p[i<span class="number">-1</span>]*p[k]*p[j];  <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span> (t&lt;u)</span><br><span class="line">        &#123;</span><br><span class="line">            u=t;  <span class="comment">//从k处断开，分别求得每次的数乘次数</span></span><br><span class="line">            s[i][j]=k;  <span class="comment">//返回t,k中较小的值，并记录断点处k</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j]=u;</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接递归计算最优值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Recur</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=Recur(i,i)+Recur(i+<span class="number">1</span>,j)+p[i<span class="number">-1</span>]*p[i]*p[j];  <span class="comment">//递归</span></span><br><span class="line">    s[i][j] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=Recur(i,k)+Recur(k+<span class="number">1</span>,j)+p[i<span class="number">-1</span>]*p[k]*p[j];  <span class="comment">//从k处断开，分别求得每次的数乘次数</span></span><br><span class="line">        <span class="keyword">if</span> (t&lt;u)  <span class="comment">//返回t,k中较小的值，并记录断点处k</span></span><br><span class="line">        &#123;</span><br><span class="line">            u=t;</span><br><span class="line">            s[i][j]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出矩阵结合方式，加括号输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(i==j)  <span class="comment">//只有一个矩阵，直接输出</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A"</span>&lt;&lt;i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>==j)  <span class="comment">//两个矩阵，加括号输出</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"(A"</span>&lt;&lt;i&lt;&lt;<span class="string">"A"</span>&lt;&lt;j&lt;&lt;<span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>;</span><br><span class="line">        Traceback(i,s[i][j]);  <span class="comment">//递归，从最得到最优解的地方s[i][j]处断开</span></span><br><span class="line">        Traceback(s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n; <span class="comment">//输入矩阵个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)   <span class="comment">//输入第一个矩阵行数和第一个到第n个矩阵的列数</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"></span><br><span class="line">Look(<span class="number">1</span>,n);  <span class="comment">//备忘录算法</span></span><br><span class="line"><span class="comment">//Recur(0,n); //直接递归算法</span></span><br><span class="line">    Traceback(<span class="number">1</span>,n);<span class="comment">//输出最优计算次序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>写出0-1背包问题的自底向上非递归的动态规划算法。<br>输入：首先输入物品的个数n，然后输入背包的容量c，再依次输入每个物品的重量wi，最后依次输入每个物品的价值vi。注意：所有值都不能随机生成！！！<br>输出：物品的选择向量。如：(1,0,0,1,1)等。<br>示例：输入：4  5  2  1  3  2  12  10  20  15<br>输出：1 1 0 1或（1,1,0,1）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> v[],<span class="keyword">int</span> w[],<span class="keyword">int</span> c,<span class="keyword">int</span> n,<span class="keyword">int</span> **m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> jmax=min(w[n]<span class="number">-1</span>,c);  <span class="comment">//找出背包容量和最后一个物品重量的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化m[n][j]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=jmax;j++)</span><br><span class="line">        m[n][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=w[n];j&lt;=c;j++)</span><br><span class="line">        m[n][j]=v[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//wi&gt;j时，m[i][j]=m[i+1][j]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">jmax=min(w[i]<span class="number">-1</span>,c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=jmax;j++)</span><br><span class="line">            m[i][j]=m[i+<span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=c;j++)</span><br><span class="line">            m[i][j]=max(m[i+<span class="number">1</span>][j],m[i+<span class="number">1</span>][j-w[i]]+v[i]);  <span class="comment">//其他做选择</span></span><br><span class="line">&#125;</span><br><span class="line">m[<span class="number">1</span>][c]=m[<span class="number">2</span>][c];</span><br><span class="line"><span class="keyword">if</span> (c&gt;=w[<span class="number">1</span>])   <span class="comment">//只剩下第一个物品时，若剩余背包容积大于w1时，要进行选择</span></span><br><span class="line">        m[<span class="number">1</span>][c]=max(m[<span class="number">1</span>][c],m[<span class="number">2</span>][c-w[<span class="number">1</span>]]+v[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span> **m,<span class="keyword">int</span> w[],<span class="keyword">int</span> c,<span class="keyword">int</span> n,<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span>(m[i][c]==m[i+<span class="number">1</span>][c])</span><br><span class="line">            x[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    x[i]=<span class="number">1</span>;</span><br><span class="line">    c -= w[i];</span><br><span class="line">&#125;</span><br><span class="line">x[n]=(m[n][c])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,w[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,x[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c,n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">int</span> **m = <span class="keyword">new</span> <span class="keyword">int</span> *[c + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">m[i]=<span class="keyword">new</span> <span class="keyword">int</span>[c+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">knapsack(v,w,c,n<span class="number">-1</span>,m);</span><br><span class="line">traceback(m,w,c,n<span class="number">-1</span>,x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h2><p>写出最优二叉搜索树的自底向上非递归的动态规划算法。<br>输入：首先输入结点的个数n，再依次输入搜索成功的概率bi，最后依次输入搜索失败的概率aj。注意：所有值都不能随机生成，且只输入整数（概率×100）！！！<br>输出：最优二叉树的结构。<br>示例：输入：5  15  10  5  10  20  5  10  5  5  5  10，<br>输出：<br>S2是根<br>S2的左孩子是S1<br>S2的右孩子是S5<br>S5是根<br>S5的左孩子是S4<br>S4是根<br>S4的左孩子是S3</p><p><img src="https://image.evilpwn.me/blog/suan02-4-1.png-sign" alt="最优二叉搜索树1"><br><img src="https://image.evilpwn.me/blog/suan02-4-2.png-sign" alt="最优二叉搜索树2"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OBST</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> **m, <span class="keyword">int</span> **s, <span class="keyword">int</span> **w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化，构造没有内部节点时的情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">w[i + <span class="number">1</span>][i] = a[i];</span><br><span class="line">m[i + <span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r&lt;n; r++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = i + r;</span><br><span class="line"><span class="comment">//构造T[i][j] 填写w[i][j],m[i][j],s[i][j]</span></span><br><span class="line"><span class="comment">//首选i作为根，其左子树为空，右子树为节点</span></span><br><span class="line">w[i][j] = w[i][j - <span class="number">1</span>] + a[j] + b[j];</span><br><span class="line">m[i][j] = m[i + <span class="number">1</span>][j];</span><br><span class="line">s[i][j] = i;</span><br><span class="line"><span class="comment">//不选i作为根，设k为其根，则k=i+1，……j</span></span><br><span class="line"><span class="comment">//左子树为节点：i,i+1……k-1,右子树为节点：k+1,k+2,……j</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= j; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = m[i][k - <span class="number">1</span>] + m[k + <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (t&lt;m[i][j])</span><br><span class="line">&#123;</span><br><span class="line">m[i][j] = t;</span><br><span class="line">s[i][j] = k;   <span class="comment">//根节点元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m[i][j] += w[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造最优解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (j&gt;i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> root = s[i][j]; <span class="comment">//根节点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s"</span> &lt;&lt; root &lt;&lt; <span class="string">"是根"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i][root - <span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s"</span> &lt;&lt; root &lt;&lt; <span class="string">"的左孩子是s"</span> &lt;&lt; s[i][root - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (s[root + <span class="number">1</span>][j]&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s"</span> &lt;&lt; root &lt;&lt; <span class="string">"的右孩子是s"</span> &lt;&lt; s[root + <span class="number">1</span>][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fun(i, root - <span class="number">1</span>, s);</span><br><span class="line">fun(root + <span class="number">1</span>, j, s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//成功概率</span></span><br><span class="line"><span class="keyword">int</span>*b = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];  <span class="comment">//失败概率</span></span><br><span class="line"><span class="keyword">int</span> **m = <span class="keyword">new</span> <span class="keyword">int</span> *[n + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> **w = <span class="keyword">new</span> <span class="keyword">int</span> *[n + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> **s = <span class="keyword">new</span> <span class="keyword">int</span> *[n + <span class="number">2</span>]; <span class="comment">//最佳节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">m[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">w[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">s[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">OBST(a, b, n, m, s, w);</span><br><span class="line">fun(<span class="number">1</span>, n, s);  <span class="comment">//最优解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法01-分治法</title>
      <link href="/2017/s01/"/>
      <url>/2017/s01/</url>
      
        <content type="html"><![CDATA[<h2 id="Ackerman函数的递归实现算法"><a href="#Ackerman函数的递归实现算法" class="headerlink" title="Ackerman函数的递归实现算法"></a>Ackerman函数的递归实现算法</h2><p>输入：输入两个数字，先输入n，后输入m。<br>输出：Ackerman函数计算后的值。<br>示例：输入：4    2，输出：16</p><p>Ackerman函数A(n，m)定义如下：<br>有两个独立的整型变量m、n：<br><img src="https://image.evilpwn.me/blog/suan01.png-sign" alt="Ackerman"></p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ackerman</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">2</span>&amp;&amp;m==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">1</span>&amp;&amp;m&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Ackerman(Ackerman(n<span class="number">-1</span>,m),m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Ackerman(n,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列的递归实现算法"><a href="#全排列的递归实现算法" class="headerlink" title="全排列的递归实现算法"></a>全排列的递归实现算法</h2><p>输入：先输入要求输入的字符的个数，后依次输入（或随机生成）每个字符（不能仅仅是数字）。<br>输出：全排列的结果。<br>示例：输入：3  /  *  2，输出：/  *  2  /  2  *  *  /  2  *  2  /  2  *  /  2  /  *  </p><p>R的全排列可归纳递归定义如下：<br><img src="https://image.evilpwn.me/blog/algorithms01-02.png-sign" alt="全排列"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">a</span>,<span class="title">T</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T t=a;a=b;b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Perm</span>(<span class="title">T</span> <span class="title">a</span>[],<span class="title">int</span> <span class="title">k</span>,<span class="title">int</span> <span class="title">m</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(k==m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(a[k],a[i]);</span><br><span class="line">            Perm(a,k+<span class="number">1</span>,m);</span><br><span class="line">            Swap(a[k],a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    Perm(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数划分的递归实现算法"><a href="#整数划分的递归实现算法" class="headerlink" title="整数划分的递归实现算法"></a>整数划分的递归实现算法</h2><p>输入：输入整数划分的整数（只输入一次，即n==m）。<br>输出：输入整数的划分个数值。<br>示例：输入：7，输出：15</p><p>q(n,m)的如下递归关系定义如下：<br>正整数n的划分数p(n)=q(n,n)。<br><img src="https://image.evilpwn.me/blog/suan01-03.png-sign" alt="整数划分"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((n&lt;<span class="number">1</span>)||(m&lt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((n==<span class="number">1</span>)||(m==<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> q(n,n);</span><br><span class="line">    <span class="keyword">if</span>(n==m) <span class="keyword">return</span> q(n,m<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q(n,m<span class="number">-1</span>)+q(n-m,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q(x,x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索的递归实现算法"><a href="#二分搜索的递归实现算法" class="headerlink" title="二分搜索的递归实现算法"></a>二分搜索的递归实现算法</h2><p>输入：先输入进行二分搜索元素的个数，然后按大小依次输入（或随机生成，然后排序）每个数字，最后输入要求搜索的元素。<br>输出：要求搜索元素的下标（下标从0开始！）。<br>示例：输入：6 1 5 5 9 6 9 6，输出3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key == a[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;a[mid])</span><br><span class="line">            <span class="keyword">return</span> BinarySearch(a,low,mid<span class="number">-1</span>,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;a[mid])</span><br><span class="line">            <span class="keyword">return</span> BinarySearch(a,mid+<span class="number">1</span>,high,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">105</span>],n,x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;BinarySearch(a,<span class="number">0</span>,n<span class="number">-1</span>,x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并排序的递归实现算法"><a href="#合并排序的递归实现算法" class="headerlink" title="合并排序的递归实现算法"></a>合并排序的递归实现算法</h2><p>输入：先输入进行合并排序元素的个数，然后依次随机输入（或随机生成）每个数字。<br>输出：元素排序后的结果，数字之间不加任何标识符。<br>示例：输入：8  11  1  2  4  8  6  15  8，输出：1  2  4  6  8  8  11  15</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cnt=<span class="number">105</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> c[],<span class="keyword">int</span> d[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>,k=left;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;=mid)&amp;&amp;(j&lt;=right))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&lt;=c[j])</span><br><span class="line">           d[k++]=c[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d[k++]=c[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;mid)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=j;q&lt;=right;q++)</span><br><span class="line">            d[k++]=c[q];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> q=i;q&lt;=mid;q++)</span><br><span class="line">            d[k++]=c[q];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> b[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">        a[i]=b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[cnt];</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)  <span class="comment">//至少有2个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;  <span class="comment">//取中点</span></span><br><span class="line">        MergeSort(a,left,mid);</span><br><span class="line">        MergeSort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        Merge(a,b,left,mid,right);   <span class="comment">//合并两个排好序的数组段到一个新的数组b中</span></span><br><span class="line">        Copy(a,b,left,right);   <span class="comment">//合并后的b再复制回数组a中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[cnt];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    MergeSort(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序的递归实现算法"><a href="#快速排序的递归实现算法" class="headerlink" title="快速排序的递归实现算法"></a>快速排序的递归实现算法</h2><p>输入：先输入进行合并排序元素的个数，然后依次随机输入（或随机生成）每个数字。<br>输出：元素排序后的结果。<br>示例：输入：8  9  1  2  4  8  6  15  8，输出：1  2  4  6  8  8  9  15</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Partition</span>(<span class="title">T</span> <span class="title">a</span>[],<span class="title">int</span> <span class="title">p</span>,<span class="title">int</span> <span class="title">r</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i=p,j=r+<span class="number">1</span>;</span><br><span class="line">    T x=a[p];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[++i]&lt;x&amp;&amp;i&lt;r);</span><br><span class="line">        <span class="keyword">while</span>(a[--j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[p]=a[j];</span><br><span class="line">    a[j]=x;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">QuickSort</span>(<span class="title">T</span> <span class="title">a</span>[],<span class="title">int</span> <span class="title">p</span>,<span class="title">int</span> <span class="title">r</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=Partition(a,p,r);</span><br><span class="line">        QuickSort(a,p,q<span class="number">-1</span>);</span><br><span class="line">        QuickSort(a,q+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">105</span>],n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    QuickSort(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ISCC-2017-writeup</title>
      <link href="/2017/ISCC-2017-writeup/"/>
      <url>/2017/ISCC-2017-writeup/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="Wheel-Cipher（50）"><a href="#Wheel-Cipher（50）" class="headerlink" title="Wheel Cipher（50）"></a>Wheel Cipher（50）</h3><p>身为二战时期的密码专家，你截获了通信员身上的一段密文、密钥序列和加密列表。你能看懂吗？<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ZWAXJGDLUBVIQHKYPNTCRMOSFE</span><br><span class="line">KPBELNACZDTRXMJQOYHGVSFUWI</span><br><span class="line">BDMAIZVRNSJUWFHTEQGYXPLOCK</span><br><span class="line">RPLNDVHGFCUKTEBSXQYIZMJWAO</span><br><span class="line">IHFRLABEUOTSGJVDKCPMNZQWXY</span><br><span class="line">AMKGHIWPNYCJBFZDRUSLOQXVET</span><br><span class="line">GWTHSPYBXIZULVKMRAFDCEONJQ</span><br><span class="line">NOZUTWDCVRJLXKISEFAPMYGHBQ</span><br><span class="line">XPLTDSRFHENYVUBMCQWAOIKZGJ</span><br><span class="line">UDNAJFBOWTGVRSCZQKELMXYIHP</span><br><span class="line">MNBVCXZQWERTPOIUYALSKDJFHG</span><br><span class="line">LVNCMXZPQOWEIURYTASBKJDFHG</span><br><span class="line">JZQAWSXCDERFVBGTYHNUMKILOP</span><br><span class="line">密钥为：2，3，7，5，13,12,9，1，8，10，4，11，6</span><br><span class="line">密文为：NFQKSEVOQOFNP</span><br></pre></td></tr></table></figure></p><p>其实就是<a href="https://en.wikipedia.org/wiki/Jefferson_disk" target="_blank" rel="noopener">Jefferson disk（杰弗逊圆盘）</a><br>解密方法：<br>密钥就是转盘的位置，根据密钥排序，轮盘第一轮对应给出的密文。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2: &lt; N ACZDTRXMJQOYHGVS F UWIKPBEL &lt;</span><br><span class="line">3: &lt; F HTEQGYXPLOCKBDMA I ZVRNSJUW &lt;</span><br><span class="line">7: &lt; Q GWTHSPYBXIZULVKM R AFDCEONJ&lt;</span><br><span class="line">5: &lt; K CPMNZQWXYIHFRLAB E UOTSGJVD &lt;</span><br><span class="line">13： S XCDERFVBGTYHNUMK I LOPJZQAW &lt;</span><br><span class="line">12： E IURYTASBKJDFHGLV N CMXZPQOW &lt;</span><br><span class="line">9: &lt; V UBMCQWAOIKZGJXPL T DSRFHENY &lt;</span><br><span class="line">1: &lt; O SFEZWAXJGDLUBVIQ H KYPNTCRM &lt;</span><br><span class="line">8: &lt; Q NOZUTWDCVRJLXKIS E FAPMYGHB&lt;</span><br><span class="line">10: &lt;O WTGVRSCZQKELMXYI H PUDNAJFB &lt;</span><br><span class="line">4: &lt; F CUKTEBSXQYIZMJWA O RPLNDVHG &lt;</span><br><span class="line">11： N BVCXZQWERTPOIUYA L SKDJFHGM &lt;</span><br><span class="line">6: &lt; P NYCJBFZDRUSLOQXV E TAMKGHIW &lt;</span><br></pre></td></tr></table></figure></p><p>得到flag：FIREINTHEHOLE</p><a id="more"></a><h3 id="告诉你个秘密（100）"><a href="#告诉你个秘密（100）" class="headerlink" title="告诉你个秘密（100）"></a>告诉你个秘密（100）</h3><p>简单加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">636A56355279427363446C4A49454A7154534230526D6843</span><br><span class="line">56445A31614342354E326C4B4946467A5769426961453067</span><br></pre></td></tr></table></figure></p><p>十六禁止，先转字符：<br>cjV5RyBscDlJIEJqTSB0RmhC<br>VDZ1aCB5N2lKIFFzWiBiaE0g<br>4的整数倍，base64解码：<br>r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM<br>低头看键盘：tongyuan</p><h3 id="神秘图片（100）"><a href="#神秘图片（100）" class="headerlink" title="神秘图片（100）"></a>神秘图片（100）</h3><p>小明最近参加一个叫共济会的社团，社长一天神秘失踪，在社长电脑桌面上同学们发现一张奇怪的照片，为找到社长，社员们正在努力解密这张照片，可是一直找不到答案，你们发现神秘蛛丝马迹吗?</p><p>拿到图，先binwalk，foremost修复得到一张新图，好熟悉，想起了当年玩的刺客信条。</p><p><img src="https://image.evilpwn.me/blog/iscc17-basic03.png-sign" alt="神秘图片"></p><p><a href="http://baike.baidu.com/item/%E7%8C%AA%E5%9C%88%E5%AF%86%E7%A0%81" target="_blank" rel="noopener">共济会密码（猪圈密码）</a><br>解出：goodluck</p><h3 id="你猜猜（100）"><a href="#你猜猜（100）" class="headerlink" title="你猜猜（100）"></a>你猜猜（100）</h3><p>我们刚刚拦截了，敌军的文件传输获取一份机密文件，请君速速破解。<br>给了个txt文本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000</span><br></pre></td></tr></table></figure></p><p><code>504B0304</code>，zip，十六进制保存为zip后，发现加密，而且不是伪加密，ziperello爆破：123456，解压得flag。</p><blockquote><p>附：<br>JPEG (jpg)，文件头：FFD8FF<br>PNG (png)，文件头：89504E47<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424D<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only] (eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>MS Word/Excel (xls.or.doc)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Postscript (eps.or.ps)，文件头：252150532D41646F6265<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>Windows Password (pwl)，文件头：E3828596<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645<br>AVI (avi)，文件头：41564920<br>Real Audio (ram)，文件头：2E7261FD<br>Real Media (rm)，文件头：2E524D46<br>MPEG (mpg)，文件头：000001BA<br>MPEG (mpg)，文件头：000001B3<br>Quicktime (mov)，文件头：6D6F6F76<br>Windows Media (asf)，文件头：3026B2758E66CF11<br>MIDI (mid)，文件头：4D546864 </p></blockquote><h3 id="公邮密码（100）"><a href="#公邮密码（100）" class="headerlink" title="公邮密码（100）"></a>公邮密码（100）</h3><p>小明的U盘中毒了。病毒把小明的文档压缩并加密。现在小明忘了公邮密码，然而记录密码的文档却被病毒压缩并加密，你能帮助小明解开吗？<br>一个zip加密文件，爆破，得base64加密的flag，解密即可。</p><h3 id="说我作弊，需要证据-（100）"><a href="#说我作弊，需要证据-（100）" class="headerlink" title="说我作弊，需要证据 （100）"></a>说我作弊，需要证据 （100）</h3><p>X老师怀疑一些调皮的学生在一次自动化计算机测试中作弊，他使用抓包工具捕获到了Alice和Bob的通信流量。狡猾的Alice和Bob同学好像使用某些加密方式隐藏通信内容，使得X老师无法破解它，也许你有办法帮助X老师。X老师知道Alice的RSA密钥为(n, e) = (0x53a121a11e36d7a84dde3f5d73cf, 0x10001) (192.168.0.13),Bob的RSA密钥为(n, e) =(0x99122e61dc7bede74711185598c7, 0x10001) (192.168.0.37)</p><p>给了个pcapng包，追踪TCP流，得到一些base64编码的字符串。<br><img src="https://image.evilpwn.me/blog/iscc17-TCP-2.png-sign" alt="tcp"></p><p>解码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">fo = open(<span class="string">"out.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'tcp.txt'</span>) <span class="keyword">as</span> ft:</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ft:</span><br><span class="line">decoded = base64.b64decode(line)</span><br><span class="line">fo.write(decoded+<span class="string">"\n"</span>)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEQ = 13; DATA = 0x3b04b26a0adada2f67326bb0c5d6L; SIG = 0x2e5ab24f9dc21df406a87de0b3b4L;</span><br><span class="line">SEQ = 0; DATA = 0x7492f4ec9001202dcb569df468b4L; SIG = 0xc9107666b1cc040a4fc2e89e3e7L;</span><br><span class="line">SEQ = 5; DATA = 0x94d97e04f52c2d6f42f9aacbf0b5L; SIG = 0x1e3b6d4eaf11582e85ead4bf90a9L;</span><br><span class="line">SEQ = 4; DATA = 0x2c29150f1e311ef09bc9f06735acL; SIG = 0x1665fb2da761c4de89f27ac80cbL;</span><br><span class="line">SEQ = 18; DATA = 0x181901c059de3b0f2d4840ab3aebL; SIG = 0x1b8bdf9468f81ce33a0da2a8bfbeL;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可得到SEQ（序列），DATA，SIG（签名）。<br>分析完pcapng包，再来看题中给出的RSA密钥：<br>Alice：(n, e) = (0x53a121a11e36d7a84dde3f5d73cf, 0x10001)<br>Bob：(n, e) =(0x99122e61dc7bede74711185598c7, 0x10001)<br>可见n并不够大，可以分解出p和q，转换十进制后，利用<a href="http://factordb.com/index.php" target="_blank" rel="noopener">FactorDB</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Alice: </span><br><span class="line">n = p * q </span><br><span class="line">= 0x53a121a11e36d7a84dde3f5d73cf </span><br><span class="line">= 1696206139052948924304948333474767 </span><br><span class="line">= 38456719616722997 * 44106885765559411</span><br><span class="line">Bob: </span><br><span class="line">n = p * q </span><br><span class="line">= 0x99122e61dc7bede74711185598c7 </span><br><span class="line">= 3104649130901425335933838103517383 </span><br><span class="line">= 49662237675630289 * 62515288803124247</span><br></pre></td></tr></table></figure></p><p>下面就可以利用pycrypto解出密文了，注意签名与数据匹配的数据包才被是有效数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> gmpy</span><br><span class="line"><span class="comment"># Alice</span></span><br><span class="line">n1 = long(<span class="number">1696206139052948924304948333474767</span>)</span><br><span class="line">e = long(<span class="number">65537</span>)</span><br><span class="line"><span class="comment"># Bob</span></span><br><span class="line">n2 = long(<span class="number">3104649130901425335933838103517383</span>)</span><br><span class="line"><span class="comment"># 分解n得到的p和q</span></span><br><span class="line">p1 = <span class="number">38456719616722997</span></span><br><span class="line">q1 = <span class="number">44106885765559411</span></span><br><span class="line">p2 = <span class="number">49662237675630289</span></span><br><span class="line">q2 = <span class="number">62515288803124247</span></span><br><span class="line"><span class="comment"># 求出解密指数d</span></span><br><span class="line">phi1 = (p1<span class="number">-1</span>)*(q1<span class="number">-1</span>)</span><br><span class="line">phi2 = (p2<span class="number">-1</span>)*(q2<span class="number">-1</span>)</span><br><span class="line">d1 = long(gmpy.invert(e, phi1))</span><br><span class="line">d2 = long(gmpy.invert(e, phi2))</span><br><span class="line"><span class="comment"># 构建RSA</span></span><br><span class="line">rsa1 = RSA.construct( (n1, e, d1) )</span><br><span class="line">rsa2 = RSA.construct( (n2, e, d2) )</span><br><span class="line"><span class="comment"># 利用pcapfile读取转换格式后的pcap包</span></span><br><span class="line"><span class="keyword">from</span> pcapfile <span class="keyword">import</span> savefile</span><br><span class="line">cf = savefile.load_savefile(open(<span class="string">"new.pcap"</span>))</span><br><span class="line">output = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> cf.packets:</span><br><span class="line">    pack = str(p.packet)[<span class="number">136</span>:].decode(<span class="string">'hex'</span>).decode(<span class="string">'base64'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'DATA'</span> <span class="keyword">in</span> pack:</span><br><span class="line">        seq = int(pack.split(<span class="string">';'</span>)[<span class="number">0</span>].split(<span class="string">' '</span>)[<span class="number">2</span>])</span><br><span class="line">        data = pack[<span class="number">16</span>:].split(<span class="string">';'</span>)[<span class="number">0</span>][:<span class="number">-1</span>]</span><br><span class="line">        sig = long(pack.split(<span class="string">';'</span>)[<span class="number">2</span>].split(<span class="string">' = '</span>)[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">        m = long(data, <span class="number">16</span>)</span><br><span class="line">        decrypted = rsa2.decrypt(m)</span><br><span class="line">        sigcheck = rsa1.sign(decrypted, <span class="string">''</span>)[<span class="number">0</span>]</span><br><span class="line">        val = str(hex(decrypted)).strip(<span class="string">'0x'</span>).rstrip(<span class="string">'L'</span>).zfill(<span class="number">2</span>).decode(<span class="string">'hex'</span>)</span><br><span class="line">        <span class="keyword">if</span> sig == sigcheck:</span><br><span class="line">            output[seq] = val</span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span>.join(output.values())</span><br></pre></td></tr></table></figure></p><p>该脚本来源<a href="https://www.honoki.net/2015/10/hack-lu-2015-creative-cheating" target="_blank" rel="noopener">@Hohoki</a><br>flag{n0th1ng_t0_533_h3r3_m0v3_0n}<br>nothing to see here move on，哈哈，果然是调皮的学生。</p><h3 id="PHP-encrypt-1（150）"><a href="#PHP-encrypt-1（150）" class="headerlink" title="PHP_encrypt_1（150）"></a>PHP_encrypt_1（150）</h3><p>大黑阔在某数据库中提取到了管理员的密码，但是密码是加密的，本要放弃的黑阔突然发现加密竟然是可逆的，网页上的脚本被黑阔提取出来了，你能够帮助黑阔解密吗？黑阔感激不尽<br>加密数据：fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=<br>附件是index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span><span class="params">($data,$key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $key = md5(<span class="string">'ISCC'</span>);</span><br><span class="line">    $x = <span class="number">0</span>;</span><br><span class="line">    $len = strlen($data);</span><br><span class="line">    $klen = strlen($key);</span><br><span class="line">    <span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; $len; $i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> ($x == $klen)</span><br><span class="line">        &#123;</span><br><span class="line">            $x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $char .= $key[$x];</span><br><span class="line">        $x+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">        $str .= chr((ord($data[$i]) + ord($char[$i])) % <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base64_encode($str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>根据给出的加密数据和index.php，逆向得：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> $data = &apos;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&apos;;</span><br><span class="line"> $data = base64_decode($data);</span><br><span class="line"> $str =&apos;&apos;;</span><br><span class="line"> $key = md5(&apos;ISCC&apos;);</span><br><span class="line"> $x = 0;</span><br><span class="line"> $len = strlen($data);</span><br><span class="line"> $klen = strlen($key);</span><br><span class="line"> for ($i=0; $i &lt; $len; $i++) &#123; </span><br><span class="line"> if ($x == $klen)</span><br><span class="line"> &#123;</span><br><span class="line"> $x = 0;</span><br><span class="line"> &#125;</span><br><span class="line"> $char .= $key[$x];</span><br><span class="line"> $x+=1;</span><br><span class="line"> &#125;</span><br><span class="line"> for ($i=0; $i &lt; $len; $i++) &#123;</span><br><span class="line"> if(ord($data[$i])&lt;ord($char[$i]))&#123;</span><br><span class="line"> $str .= chr(ord($data[$i])+128-ord($char[$i]));</span><br><span class="line"> &#125;else &#123;</span><br><span class="line"> $str .= chr(ord($data[$i])-ord($char[$i]));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> echo $str;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="二维码（150）"><a href="#二维码（150）" class="headerlink" title="二维码（150）"></a>二维码（150）</h3><p>这是一个二维码<br><img src="https://image.evilpwn.me/blog/basic07.png-sign" alt="二维码"><br>binwalk得到加密的zip，爆破解压得：C8-E7-D8-E8-E5-88_handshake.cap和破解记录.txt，破解记录里写着：前四位是ISCC 后四位由大写字母和数字构成。简单，crunch制作字典，跑一下就出来了。</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="Web签到题，来和我换flag啊！（100）"><a href="#Web签到题，来和我换flag啊！（100）" class="headerlink" title="Web签到题，来和我换flag啊！（100）"></a>Web签到题，来和我换flag啊！（100）</h3><p>Ps：比赛过程中严禁和其他队伍互换flag！！！<br><a href="http://139.129.108.53:3190/web-02/" target="_blank" rel="noopener">http://139.129.108.53:3190/web-02/</a><br>打开后提示“you give me a f1ag，I will give you a flag too”(记不清了，大致这个意思)<br>源代码中一个文本框，一个隐藏文本框，post提交f1ag后，得到提示，再要一个FLAG，ok，提交后，http头部得到flag。</p><h3 id="WelcomeToMySQL（150）"><a href="#WelcomeToMySQL（150）" class="headerlink" title="WelcomeToMySQL（150）"></a>WelcomeToMySQL（150）</h3><p>Welcome to MySQL! SQL inject?<br><a href="http://139.129.108.53:8081/web-01/" target="_blank" rel="noopener">http://139.129.108.53:8081/web-01/</a><br>打开后发现是文件上传，又根据提示SQL注入，很明显上传一句话。<br>尝试了几种上传绕过，发现php5可以，菜刀连接后，在base.php（源码中也有提示）中，找到数据库的相关信息<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername=<span class="string">"localhost"</span>;</span><br><span class="line">$username=<span class="string">"iscc2017"</span>;</span><br><span class="line">$password=<span class="string">"iscc2017"</span>;</span><br><span class="line">$db=<span class="string">"flag"</span>;</span><br><span class="line">$tb=<span class="string">"flag"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>连接数据库，查到flag。</p><h3 id="where-is-your-flag-（150）"><a href="#where-is-your-flag-（150）" class="headerlink" title="where is your flag （150）"></a>where is your flag （150）</h3><p>美国大黑阔Jack来窃取小明的flag，看上去确实很简单<br><a href="http://139.129.108.53:6980/web-08/" target="_blank" rel="noopener">http://139.129.108.53:6980/web-08/</a><br>宽字节注入，构造payload后得flag</p><h3 id="我们一起来日站（150）"><a href="#我们一起来日站（150）" class="headerlink" title="我们一起来日站（150）"></a>我们一起来日站（150）</h3><p>老司机发挥所长，利用平时拿站的技巧来解题吧<br><a href="http://139.129.108.53:5090/web-04/" target="_blank" rel="noopener">http://139.129.108.53:5090/web-04/</a><br>根据rebots.txt找到后台登陆地址admin.php<br>万能密码<code>&#39; or &#39;1&#39;=&#39;1</code>直接得flag。</p><h3 id="自相矛盾（150）"><a href="#自相矛盾（150）" class="headerlink" title="自相矛盾（150）"></a>自相矛盾（150）</h3><p>打破常规，毁你三观！<br><a href="http://139.129.108.53:8083/web-09/" target="_blank" rel="noopener">http://139.129.108.53:8083/web-09/</a><br>php弱类型，<a href="http://bobao.360.cn/learning/detail/188.html" target="_blank" rel="noopener">原题</a>改了个字符串，构造payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://139.129.108.53:8083/web-09/index.php?iscc=&#123;%22bar1%22:%222017e%22,%22bar2%22:[[1],1,2,3,0]&#125;&amp;cat[0]=00isccctf2017&amp;cat[1][]=1111&amp;dog=%00</span><br></pre></td></tr></table></figure></p><h3 id="I-have-a-jpg-i-upload-a-txt-（200）"><a href="#I-have-a-jpg-i-upload-a-txt-（200）" class="headerlink" title="I have a jpg,i upload a txt.（200）"></a>I have a jpg,i upload a txt.（200）</h3><p>小明发现，php将上传的jpg文件流写入一个txt中，再重命名后缀为jpg还可以正常读取，于是写了一段上传代码，会不会有什么漏洞呢？<br><a href="http://139.129.108.53:3366/web-03" target="_blank" rel="noopener">http://139.129.108.53:3366/web-03</a></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="眼见非实（100）"><a href="#眼见非实（100）" class="headerlink" title="眼见非实（100）"></a>眼见非实（100）</h3><p>附件是docx，改名zip后解压，从/word/document.xml中得flag。</p><h3 id="就在其中（150）"><a href="#就在其中（150）" class="headerlink" title="就在其中（150）"></a>就在其中（150）</h3><p>啊。我好像捕获到了什么不得了的东西。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXgIBAAKBgQD0UN0A+70iM0VCJ1ni0n/U1BRj0u8yMWH4Qi+xTbjHgbE7wOuk</span><br><span class="line">OaO+2PyQXiqIzZnf5jCkJuVDYjALGcKrZM4OCQBBd85B/LTc36XZ7JVfX5kGy5tI</span><br><span class="line">R3tquuPIVKNdAsHlSqh9S7YSS39RdnSa5rOUyGhrLzxwzzM9IO4e+QQ+CQIDAQAB</span><br><span class="line">AoGADiaw5mGubtCxbkeBOVYf+V/fXnjVSf76QbrzsD1kOooUjfV6sKR2C5Pd7S7H</span><br><span class="line">H+1owENBBgEKvoBtb/cqA2tvU9vQ4l5TMBJcHv6LEcb9WPpnMxPV2GNjO+DTPGPy</span><br><span class="line">Xnu1UZlZjwx+NaF5rESoSSVS2ZaaIixBs4RWRXk+lHEbTFECQQD6Rp6jMweRgPHO</span><br><span class="line">pR3mgIK83zL+kzqYM5isIPv3DIC5JQN2kXqK73IDQCFVlfXnr9lAAVRzLDsAXLqv</span><br><span class="line">le/o6yQLAkEA+edY+GERlLuD1t2k9Js0Dc7EwnLcxoFUE60ivj8Gf9jzLskGHxsv</span><br><span class="line">0IV6J5OHwPh54kAxAnqCjSqNRAWGNzr+uwJBALYEjDUm1LdGrxXZ0jAkgHC6Z0zs</span><br><span class="line">aK3uwHdXGcinqCp+t9EQpq3KzQF+L4AeKxRQONEq5m9I2LQ/vGocwrmD4dcCQQDb</span><br><span class="line">rTyOinWz8upAFPKOe2hUwvA/pkzgyosoCMhDyI9kD0gmVlvlODbd7Jem9o8dWM97</span><br><span class="line">zcXHUf41LbSkmN6U6m1FAkEAqmZbr35bPfkeoiikwNl6OVQytg12TZjw2vIbvfub</span><br><span class="line">f9Rvti8Lh/tbrmhZroiz8/l3aAZmugI1NBcbeZR0gz8ggg==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure></p><p>给了个私钥和pcapng包，binwalk提取出一个压缩包，解压得一个加密的key.txt，把私钥保存为private.key，利用<a href="http://www.cnblogs.com/aLittleBitCool/archive/2011/09/22/2185418.html" target="_blank" rel="noopener">openssl</a>解密即可。<br><code>openssl rsautl -decrypt -in key.txt -inkey private.key -out key_flag.txt</code></p><h3 id="待更"><a href="#待更" class="headerlink" title="待更"></a>待更</h3>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> writeup </tag>
            
            <tag> ISCC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识Metasploit</title>
      <link href="/2017/acquaintance-metasploit/"/>
      <url>/2017/acquaintance-metasploit/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>通过模拟恶意攻击者的技术和方法，挫败目标系统安全控制措施，取得访问控制权，并发现具有业务影响后安全隐患的一种安全测试与评估方式。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>黑盒测试：模拟一个对客户组织一无所知的攻击者，进行渗透攻击。</li><li>白盒测试：攻击者拥有客户组织所有知识的情况下，进行渗透攻击。</li></ul><a id="more"></a><h3 id="黑盒测试（Block-box-Testing）"><a href="#黑盒测试（Block-box-Testing）" class="headerlink" title="黑盒测试（Block-box Testing）"></a>黑盒测试（Block-box Testing）</h3><p>也称<strong>外部测试（External Testing）</strong>，从一个远程网络位置来评估目标网络基础设施，完全模拟真实网络中的攻击者，所以比较费时费力，同时需要渗透测试者具备较高的技术能力。</p><h3 id="白盒测试（Write-box-Testing）"><a href="#白盒测试（Write-box-Testing）" class="headerlink" title="白盒测试（Write-box Testing）"></a>白盒测试（Write-box Testing）</h3><p>也称<strong>内部测试（Internal Tesing）</strong>，可以先了解到目标环境的所有内部与底知识，以最小的代价发现和验证系统中最严重的安全漏洞。如果实施到位，比黑盒测试消除更多目标环境中漏洞与弱点。<br>但白盒测试最大问题在于无法有效的测试客户组织的应急响应程序，也无法判断他们安全防护计划对监测特定攻击的效率。</p><h3 id="灰盒测试（Grey-box-Testing）"><a href="#灰盒测试（Grey-box-Testing）" class="headerlink" title="灰盒测试（Grey-box Testing）"></a>灰盒测试（Grey-box Testing）</h3><p>以上两种方式的组合，渗透者能根据目标系统所掌握的有限知识与信息，来选择评估整体安全性的最佳途径。测试中，也需要从外部逐步渗透进入目标网络，但他所拥有的目标网络底层拓扑与架构有助于更好的决策攻击途径与方法。</p><h3 id="规范测试的流程"><a href="#规范测试的流程" class="headerlink" title="规范测试的流程"></a>规范测试的流程</h3><ol><li>前期交互阶段<br>确定渗透测试的范围、目标、限制条件以及服务合同细节。</li><li>情报搜集阶段<br>获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。<br>方法：公开来源信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。</li><li>威胁建模阶段<br>针对获取的信息进行威胁建模与攻击规划。<br>目标：从大量的信息情报中理清头绪，确定出最可行的攻击通道。</li><li>漏洞分析阶段<br>考虑该如何取得目标系统的访问控制权。<br>操作：通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。可以针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘。</li><li>渗透攻击阶段<br>利用所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。</li><li>后渗透攻击阶段<br>渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。</li><li>报告阶段<br>一份凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程、造成业务影响后果的攻击途径以及站在防御者的角度帮助他们分析安全防御体系中的薄弱环节、存在的问题和修补升级技术方案的报告。</li></ol><h2 id="Metasploit体系框架"><a href="#Metasploit体系框架" class="headerlink" title="Metasploit体系框架"></a>Metasploit体系框架</h2><p><img src="https://image.evilpwn.me/blog/meta-tx-01.png-sign" alt="Metasploit体系框架"></p><ol><li><p>基础库文件<br>源码在根目录下的libraries目录中，包括Rex、framework-core、framework-base三部分。</p><ul><li>Rex：整个Metasploit框架所依赖的最基础的一些组件，如：包装的网络套接字、网络应用协议客户端与服务端实现、日志子系统、渗透攻击支持例程、PostgreSQL及MySQL数据库支持等。</li><li>framework-core库负责实现所有与各种类型的上层模块及插件的交互接口。</li><li>framework-base库扩展了framework-core，提供更加简单的包装例程，并为处理框架各个方面的功能提供一些功能类，用于支持用户接口与功能程序调用框架本身功能及框架继承模块。</li></ul></li><li><p>模块<br>按用途分为：辅助模块（Aux）、渗透攻击模块（Exploits）、后渗透攻击模块（Post）、攻击载荷模块（Payloads）、空指令模块（Nops）和编译器模块（Encoders）。</p></li><li><p>插件<br>扩充框架功能，或者组装已有功能构成高级特性的组件。还可集成现有的一些外部安全工具，如Nessus、OpenVAS漏洞扫描器等，为用户接口提供一些新的功能命令、记录所有的网络记录或提供创新的渗透测试功能。</p></li><li><p>接口<br>msfconsole控制台终端、msfcli命令行、msfgui图形化界面、armitage图形化界面及msfapi远程调用接口等</p></li><li><p>功能程序<br>除了框架主功能之外，还提供一系列可直接运行的功能程序，如msfpayload、msfencode和msfvenom可将攻击载荷封装为可执行文件、C语言、JavaScript语言等，并进行各种类型的编码。<br>msf*scan系列提供在PE、ELF等各种类型文件中搜索特定指令的功能，帮助定位指令地址。</p></li></ol><h2 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h2><h3 id="辅助模块（Aux）"><a href="#辅助模块（Aux）" class="headerlink" title="辅助模块（Aux）"></a>辅助模块（Aux）</h3><p>帮助渗透测试之前得到目标系统丰富的情报信息，从而更具目标性的精准攻击</p><h3 id="渗透攻击模块（Exploits）"><a href="#渗透攻击模块（Exploits）" class="headerlink" title="渗透攻击模块（Exploits）"></a>渗透攻击模块（Exploits）</h3><p>发现漏洞或配置弱点进行攻击，以植入和运行攻击载荷，从而获得访问权。<br>其按照漏洞所在位置分为<strong>主动渗透攻击</strong>和<strong>被动渗透攻击</strong>。</p><ul><li>主动渗透攻击<br>漏洞位于网络服务端软件与服务承载的上层应用程序之中。<br>服务端通常开启一些监听端口等待客户端连接，针对它们的渗透攻击可以主动发出。</li><li>被动渗透攻击<br>漏洞位于客户端软件中，对于客户端软件的安全漏洞，渗透者无法主动的将数据从远程输入到客户端软件中，因此采用被动渗透攻击。<blockquote><ol><li>利用网络欺骗、劫持等各种技术，欺骗目标打开恶意内容的服务器、邮件附件等，从而触发客户端软件的安全漏洞。</li><li>被动渗透可绕过防火强等网络边界防护措施。</li><li>最常见的两类被动渗透：<strong>浏览器软件漏洞攻击</strong>、<strong>文件格式类漏洞攻击</strong>。</li></ol></blockquote></li></ul><h3 id="攻击载荷模块（Payloads）"><a href="#攻击载荷模块（Payloads）" class="headerlink" title="攻击载荷模块（Payloads）"></a>攻击载荷模块（Payloads）</h3><p>攻击载荷：渗透攻击成功后促使目标系统执行一段植入代码。通常作用为打开目标系统上的控制会话连接。<br>该模块分为3类：独立（Singles），传输器（Stager），传输体（Stage）。<br>独立攻击载荷。</p><ul><li>独立攻击载荷是完全自包含的，可直接独立地植入目标系统进行执行。</li><li>在一些特殊的渗透攻击场景中，可能会对攻击载荷的大小、运行条件有所限制，利用<strong>传输器</strong>和<strong>传输体</strong>配对分阶段植入的技术，由渗透攻击模块首先植入代码精悍短小且非常可靠的传输器载荷，然后在运行传输器载荷时进一步下载传输体载荷并执行。</li></ul><h3 id="空指令模块（NOP）"><a href="#空指令模块（NOP）" class="headerlink" title="空指令模块（NOP）"></a>空指令模块（NOP）</h3><p>对程序运行状态不会造成任何实质影响的空操作或无关操作指令。<br>如空操作，x86 CPU体系构架平台上的操作码是0x90。</p><blockquote><p>在渗透攻击构造数据缓冲区时，在真正要执行的Shellcode之前添加一段空指令区，当触发渗透攻击后跳转执行Shellcode时，有较大的安全着陆区，从而避免受到内存地址随机化、返回地址计算偏差等原因造成的Shellcode执行失败。</p></blockquote><h3 id="编译器模块（Encoders）"><a href="#编译器模块（Encoders）" class="headerlink" title="编译器模块（Encoders）"></a>编译器模块（Encoders）</h3><p>攻击载荷模块（Payloads）与空指令模块（NOP）组装完成一个指令序列后，进行编码（Encoding）。</p><blockquote><p>编译器模块的使命：</p><ol><li>确保渗透过程中，攻击载荷不会出现难以加载的<strong>“坏字符”</strong>，如：0x00空字节，字符串操作函数中输入字符串中的空字节，会将后面内容截断，攻击载荷无法完整运行；网络输入使用明文协议，那么攻击载荷的内容都是可打印字符。</li><li>对攻击载荷进行免杀，逃避反病毒软件、IDS入侵检测系统和IPS入侵防御系统的检测和阻断。</li></ol></blockquote><p><strong>注意：</strong>编码后，载荷体积增大，而每个渗透攻击模块能植入的邪恶缓冲区大小受漏洞触发条件限制（通常在渗透攻击模块的Space字段中指明），所以自动编码会找不到合适的编码器（编码后大小溢出），“No encoders encoded the buffer successfully”。<br>此时，就要选择一个<strong>传输器</strong>和<strong>传输体</strong>配对构成的攻击载荷，以短小精悍的传输器避免编码后超出空间限制，再运行传输器载荷就不受空间大小约束了。</p><h3 id="后渗透攻击模块（Post）"><a href="#后渗透攻击模块（Post）" class="headerlink" title="后渗透攻击模块（Post）"></a>后渗透攻击模块（Post）</h3><p>v4版本中的新模块，主要在取得目标控制权后进行的各种攻击，如获取敏感信息、进一步拓展、实施跳板攻击等。其中最强大的是Meterperter模块。</p><h2 id="Metasploit的使用接口"><a href="#Metasploit的使用接口" class="headerlink" title="Metasploit的使用接口"></a>Metasploit的使用接口</h2><ul><li>msfgui图形化管理界面</li><li>msfconsole控制台终端</li><li>msfcli命令行程序<h3 id="控制台终端的优势"><a href="#控制台终端的优势" class="headerlink" title="控制台终端的优势"></a>控制台终端的优势</h3></li></ul><ol><li>访问框架中每一项功能，并能直接执行外部shell命令和第三方（Nmap等）。</li><li>更新及时，最稳定的Metasploit用户接口。</li></ol><p>输入<code>help xxx</code>显示该命令的参数列表。</p><h3 id="msfcli命令行程序"><a href="#msfcli命令行程序" class="headerlink" title="msfcli命令行程序"></a>msfcli命令行程序</h3><p>为脚本自动化处理及与其他命令行工具互操作而设计的一种用户接口。<br>相对于msf终端，弱点在于支持的功能特性少以及不支持MSF终端中的高级自动化渗透测试特性。</p>]]></content>
      
      
      <categories>
          
          <category> metasploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> metasploit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统-进程调度算法</title>
      <link href="/2017/OS-dispatching-algorithm/"/>
      <url>/2017/OS-dispatching-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><ol><li>先来先服务</li><li>短进程优先</li><li>优先级算法</li><li>时间片轮转算法</li><li>多级反馈队列算法</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><figcaption><span>进程调度算法.cpp</span><a href="/downloads/code/c/进程调度算法1.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FCFS SJF 优先级算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>; <span class="comment">//进程数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCB</span>{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> arrivalTime;</span><br><span class="line">    <span class="keyword">float</span> serviceTime;</span><br><span class="line">    <span class="keyword">float</span> startTime;</span><br><span class="line">    <span class="keyword">float</span> finishTime;</span><br><span class="line">    <span class="keyword">float</span> turnoverTime;  <span class="comment">// 周转时间</span></span><br><span class="line">    <span class="keyword">float</span> turnaroundTime;  <span class="comment">// 带权周转时间</span></span><br><span class="line">    <span class="keyword">int</span> pri;  <span class="comment">//优先级</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(PCB *p, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N - <span class="number">1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d个进程："</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %f %f %d"</span>, p[i].name, &amp;p[i].arrivalTime, &amp;p[i].serviceTime, &amp;p[i].pri);</span><br><span class="line">        p[i].startTime = <span class="number">0</span>;</span><br><span class="line">        p[i].finishTime = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(PCB *p, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行顺序：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, p[<span class="number">0</span>].name);</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt; N; k++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--&gt;%s"</span>, p[k].name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程名\t到达时间\t运行时间\t完成时刻\t周转时间\t带权周转时间\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">     {</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%6s\t%8.2f\t%8.2f\t%8.2f\t%8.2f\t%12.2f\t"</span>,p[k].name,p[k].arrivalTime,p[k].serviceTime,p[k].finishTime,p[k].turnoverTime,p[k].turnaroundTime);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算各时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(PCB *p, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 第一个进程到达</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            p[k].startTime = p[k].arrivalTime;</span><br><span class="line">            p[k].finishTime = p[k].arrivalTime + p[k].serviceTime;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            p[k].startTime = p[k - <span class="number">1</span>].finishTime;</span><br><span class="line">            p[k].finishTime = p[k].startTime + p[k].serviceTime;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 周转时间 = 完成时间 - 到达时间</span></span><br><span class="line">        p[k].turnoverTime = p[k].finishTime - p[k].arrivalTime;</span><br><span class="line">        <span class="comment">// 带权周转时间 = 周转时间/服务时间</span></span><br><span class="line">        p[k].turnaroundTime = p[k].turnoverTime/p[k].serviceTime;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//FCFS 进程到达时间排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FCFS</span><span class="params">(PCB *p, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    {</span><br><span class="line">        PCB t = p[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; t.arrivalTime &lt; p[j].arrivalTime; j--)</span><br><span class="line">            p[j+<span class="number">1</span>] = p[j];</span><br><span class="line">        p[j+<span class="number">1</span>] = t;</span><br><span class="line">    }</span><br><span class="line">calc(p,N);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n先来先服务"</span>);</span><br><span class="line">output(p,N);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SJF 短进程优先排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SJF</span><span class="params">(PCB *p,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    {</span><br><span class="line">        PCB t = p[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; t.serviceTime &lt; p[j].serviceTime; j--)</span><br><span class="line">            p[j+<span class="number">1</span>] = p[j];</span><br><span class="line">        p[j+<span class="number">1</span>] = t;</span><br><span class="line">    }</span><br><span class="line">    calc(p,N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n短作业优先"</span>);</span><br><span class="line">    output(p,N);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">priority</span><span class="params">(PCB *p,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    {</span><br><span class="line">        PCB t = p[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; t.pri &lt; p[j].pri; j--)</span><br><span class="line">            p[j+<span class="number">1</span>] = p[j];</span><br><span class="line">        p[j+<span class="number">1</span>] = t;</span><br><span class="line">    }</span><br><span class="line">    calc(p,N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n优先级算法"</span>);</span><br><span class="line">    output(p,N);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前进程个数设置为：%d\n请分别输入进程的“名字、到达时间、服务时间、优先级”\n[注]优先级为1-%d，不采用优先级算法则全部输入0\n如:a 8.0 2.0 0\n\n"</span>,N,N);</span><br><span class="line">    PCB p[N];</span><br><span class="line">    input(p, N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>].pri==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        FCFS(p,N);</span><br><span class="line">        SJF(p,N);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        priority(p,N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>RIP协议</title>
      <link href="/2017/RIP/"/>
      <url>/2017/RIP/</url>
      
        <content type="html"><![CDATA[<h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>RIP是一种基于距离矢量（distance-vector）的路由协议，以路由跳数(hop)作为计数单位的路由协议。适合用于比较小型的网络环境。</p><h3 id="使用距离矢量来决定最优路径"><a href="#使用距离矢量来决定最优路径" class="headerlink" title="使用距离矢量来决定最优路径"></a>使用距离矢量来决定最优路径</h3><ul><li>跳数（hop count）：一个报文从本节点到目的节点中途经的中转次数，也就是一个包到达目标所必须经过的路由器的数目。</li><li>下一跳（next hop）：本网上的报文欲通过本网络节点到达目的节点，如不能直接送达，则本节点应把此报文送到某个中转站点，此中转站点称为下一跳。</li><li>跳（hop） ：报文转发的中转过程。</li></ul><h3 id="RIP特点"><a href="#RIP特点" class="headerlink" title="RIP特点"></a>RIP特点</h3><p>原理和配置方法均简单，但有时不能准确地选择最优路径，收敛的时间也较长。</p><ul><li>最多支持的跳数为15 ，跳数16表示不可达 </li><li>跳数最小即为最优路由，跳数相同则为等代价路由</li><li>使用UDP 520端口交换路由信息</li><li>周期性更新，路由更新为完整的路由表</li><li>路由信息每经过一个路由器，跳数加1</li><li>使用多个时钟以保证路由的有效性与及时性</li></ul><a id="more"></a><h2 id="RIP工作过程和计时器"><a href="#RIP工作过程和计时器" class="headerlink" title="RIP工作过程和计时器"></a>RIP工作过程和计时器</h2><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p><img src="https://image.evilpwn.me/blog/RIP-01.png-sign" alt="图1"></p><p>路由器初始的路由表中只有自己的直连路由，路由器A的更新周期首先到达（更新计时器：30s），路由器B收到A发出的路由更新，将1.0.0.0加入路由表，跳数为1。随后，路由器B的更新周期到达，路由器A和C收到B发出的路由更新。接着，路由器C到达更新周期，路由器B收到路由更新，刷新路由表，并在更新周期到来时发送新的路由更新。随着这个过程的不断重复，所有路由器都学习到了全部的路由——收敛完毕。</p><p><img src="https://image.evilpwn.me/blog/RIP-02.png-sign" alt="图2"></p><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><ul><li>更新计时器<br>30s（为了防止同时更新，叠加一个随机变量，一般为5s之内）</li><li>无效计时器<br>180s，6倍更新时间内未收到更新，该路由被标记为16跳（不可达）</li><li>刷新计时器<br>120s，无效路由在刷新计时器时间内仍未被更新，则被删除</li></ul><p><img src="https://image.evilpwn.me/blog/RIP-03.png-sign" alt="计时过程"></p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://image.evilpwn.me/blog/RIP-04.png-sign" alt="RIP更新路由表"></p><h2 id="路由更新原则"><a href="#路由更新原则" class="headerlink" title="路由更新原则"></a>路由更新原则</h2><ol><li>直连路由的可信度最高。不会被更新。</li><li>本路由表已有的路由表项，当下一跳不同时，只有度量值减小才更新该路由表项。</li><li>对本路由表已有的路由表项，当下一跳相同时，不论度量值增大还是减少，都更新该路由表项。</li></ol><h2 id="路由环路"><a href="#路由环路" class="headerlink" title="路由环路"></a>路由环路</h2><h3 id="路由毒化"><a href="#路由毒化" class="headerlink" title="路由毒化"></a>路由毒化</h3><p>（更新规则3可能会导致路由毒化，从而形成路由环路）<br>使用无穷大的度量（16跳）传播关于路由失效的坏消息 。</p><h3 id="防止路由环路"><a href="#防止路由环路" class="headerlink" title="防止路由环路"></a>防止路由环路</h3><ul><li><p>水平分割<br>路由器记住每一条路由信息的来源，并且不在收到这条信息的端口上再次发送它<br>。这是保证不产生路由环路的最基本措施。</p></li><li><p>触发更新<br>在改变一条路由度量时立即广播一条更新消息，而不管30秒更新计时器还剩多少时间 </p></li><li><p>毒性逆转<br>当路由器学习到一条毒化路由（度量值为16）时，对这条路由忽略水平分割的规则，并通告毒化的路由。</p></li></ul><p><img src="https://image.evilpwn.me/blog/RIP-005.png-sign" alt="毒性逆转"></p><p>C失去网段4.0.0.0/8，立即发送一个触发的部分更新，仅包含变化的信息，即4.0.0.0/8的毒化路由。<br>B相应这个更新，修改自己的路由表，并立即会送（触发）包含4.0.0.0/8、度量值为16的更新，这就是毒性逆转。<br>到C的下一个更新周期，它会通过所有路由，包括4.0.0.0/8的毒化路由；同样，B到达下一个更新周期时，也是如此。<br>C通告的毒化路由不被认为时毒性逆转路由，因为它本来就应当通告这条路由；而B通告的毒化路由则被认为时毒性逆转路由，因为它把这条路由又通告给力C，这条失效路由原本就是从那里学习到的。</p><ul><li>抑制计数器<br>水平分割在<strong>环形拓扑</strong>（即存在冗余链路构成的环路）中水平分割不能很好的预防计数到无穷大的问题。<br><img src="https://image.evilpwn.me/blog/RIP-06.png-sign" alt="环路水平分割01"><br>B先收到4.0.0.0/8的毒化路由的部分更新，修改度量值为16，然后可能会收到C发出的周期性更新，里面声明到达4.0.0.0/8的度量值为2，结果再把度量值更新为2，下一跳为路由器C。</li></ul><p><img src="https://image.evilpwn.me/blog/RIP-07.png-sign" alt="环路水平分割02"><br>此时，C收到A的触发更新，度量值改16，但在C到达下一个更新周期时，B向A发送一个周期更新，度量值改3，之后C的周期性更新才到达，B更改度量值为16。</p><p>这样的过程不断循环，最终还是导致了计数到无穷大。</p><p>这时需要另一个防止路由环路的方法，抑制及时器（一般是180s）。<br>一条路由信息失效后，便处于抑制状态，在抑制时间内，失效的路由不接受任何更新信息（除非这条信息是从原始通告这条路由的路由器来的），以确保每台路由器都学习到这个信息。<br>抑制计时器减少了路由的浮动，增加了网络的稳定性。</p><h2 id="RIPv1-amp-RIPv2"><a href="#RIPv1-amp-RIPv2" class="headerlink" title="RIPv1 &amp; RIPv2"></a>RIPv1 &amp; RIPv2</h2><h3 id="RIPv1"><a href="#RIPv1" class="headerlink" title="RIPv1"></a>RIPv1</h3><ul><li>使用广播的方式发送路由更新</li><li>路由更新信息中不携带子网掩码，为有类路由协议</li><li>RIP报文大小限制是512字节，最多可以携带25条路由信息<br><img src="https://image.evilpwn.me/blog/RIP-08.png-sign" alt="RIPv1报文格式"></li></ul><h3 id="RIPv2"><a href="#RIPv2" class="headerlink" title="RIPv2"></a>RIPv2</h3><ul><li>RIPv2发送更新报文的方式为组播，组播地址为224.0.0.9 </li><li>路由信息中加入了子网掩码，无类的路由协议 </li><li>支持认证</li></ul><h3 id="RIPv1和RIPv2比较"><a href="#RIPv1和RIPv2比较" class="headerlink" title="RIPv1和RIPv2比较"></a>RIPv1和RIPv2比较</h3><table><thead><tr><th>特性</th><th>RIPV1</th><th>RIPV2</th></tr></thead><tbody><tr><td>采用跳数为度量值</td><td>是</td><td>是</td></tr><tr><td>15是最大的有效度量值，16为无穷大</td><td>是</td><td>是</td></tr><tr><td>默认30s更新周期</td><td>是</td><td>是</td></tr><tr><td>周期性更新时发送全部路由信息</td><td>是</td><td>是</td></tr><tr><td>拓扑改变时发送只针对变化的触发更新</td><td>是</td><td>是</td></tr><tr><td>使用路由毒化、水平分割、毒性逆转</td><td>是</td><td>是</td></tr><tr><td>使用抑制计时器</td><td>是</td><td>是</td></tr><tr><td>发送更新的方式</td><td>广播</td><td>组播</td></tr><tr><td>使用UDP 520端口发送报文</td><td>是</td><td>是</td></tr><tr><td>更新中携带子网掩码，支持VLSM</td><td>否</td><td>是</td></tr><tr><td>支持认证</td><td>否</td><td>是</td></tr></tbody></table><h2 id="配置RIP"><a href="#配置RIP" class="headerlink" title="配置RIP"></a>配置RIP</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>创建RIP进程<br><code>Router(config)# router rip</code></li><li>定义关联网络<br><code>Router(config-router)# network network-number</code><br>关联网络有两层意思：</li></ul><ol><li>RIP 只对外通告关联网络的路由信息</li><li>RIP 只向关联网络所属接口通告路由信息<blockquote><p>network 需要有类网络号（无子网掩码），如果使用子网号或IP地址，路由器会自动修改为ABC三类网络号。</p></blockquote></li></ol><ul><li>定义RIP版本<br><code>Router(config-router)# version {1|2}</code><br>默认1</li><li>关闭RIPv2自动汇总<br><code>Router(config-router)# no auto-summary</code><br>路由自动汇总：当子网路由穿越有类网络边界时，将自动汇总成有类网络路由。<br>RIPv2 缺省情况下将进行路由自动汇聚，RIPv1 不支持该功能。</li><li>调整RIP时钟<br><code>Router(config-router)# timers basci update invalid flush</code><br>默认更新30s，无效时间180s，刷新120s。<br>调整可能会加快路由协议的收敛时间以及故障恢复时间。<br>注意：同一网络上的设备，RIP时钟值一定要一致。</li><li><p>关闭水平分割<br><code>Router(config-if)# no ip split-horizon</code></p></li><li><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RouterA(config)<span class="comment">#router rip</span></span><br><span class="line">RouterA(config-router)<span class="comment">#network 1.0.0.0</span></span><br><span class="line">RouterA(config-router)<span class="comment">#network 2.0.0.0</span></span><br><span class="line">RouterA(config-router)<span class="comment">#end</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置单播更新和被动接口"><a href="#配置单播更新和被动接口" class="headerlink" title="配置单播更新和被动接口"></a>配置单播更新和被动接口</h3><ul><li>RIP被动接口：RIP路由器的某个端口仅仅学习RIP路由，并不进行RIP路由通告<br>(非RIP请求仍会相应)<br><code>Router(config-router)#passive-interface {default | interface-type interface-num}</code></li><li>RIP报文单播更新 ：RIP路由信息需要通过非广播网络传输，或需要限制一个接口通告广播式的路由更新报文<br><code>Router(config-router)# neighbor ip-address</code></li></ul><p>示例：实现A发出的更新报文只能被B接受，而不被C接受。<br><img src="https://image.evilpwn.me/blog/RIP-09.png-sign" alt="单播更新和被动接口"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RouterA(config)<span class="comment">#router rip</span></span><br><span class="line">RouterA(config-router)<span class="comment">#passive-interface fastEthernet 0/0</span></span><br><span class="line">RouterA(config-router)<span class="comment">#neighbor 4.0.0.2</span></span><br><span class="line">RouterA(config-router)<span class="comment">#end</span></span><br></pre></td></tr></table></figure></p><h2 id="debug-命令进行排错"><a href="#debug-命令进行排错" class="headerlink" title="debug 命令进行排错"></a>debug 命令进行排错</h2><ul><li>debug命令让路由器执行以下：</li></ul><ol><li>监视内部过程（例如RIP发送和接收的更新）</li><li>当某些进程发生一些事件后，产生日志信息</li><li>持续产生日志信息，直到用no debug命令关闭</li></ol><blockquote><p>Debug命令可用于观察RIP的内部工作过程，以便发现存在的问题。<br>调试排错结束后，应当关闭debug。<br>no debug ip rip<br>no debug all </p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><ol><li>更新计时器、无效计时器和刷新计时器<br>RIP协议中，路由接口将周期性地发送全部路由更新，<strong>更新计时器（Update Timer）</strong>为30s；成功建立一条RIP路由条目后，加上一个180s（6倍的更新时间）的<strong>无效计时器（InvalidTimer）</strong>，180s后未收到针对该路由的更新，则把该路由的度量值标记为16跳，表示不可达，但并不从路由表中删除。标记后，RIP路由立即启动<strong>刷新计时器（Flush Timer，也称为清除计时器）</strong>，120s，超时后，删除。</li><li>计数到无穷大的情况<br>存在路由环路（逻辑环路或者物理环路）,导致路由器互相之间不断发送针对同一条失效路由的错误更新，每发一次，top+1，直到无穷大。</li><li>防止路由环路的技术<ul><li>路由毒化：当一条路径信息变为无效之后，路由器并不立即将它从路由表中删除，而是用 16，即不可达的度量值将它广播出去。 </li><li>水平分割：路由器将记住每一条路由信息的来源，并且不在收到这条信息的端口上再次发送它。这是保证不产生路由循环的最基本措施。 </li><li>毒性逆转：当路由器收到一条毒化路由后，立即将这条毒化路由以触发更新的方式通告出去，并不再遵循水平分割的原则，也就是同样会通告给初始发送这条路由的路由器。 </li><li>触发更新：当路由表发生变化时，更新报文立即广播给相邻的所有路由器，而不是等待30 秒的更新周期。这样，网络拓扑的变化会最快地在网络上传播开，减少了路由循环产生的可能性。 </li><li>抑制计时：一条路由信息无效之后，一段时间内这条路由都处于抑制状态，即在一定时间内不再接收关于同一目的地址的路由更新。 如果， 路由器从一个网段上得知一条路径失效，然后，立即在另一个网段上得知这个路由有效。这个有效的信息往往是不正确的，抑制计时避免了这个问题，而且，当一条链路频繁起停时，抑制计时减少了路由的浮动，增加了网络的稳定性。</li></ul></li><li>RIPv1 和 和 V2  的区别<br>上表总结的有</li><li>network命令作用<br>定义关联网络，关联网络有两层意思：<br>RIP 只对外通告关联网络的路由信息；<br>RIP 只向关联网络所属接口通告路由信息。<br>即：network 命令告诉路由器哪个接口开始使用 RIP，然后从这个接口发送路由更新，通告这个接口直连的网络，并从这个接口监听从其他路由器发来的 RIP 更新。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 路由与交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由 </tag>
            
            <tag> RIP协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>路由技术</title>
      <link href="/2017/Routing-technology/"/>
      <url>/2017/Routing-technology/</url>
      
        <content type="html"><![CDATA[<h2 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h2><p>指导IP报文发送的路径信息。</p><h3 id="选路"><a href="#选路" class="headerlink" title="选路"></a>选路</h3><p>路由器中保存着一张路由表，表中每条路由项都致命数据到某个子网应通过路由器的哪个物理接口发送出去。</p><h3 id="路由选择表中保存的信息"><a href="#路由选择表中保存的信息" class="headerlink" title="路由选择表中保存的信息"></a>路由选择表中保存的信息</h3><p>路由选择表中的每一个表项至少要包括目标地址和下一跳路由器的地址， 或表明目标地址是直接相连的。</p><a id="more"></a><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>网络互联：主要用于互联局域网和广域网</li><li>数据处理：分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等。</li><li>网络管理：配置管理、性能管理、容错管理、流量控制等。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>Console：控制台口，初始化配置</li><li>AUX：异步接口，主要用于远程配置，也可用于拨号连接，还可通过收发器与MODEM进行连接，支持硬件流控制。</li><li><p>RJ-45接口：最常见的双绞线以太网接口。</p><blockquote><p>RJ-45，根据接口的通信速率不同，TJ-45接口又可分为10Base-T（RJ-45）接口、100Base-TX（RJ-45）、100Base-T3类等。</p></blockquote></li><li><p>SIC模块：<br>4接口100Base-T快速以太网交换接口卡（SIC-4ESW）。<br>1接口通道化E1接口卡（SIC-1CE1）。<br>1接口非通道化E1接口卡（SIC-1E1-F）。<br>1接口高速同步串口接口卡（SIC-1HS）。<br>1接口高速异步串口接口卡（SIC-1A）。<br>8接口高速异步串口接口卡（SIC-8A）。<br>1接口ISDN基本速率U接口卡（SIC-1B-U）。<br>1接口ISDN基本速率S/T接口卡（SIC-1B-S/T）。<br>2接口FXS语音接口卡（SIC-2FXS）。<br>2接口FXO语音接口卡（SIC-2FXO）。</p></li></ul><h3 id="路由的访问方式"><a href="#路由的访问方式" class="headerlink" title="路由的访问方式"></a>路由的访问方式</h3><ul><li>带外管理（Console口）</li><li>Telnet</li><li>Web</li><li>SNMP管理工作站</li></ul><h2 id="静态路由、默认路由、浮动路由"><a href="#静态路由、默认路由、浮动路由" class="headerlink" title="静态路由、默认路由、浮动路由"></a>静态路由、默认路由、浮动路由</h2><ul><li><p>静态路由<br>网络管理员手工配置的路由信息</p></li><li><p>默认静态路由<br>路由表中未直接列出目标网络的路由选择项，用于在不明确的情况下指示数据帧下一跳的方向。</p></li><li><p>浮动静态路由<br>浮动静态路由是到达目标地址的备用路由，它的管理距离被设得更高，这样只有当别的优先级高的路由均不可用时，它才被启用。</p></li></ul><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><ul><li>路由协议<br>通过共享路由选择信息的机制来支持被动路由协议。</li><li>路由协议作用<br>维护路由信息，建立路由表，决定最佳路径。</li><li>路由选择协议<br>通俗的说，路由选择协议就是路由器之间所讲的一种语言，用来共享网络目标地址的信息。</li></ul><blockquote><p>所有的路由协议都围绕着一个算法构建的，因此对于所有路由选择协议来说，共有的几个问题是<strong>路径决策</strong>、<strong>度量</strong>、<strong>收敛</strong>和<strong>负载均衡</strong></p></blockquote><ul><li><p>路径决策<br>根据路由表中的信息，选择一条最佳的路径，将数据转发出去。</p></li><li><p>度量<br>路由的度量值，也叫路由代价或路由距离，用来决定到达一个目的的最佳路径，最佳路径所使用的度量值类型定义。</p></li><li><p>收敛<br>使所有路由选择表都达到一致状态的过程。</p><ul><li><p>收敛时间<br>一级路由器所花费用来完成路由信息交换的时间。</p></li><li><p>一个网络的收敛速度越快，说明路由选择协议越好。</p></li></ul></li></ul><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>通过路由信息的交换生成并维护转发引擎所需的路由表。当网络拓扑结构改变时动态路由协议可以自动更新路由表，并负责决定数据传输最佳路径。</p><ul><li>动态路由协议按运行的区域范围划分：<ul><li>内部网关协议（Interior Gateway Protocol，IGP）：同一自制系统内部交换路由信息。</li><li>外部网关协议（Exterior Gateway Protocol，EGP）：不同自制系统间交换路由信息。</li></ul></li><li>IGP内根据路由选择协议算法不同划分如下：<ul><li>距离矢量（DiStance Vector）</li><li>链路状态（Link-state）</li><li>混合算法（Hybird）</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[动态路由协议] --- B[IGP]</span><br><span class="line">A --- C[EGP]</span><br><span class="line">B --- D[距离矢量路由选择协议]</span><br><span class="line">B --- E[链路状态路由选择协议]</span><br><span class="line">B --- F[混合算法]</span><br><span class="line">D --- G[RIP]</span><br><span class="line">D --- H[IGRP,cisco私有协议]</span><br><span class="line">E --- I[OSPF]</span><br><span class="line">E --- J[IS-IS]</span><br><span class="line">F --- K[EIGRP,cisco私有协议]</span><br></pre></td></tr></table></figure><p><img src="https://image.evilpwn.me/blog/dtly.png-sign" alt="动态路由协议划分"></p><p><a href="../RIP">RIP路由协议</a><br><a href="http://baidu.com" target="_blank" rel="noopener">OSPF路由协议</a></p><h2 id="动态与静态的区别"><a href="#动态与静态的区别" class="headerlink" title="动态与静态的区别"></a>动态与静态的区别</h2><p>静态路由：无开销，配置简单，需要人工维护，适合简单拓扑结构的网络；<br>动态路由协议：开销大，配置复杂，无需人工维护，适合复杂拓扑结构的网络</p><h2 id="有类路由协议与无类路由协议"><a href="#有类路由协议与无类路由协议" class="headerlink" title="有类路由协议与无类路由协议"></a>有类路由协议与无类路由协议</h2><h3 id="有类路由协议"><a href="#有类路由协议" class="headerlink" title="有类路由协议"></a>有类路由协议</h3><p>有类的路由不会识别子网的信息,如宣告10.0.1.0/24 172.16.1.0/22 192.168.1.64/28 路由表中只会识别A类10.0.0.0/8,B类172.16.0.0/16 C类192.168.1.0/24。</p><ul><li>使用协议：RIPV1 IGRP（cisco私有协议）<br>有类的路由协议只会传送网络前缀（网络地址），但是不会包含子网掩码。当它传送更新时，它首先检查直接连接的网络是否和发送更新的网络属于同一个大一点的子网，如果是的，那么它会继续检查它们的子网掩码是否相等，如果不等，那么更新信息会被丢弃而不会被广播。</li></ul><h3 id="无类路由协议"><a href="#无类路由协议" class="headerlink" title="无类路由协议"></a>无类路由协议</h3><p>无类的路由协议不会根据A B C类来识别,根据子网掩码的长度来区分网段,所以说无类的路由协议都可以不支持路由自动汇总。</p><ul><li>使用协议：RIPV2、EIGRP（cisco私有协议）、OSPF、IS-IS等。<br>路由控制包里面除了IP地址，还必须包含一个掩码与其匹配。掩码的作用是划分出网络ID和主机ID，这样的划分更灵活多变。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>是否支持变长子网掩码（VLSM）</li><li>是否支持不连续的子网。</li><li>在路由器宣告时是否带有子网掩码。</li></ul><p>有类：不支持；无类：支持。</p>]]></content>
      
      
      <categories>
          
          <category> 路由与交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由 </tag>
            
            <tag> 静态路由 </tag>
            
            <tag> 动态路由 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类</title>
      <link href="/2017/class/"/>
      <url>/2017/class/</url>
      
        <content type="html"><![CDATA[<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol><li>类是对象共性的抽象</li><li>是对象的模板</li><li>是客观对象在人脑中的主观反应，人对对象的一种认知</li></ol><p>类是主观的认知，对象是客观存在的</p><a id="more"></a><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性：实例变量（定义的位置：类中）<br>特点：</p><ol><li>有默认值：数值：各种零 布尔类型：false 对象类型：null</li><li>作用范围：至少是全类内部（位置灵活）</li><li>可以和局部变量发生命名冲突，冲突的时候局部变量优先</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>方法的声明：代表对象能做什么</li><li>方法的实现：代表怎么做<br>方法的声明构成：<br>修饰符 返回值类型 方法名 （参数列表） 抛出的异常</li><li>以上5个部分顺序严格，不能交换</li><li>一个方法可以没有修饰符</li><li>一个方法的修饰符可以又多个，修饰符没有顺序要求</li></ol><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载overload 方法覆盖：override<br>允许定义多个同名的方法，参数表不同（是面向对象中特有的性质）</p><ul><li>参数列表不同</li></ul><ol><li>方法参数的个数</li><li>方法参数的类型不同</li><li>方法参数的顺序不同<br> 形参类型相同，名称不同不算重载<br> 形参类型相同，顺序不同不算重载<br>调用方法的时候通过参数列表不同来区分</li></ol><p>挑选的过程：编译器在编译的时候根据参数列表，选择一个合适的方法<br>方法重载又称之为：编译时多态<br>原则：就近向上匹配（避免混淆）</p><ul><li>方法重载的作用<br>一个对象的同类方法，由于参数列表的不同，所造成的差异，对用户屏蔽<br>System.out.println(字符串，数字，字符，布尔类型);</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li>没有返回值类型</li><li>方法名必须和类名相同</li><li>不允许手工调用，在对象构造的过程中自动调用一次<br>如果一个类没有构造方法，系统会默认添加一个无参的构造方法<br>如果一个类有构造方法，系统不会添加默认构造方法（手动补充一个无参的构造方法）</li></ol><p>构造方法中的参数称之为：构造参数</p><ul><li>对象的创建过程</li></ul><ol><li>分配空间，将所有的实例变量赋予默认值</li><li>初始化属性：将所有的实例变量初始化（第二次赋值）</li><li>调用构造方法：实例变量将被第三次赋值</li></ol><p>构造方法常用来赋值</p><h3 id="如何创建一个对象"><a href="#如何创建一个对象" class="headerlink" title="如何创建一个对象"></a>如何创建一个对象</h3><p>关键字：new<br>构造对象：<br>Student s1=new Student();<br>Student s2=new Student(构造参数);<br>查看属性：<br>变量名.属性名<br>查看方法：<br>变量名.方法名（参数）</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>数据分类：简单类型，对象类型<br>变量分类：简单变量，对象变量（引用）<br>变量按照类型划分：<br>简单变量：存的是值<br>对象变量：存对象的地址</p><p>java中参数的传递规则：<br>简单类型传数据（值）<br>对象类型传递的是地址，引用，多个变量指向是同一个对象</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 表示的是一个引用，指向当前对象</p><ol><li>当实例变量和局部变量命名冲突的时候，用this来区分实例变量和局部变量</li><li>常用语构造方法中<ol><li>参与构造方法中的赋值（在有参构造方法中给属性赋值）</li><li>调用本类中的其他构造方法（this（构造参数））<br>构造方法中，只能调用一次其他构造方法，并且必须是构造方法中的第一句</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象</title>
      <link href="/2017/Object-Oriented/"/>
      <url>/2017/Object-Oriented/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术[1]  发展到一定阶段后的产物。</p><p>——百度百科</p></blockquote><a id="more"></a><ul><li>核心：实现了面向对象的核心思想</li><li>编程思想：<br>需求==》建立思路==》目标代码</li></ul><h2 id="面向过程的编程思想"><a href="#面向过程的编程思想" class="headerlink" title="面向过程的编程思想"></a>面向过程的编程思想</h2><p>哥德巴赫猜想：</p><ol><li>让用户输入一个数<br> 1).是不是大于6<br> 2).是不是偶数<br> 3).是不是数</li><li>对输入的数拆分</li><li>分别验证是不是质数</li></ol><p>自顶向下逐步求精<br>将一个程序打散成n多个小程序，再将程序进一步细化，直到整理出最终代码为止</p><ul><li>独立过程<br>哥德巴赫猜想：<br>n=a+b;<br>判断a和b的过程，是独立的，相互之间互不影响</li></ul><p>函数是对抽取出来的独立的过程的封装</p><p>淘宝：<br>1.登陆浏览器2.登陆3.验证用户合法性4.浏览商品5.添加购物车6.下订单7.填写收货地<br>址。。。。。。<br>不适用于多过程的复杂需求</p><p>第一个面向对象的编程语言：SmallTalk<br>C语言==》C++加入了面向对象的思想<br>面向对象的革命：Java（纯面向对象的语言）</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>万物皆对象：一切客观存在的事物<br>唯物主义哲学思想<br>例如：显示屏，桌椅板凳，错误（客观存在）</p><ul><li><p>对象<br>  1.有什么：属性<br>  2.能干什么：方法</p><p>  例如：<br>  电脑：<br>  有什么：显示器，鼠标，键盘，主机。。。<br>  能做什么：上网，打游戏，学习。。。<br>除了属性和方法之外没有我们需要关注的东西。</p></li><li><p>对象的属性</p></li></ul><p>对象的属性可能又是一个对象</p><ul><li>对象的方法</li></ul><p>对象的方法的使用者，一定也是一个对象，（这个对象可能是别的对象，也可能是自己）</p><ul><li>客观世界是由对象组成</li></ul><ol><li>小对象组成大对象（小对象作为大对象的属性而存在）</li><li>对象的方法彼此间相互调用</li></ol><ul><li>如何建立解题思路</li></ul><p>例如：校外实训：郑州==》北京</p><ol><li>找对象<br> 有交通运输的方法（小黄车，摩拜单车，摩的，汽车，高铁，飞机）</li><li>找方法<br> 调用交通工具的运输方法</li></ol><ul><li>解决客观问题的方法</li></ul><ol><li>把解决问题所需要的对象准备好</li><li>考虑对象之间如何配合，完成需求</li></ol><ul><li>小结</li></ul><ol><li>面向过程的编程思想：自顶向下，逐步求精（适合于解决简单问题）</li><li>面向对象的编程思想：找到合适的对象是第一位，需要什么方法是第二位</li></ol><h2 id="面向对象在计算机领域中的使用"><a href="#面向对象在计算机领域中的使用" class="headerlink" title="面向对象在计算机领域中的使用"></a>面向对象在计算机领域中的使用</h2><p>计算机需求，来源于客观世界<br>把客观世界的需求，用计算机来实现</p><p>例如：<br>京东：<br>需求：在人类社会中，有人买东西，有人卖东西<br>解决：利用了计算机网络，解决人和人之间的交易行为（没有计算，这样的需求依旧存在）</p><p>QQ：<br>需求：人与人之间有交流的需求<br>解决：利用计算机解决<br>用计算机解决问题：用面向对象的思想解决，和现实世界高度统一（生活中怎么解决这个问题，用计算就怎么解<br>决）</p><ul><li>计算机中的对象</li></ul><p>在JVM中一块连续的存储空间（数据，代表生活中的对象）<br>例如：<br>学生管理系统：</p><ol><li>人工：建立档案册，记录学生信息（管理的对象：学生，有血有肉的人）</li><li>计算机：建立档案册，记录学生信息（管理的对象：计算机在存储空间中表示的学生，其属性是需要的属性）</li></ol><ul><li>小结<br>面向对象的思想为解决生活中的问题提供了思路，应对复杂的需求<br>一个系统，越接近生活，越是合理（生活是最合理的）</li></ul><ol><li>各司其职，对象应该保持简单性</li><li>弱耦合性，对象和对象之间的联系，尽量弱化</li><li>可重用性，创建对象下一次可以拿来直接用</li><li>可扩展性，在原有的功能基础之上曾加新功能</li></ol><p>oop面向对象的编程思想Object Oriented Programming</p><ol><li>面向对象的语法：编译通过</li><li>面向对象的思想：要按照以上4点纲领</li></ol><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>封装，继承，多态（三大基石）</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>定义<br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p><p>  封装把对象的所有组成部分组合在一起，定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。</p><p>  适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。</p></li><li><p>特点<br>对象会有明确的边界，保护对象中的属性‐‐‐‐数据隐藏<br>封装的粒度（不宜过大，也不宜过小）<br>public 公开的，不受边界的控制<br>private 私有的，只能在本类中使用，无法突破边界<br>（提供对应的get/set方法）<br>好处：提供约束，设置只读性<br>方法私有：private 返回值类型 方法名（参数列表）<br>方法公开：声明公开，实现隐藏（在声明不变的情况下，如果实现改变，对架构的影响最小）</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>父类‐‐子类（有继承关系） 父类把子类的共性抽取出来<br>关键字：extends<br>class 子类 extends 父类{}</p><ul><li>特点</li></ul><ol><li>子类可以继承父类中的方法和属性</li><li>可扩展性（子类，重用父类中的方法）</li></ol><ul><li><p>本质<br>Animal‐‐Dog<br>创建过程：先创建父类对象，后创建子类对象，父类对象作为子类对象的的一部分<br>访问修饰符：从严到宽<br>private 私有的 本类内部（不能被继承）<br>default 默认的 本类内部+同包可以访问+同包子类（可能被继承）<br>protected 受保护的 同包+不同包子类<br>public 公开的 全能访问</p><p>  <strong>构造方法不能被继承</strong></p></li></ul><h4 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h4><p>子类用特殊的方法实现，替换了父类中的一般方法实现<br>语法要求：</p><ol><li>返回类型，方法名，参数列表和父类相同（参数列表变化，就是重载）</li><li>访问修饰符：相同，或者更宽</li><li>不能抛出比父类更多的异常</li></ol><h4 id="对象构造的过程"><a href="#对象构造的过程" class="headerlink" title="对象构造的过程"></a>对象构造的过程</h4><ol><li>分配空间：本类和父类一并分配空间，所有的属性被赋予默认值</li><li>递归的构造父类对象（初始化分类的属性，调用父类的构造方法）</li><li>初始化属性</li><li>调用构造方法</li></ol><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ol><li>在构造方法中指定调用父类的哪一个构造方法</li><li>必须在构造方法的第一个语句</li><li>如果一个构造方法的第一句，不指定this也不指定super 系统默认添加super（）；</li><li>表示父类对象，区分父类被遮盖的属性，或者调用父类被覆盖的方法</li></ol><ul><li>小结<br>系统默认添加：<br>构造方法第一行：super（）；<br>没有写构造方法：公开的无参构造<br>每个程序：import java.lang.*;<br>super常常用来把构造参数传递给父类</li></ul><h4 id="JAVA继承的分类"><a href="#JAVA继承的分类" class="headerlink" title="JAVA继承的分类"></a>JAVA继承的分类</h4><p>继承分为单继承和多重继承。单继承是指一个子类最多只能有一个父类。多继承是一个子类可以有二个以上的父类。由于多继承会带来二义性，在实际应用中应尽量使用单继承。Java语言中的类只支持单继承，而接口支持多继承。Java中多继承的功能是通过接口（interface）来间接实现的。</p><p>一个类最多只能有一个直接父类，这点和C++不同！</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>编译时多态（方法重载） 运行时多态（引用多态）</p><ol><li>子类对象可以看成是父类对象（继承关系合理）</li><li>父类引用指向子类对象</li></ol><h4 id="多态规则："><a href="#多态规则：" class="headerlink" title="多态规则："></a>多态规则：</h4><ol><li>对象类型不变</li><li>只能调用引用类型中所声明的方法</li><li>发生了方法覆盖，调用覆盖后的方法</li></ol><h4 id="引用之间的传递"><a href="#引用之间的传递" class="headerlink" title="引用之间的传递"></a>引用之间的传递</h4><ol><li>子类对象的引用可以直接赋值给父类引用</li><li>父类引用给子类引用赋值，需要强制类型转换</li><li>在强制类型转换之前要用instanceof 判断，避免类型转换异常<br>引用 instanceof 类名 （表示：引用是否和类名相互兼容）</li></ol><h4 id="多态作用"><a href="#多态作用" class="headerlink" title="多态作用"></a>多态作用</h4><p>将多个对象统一看做是同一个父类对象，屏蔽子类之间的差异，增加程序的灵活性和通用性。</p><h4 id="多态的方法"><a href="#多态的方法" class="headerlink" title="多态的方法"></a>多态的方法</h4><ol><li>方法声明中的形参可以用父类引用来表示，实参用子类对象来传输</li><li>用父类作为返回值类型</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle存储管理2</title>
      <link href="/2017/Oracle-store-management-2/"/>
      <url>/2017/Oracle-store-management-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle存储管理1"><a href="#Oracle存储管理1" class="headerlink" title="Oracle存储管理1"></a>Oracle存储管理1</h2><p><a href="../Oracle-store-management-1">表空间管理</a></p><h2 id="回滚段管理"><a href="#回滚段管理" class="headerlink" title="回滚段管理"></a>回滚段管理</h2><p>回滚段来实现未提交数据或因系统故障导致实例崩溃时进行回滚操作，每一个表空间需要创建回滚段，各个表空间对回滚段实现各自的管理</p><a id="more"></a><h3 id="查看回滚段信息"><a href="#查看回滚段信息" class="headerlink" title="查看回滚段信息"></a>查看回滚段信息</h3><p>使用视图DBA_SEGMENTS可以查看当前数据库中所有段的信息。回滚段的类型（SEGMENT_TYPE）值为ROLLBACK。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COL 回滚段名 FOR A20</span><br><span class="line"><span class="keyword">SELECT</span> SEGMENT_NAME 回滚段名, TABLESPACE_NAME 所在表空间, <span class="keyword">BYTES</span> 大小</span><br><span class="line"><span class="keyword">FROM</span> DBA_SEGMENTS <span class="keyword">WHERE</span> SEGMENT_TYPE=<span class="string">'ROLLBACK'</span>;</span><br></pre></td></tr></table></figure></p><p><img src="https://image.evilpwn.me/blog/oracle-bkj05.png-sign" alt="回滚段信息"></p><p>查看回滚段的当前工作情况 ：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COL NAME FOR A12</span><br><span class="line"><span class="keyword">SELECT</span> s.USN, n.NAME, s.EXTENTS, s.RSSIZE, s.STATUS </span><br><span class="line"><span class="keyword">FROM</span> V$ROLLSTAT s, V$ROLLNAME n</span><br><span class="line"><span class="keyword">WHERE</span> s.USN=n.USN;</span><br></pre></td></tr></table></figure></p><p><img src="https://image.evilpwn.me/blog/oracle-bkj06.png-sign" alt="回滚段当前工作情况"></p><h3 id="查看和设置回滚段的管理模式"><a href="#查看和设置回滚段的管理模式" class="headerlink" title="查看和设置回滚段的管理模式"></a>查看和设置回滚段的管理模式</h3><ul><li>Oracle数据库可以自动管理回滚段，也可以由用户来手动管理。</li><li>使用初始化参数UNDO_MANAGEMENT可以设置管理回滚段的方式。</li></ul><p>查看UNDO_MANAGEMENT参数的值：<br><code>SHOW PARAMETER UNDO_MANAGEMENT</code><br><img src="https://image.evilpwn.me/blog/oracle-bkj07.png-sign" alt="UNDO_MANAGEMENT参数的值"></p><p>将回滚段管理方式设置为手动管理：<br><code>ALTER SYSTEM SET UNDO_MANAGEMENT=MANUAL SCOPE=SPFILE;</code><br>SCOPE=SPFILE表示对初始化参数的修改应用于SPFILE，需要重新启动数据库实例才能生效。</p><h3 id="创建回滚段"><a href="#创建回滚段" class="headerlink" title="创建回滚段"></a>创建回滚段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">PUBLIC</span>] <span class="keyword">ROLLBACK</span> <span class="keyword">SEGMENT</span> 回滚段名称 </span><br><span class="line"><span class="keyword">TABLESPACE</span>所属表空间名称</span><br><span class="line"><span class="keyword">STORAGE</span> 存储选项</span><br></pre></td></tr></table></figure><p>示例：为表空间OrclTBS01创建回滚段OrclRs01<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLLBACK</span> <span class="keyword">SEGMENT</span> OrclRs01</span><br><span class="line"><span class="keyword">TABLESPACE</span> UndoTBS1</span><br><span class="line"><span class="keyword">STORAGE</span> (<span class="keyword">INITIAL</span> <span class="number">5</span>M</span><br><span class="line">          <span class="keyword">NEXT</span> <span class="number">2</span>M</span><br><span class="line">          <span class="keyword">MAXEXTENTS</span> <span class="keyword">UNLIMITED</span>);</span><br></pre></td></tr></table></figure></p><h3 id="修改回滚段的属性"><a href="#修改回滚段的属性" class="headerlink" title="修改回滚段的属性"></a>修改回滚段的属性</h3><ol><li>修改回滚段的在线状态<br><code>ALTER ROLLBACK SEGMENT 回滚段名称 回滚段状态</code><br>状态：ONLINE（联机）和OFFLINE（脱机），新建回滚段的状态为ONLINE。</li><li>手动收缩回滚段<br>如果在创建回滚段时指定的初始大小（INITIAL参数）过大，可以手动收缩回滚段的大小。<br><code>ALTER ROLLBACK SEGMENT 回滚段名称 SHRINK TO 回滚段的初始大小</code><br>示例：回滚段OrclRs01的大小收缩为1MB<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLLBACK</span> <span class="keyword">SEGMENT</span> OrclRs01 <span class="keyword">SHRINK</span> <span class="keyword">TO</span> <span class="number">1</span>M;</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除回滚段"><a href="#删除回滚段" class="headerlink" title="删除回滚段"></a>删除回滚段</h3><blockquote><p>需要先将回滚段设置为<strong>脱机状态</strong>。<br>ALTER ROLLBACK SEGMENT 回滚段名 OFFLINE;</p></blockquote><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">ROLLBACK</span> <span class="keyword">SEGMENT</span> OrclRs01 <span class="keyword">OFFLINE</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">ROLLBACK</span> <span class="keyword">SEGMENT</span> OrclRs01;</span><br></pre></td></tr></table></figure></p><h2 id="数据库文件管理"><a href="#数据库文件管理" class="headerlink" title="数据库文件管理"></a>数据库文件管理</h2><p>（待整理）</p>]]></content>
      
      
      <categories>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回滚段 </tag>
            
            <tag> 数据库文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle存储管理1</title>
      <link href="/2017/Oracle-store-management-1/"/>
      <url>/2017/Oracle-store-management-1/</url>
      
        <content type="html"><![CDATA[<h2 id="表空间介绍"><a href="#表空间介绍" class="headerlink" title="表空间介绍"></a>表空间介绍</h2><p>数据库可划分为若干的逻辑存储单元，这些单元被称为表空间。</p><h3 id="表空间的分类"><a href="#表空间的分类" class="headerlink" title="表空间的分类"></a>表空间的分类</h3><p><img src="https://image.evilpwn.me/blog/oracle-bkj.png-sign" alt="表空间分类"></p><h3 id="数据库、表空间和数据文件的关系"><a href="#数据库、表空间和数据文件的关系" class="headerlink" title="数据库、表空间和数据文件的关系"></a>数据库、表空间和数据文件的关系</h3><p><img src="https://image.evilpwn.me/blog/oracle-bkj02.png-sign" alt="数据库、表空间和数据文件的关系"></p><ul><li>每个表空间由一个或多个数据文件组成。数据文件用于在物理上存储表空间中所有逻辑结构的数据。</li><li>表空间中数据文件的大小之和就是表空间的存储容量（图中系统表空间存储容量为2MB，用户表空间的存储容量为4MB）。</li><li>数据库中表空间的存储容量之和就是数据库的存储容量。</li></ul><a id="more"></a><h3 id="预配置的数据库中的表空间"><a href="#预配置的数据库中的表空间" class="headerlink" title="预配置的数据库中的表空间"></a>预配置的数据库中的表空间</h3><ul><li>SYSTEM：包含数据目录表和其它管理数据 </li><li>SYSAUX：是 SYSTEM 表空间的辅助表空间 </li><li>TEMP：包含仅在会话期间存在的临时数据 </li><li>UNDOTBS1：包含还原段 </li><li>USERS：非系统用户创建的所有对象的默认表空间 </li><li>EXAMPLE：包含示例方案 <h3 id="统计表空间的使用情况"><a href="#统计表空间的使用情况" class="headerlink" title="统计表空间的使用情况"></a>统计表空间的使用情况</h3></li><li>DBA_DATA_FILES，用于查询所有数据文件的信息。</li><li>DBA_FREE_SPACE，用于查询表空间的空闲区间信息。</li><li>DBA_TABLESPACES，用于查询所有表空间的信息。</li></ul><p>1.统计所有表空间的总空间大小<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tablespace_name <span class="keyword">AS</span> 表空间名,<span class="keyword">SUM</span>(<span class="keyword">bytes</span>)</span><br><span class="line"><span class="keyword">FROM</span> DBA_DATA_FILES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> tablespace_name;</span><br></pre></td></tr></table></figure></p><p><img src="https://image.evilpwn.me/blog/oracle-bkj03.png-sign" alt="统计所有表空间的总空间大小"></p><p>2.统计所有表空间的空闲空间大小<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.tablespace_name, NVL(<span class="keyword">SUM</span>(b.bytes),<span class="number">0</span>) <span class="keyword">bytes</span> </span><br><span class="line"><span class="keyword">FROM</span> DBA_DATA_FILES a, DBA_FREE_SPACE b </span><br><span class="line"><span class="keyword">WHERE</span> a.tablespace_name = b.tablespace_name (+) <span class="keyword">AND</span> a.file_id = b.file_id (+) <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.tablespace_name;</span><br></pre></td></tr></table></figure></p><p><img src="https://image.evilpwn.me/blog/oracle-bkj04.png-sign" alt="统计所有表空间的总空间大小"></p><h2 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">BIGFILE</span>|<span class="keyword">SMALLFILE</span>|<span class="keyword">UNDO</span>|<span class="keyword">TEMPORARY</span>]</span><br><span class="line"> <span class="keyword">TABLESPACE</span> &lt;表空间名&gt;</span><br><span class="line">    <span class="keyword">DATAFILE</span> |TEMPFILE‘数据文件名称和位置’ <span class="keyword">SIZE</span> &lt;大小&gt;</span><br><span class="line">    [<span class="keyword">REUSE</span>]</span><br><span class="line">    [<span class="keyword">EXTENT</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">LOCAL</span>|DICTIONARY]</span><br><span class="line">    [<span class="keyword">AUTOALLOCATE</span>|<span class="keyword">UNIFORM</span> <span class="keyword">SIZE</span> &lt;大小&gt;]</span><br><span class="line">    [<span class="keyword">SEGMENT</span> <span class="keyword">SPACE</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">AUTO</span>|<span class="keyword">MANUAL</span>]</span><br><span class="line">    [<span class="keyword">BLOCKSIZE</span> &lt;大小&gt; ]</span><br></pre></td></tr></table></figure><ul><li>参数说明<ul><li>DATAFILE子句：用于定义表空间中包含的数据文件。</li><li>MININUM EXTENT子句：用于指定表空间中包含的区间的最小值。</li><li>BLOCKSIZE子句：用于指定一个不标准的数据块的大小。</li><li>logging子句：指定表空间上所有用户的日志属性。</li><li>FORCE LOGGING：指定表空间进入强制日志模式，此时系统将记录表空间上对象的所有变化（不包含临时段的变化）。</li><li>DEFAULT 存储子句：用于指定缺省的存储信息。</li><li>online|offline参数：指定表空间的在线状态。online指定表空间在创建后立即生效；offline指定表空间在创建后无效。</li><li>PERMANENT|TEMPORARY参数指定表空间的类型，是永久表空间还是临时表空间。永久表空间中保存永久对象，临时表空间中保存会话生命周期中存在的临时对象。</li><li>区间管理子句：指定表空间如何管理区间。使用local选项指定本地管理表空间，使用autoallocate选项表示由表空间自动分配区间，用户不能指定区间的大小。</li><li>段管理子句指定表空间如何管理段，通常使用SEGMENT SPACE MANAGEMENT AUTO子句指定自动管理段。</li><li>REUSE<ul><li>如果file 已经存在，并且在创建时指定了file size，那么就重用原文件，并应用新的size，如果没有指定file size，则保留原有的大小。</li><li>如果file 不存在，oracle 将忽略该参数。</li><li>如果Oracle使用了已经存在的file，那么之前file里的数据将全部丢失。  </li></ul></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="本地管理表空间"><a href="#本地管理表空间" class="headerlink" title="本地管理表空间"></a>本地管理表空间</h4><p>【例1】在CREATE TABLESPACE语句中使用EXTENT MANAGEMENT LOCAL子句，可以创建一个本地管理表空间<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> OrclTBS01</span><br><span class="line">    <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf'</span> <span class="keyword">SIZE</span> <span class="number">50</span>M</span><br><span class="line">    <span class="keyword">EXTENT</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">LOCAL</span> </span><br><span class="line">   <span class="keyword">AUTOALLOCATE</span>;</span><br></pre></td></tr></table></figure></p><p>【例2】创建表空间OrclTBS02时，指定其统一区间大小为128KB<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> OrclTBS02</span><br><span class="line">    <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\OrclTBS02.dbf'</span> <span class="keyword">SIZE</span> <span class="number">30</span>M</span><br><span class="line">    <span class="keyword">EXTENT</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">LOCAL</span> </span><br><span class="line">    <span class="keyword">UNIFORM</span> <span class="keyword">SIZE</span> <span class="number">128</span>K;</span><br></pre></td></tr></table></figure></p><h4 id="大文件表空间"><a href="#大文件表空间" class="headerlink" title="大文件表空间"></a>大文件表空间</h4><p>【例】在CREATE TABLESPACE语句中使用BIGFILE关键词可以创建大文件表空间<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">BIGFILE</span> <span class="keyword">TABLESPACE</span> bigtbs</span><br><span class="line">    <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\bigtbs.dbf'</span> <span class="keyword">SIZE</span> <span class="number">1</span>G;</span><br></pre></td></tr></table></figure></p><h4 id="临时表空间"><a href="#临时表空间" class="headerlink" title="临时表空间"></a>临时表空间</h4><p>【例】创建临时表空间tmptbs<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLESPACE</span> tmptbs</span><br><span class="line">    TEMPFILE <span class="string">'C:\app\Administrator\oradata\orcl\tmptbs.dbf'</span></span><br><span class="line">    <span class="keyword">SIZE</span> <span class="number">20</span>M </span><br><span class="line">    <span class="keyword">REUSE</span></span><br><span class="line">    <span class="keyword">EXTENT</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">LOCAL</span> </span><br><span class="line">    <span class="keyword">UNIFORM</span> <span class="keyword">SIZE</span> <span class="number">16</span>K;</span><br></pre></td></tr></table></figure></p><h2 id="段和数据块管理"><a href="#段和数据块管理" class="headerlink" title="段和数据块管理"></a>段和数据块管理</h2><p>进行插入、更新和删除操作时，段中的数据块的空间会发生变化，块的状态也会发生变化。 </p><h3 id="两种方法进行块管理："><a href="#两种方法进行块管理：" class="headerlink" title="两种方法进行块管理："></a>两种方法进行块管理：</h3><ul><li>手动管理（Manual Segment Space Management）<br>Oracle使用自由列表（Free List）管理段中的块，自由列表列出允许进行插入操作的数据块</li><li>自动管理（Automatic Segment Space Management，ASSM）<br>自动管理使用位图来管理数据快。当块发生变化时，Oracle会更新位图，以反映这个块是否允许INSERT操作。位图使Oracle自动管理自由空间。</li></ul><h3 id="定义段空间管理方式"><a href="#定义段空间管理方式" class="headerlink" title="定义段空间管理方式"></a>定义段空间管理方式</h3><p><code>SEGMENT SPACE MANAGEMENT</code><br>【例】创建自动段管理方式的表空间MyTBS01：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> MyTBS01</span><br><span class="line">    <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf'</span> <span class="keyword">SIZE</span> <span class="number">30</span>M</span><br><span class="line">    <span class="keyword">EXTENT</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">LOCAL</span> <span class="keyword">AUTOALLOCATE</span></span><br><span class="line">    <span class="keyword">SEGMENT</span> <span class="keyword">SPACE</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">AUTO</span>;</span><br></pre></td></tr></table></figure></p><p>【例】创建手动段管理方式的表空间MyTBS01：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> MyTBS01</span><br><span class="line">    <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf'</span> <span class="keyword">SIZE</span> <span class="number">30</span>M</span><br><span class="line">    <span class="keyword">EXTENT</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">LOCAL</span> <span class="keyword">AUTOALLOCATE</span></span><br><span class="line">    <span class="keyword">SEGMENT</span> <span class="keyword">SPACE</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">MANUAL</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>数据块是Oracle数据库的最小存储单元，在初始化参数DB_BLOCK_SIZE中定义了标准数据块的大小。<br>在创建表空间时，如果不特殊指定，将使用DB_BLOCK_SIZE中定义的数据作为数据块的大小。</p></blockquote><p>【例】可以在CREATE TABLESPACE语句中使用BLOCKSIZE子句指定非标准数据块的大小：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> OrclTBS01</span><br><span class="line">   <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf'</span> <span class="keyword">SIZE</span> <span class="number">30</span>M</span><br><span class="line">   <span class="keyword">EXTENT</span> <span class="keyword">MANAGEMENT</span> <span class="keyword">LOCAL</span> <span class="keyword">AUTOALLOCATE</span></span><br><span class="line">   <span class="keyword">BLOCKSIZE</span> <span class="number">8</span>K;</span><br><span class="line">新创建的表空间数据块大小为8K。</span><br></pre></td></tr></table></figure></p><h2 id="撤销表空间"><a href="#撤销表空间" class="headerlink" title="撤销表空间"></a>撤销表空间</h2><p>撤销记录可以用于完成如下功能：</p><ul><li>当执行ROLLBACK命令时，完成回滚操作。</li><li>恢复数据库。</li><li>使用闪回查询分析以前时间点的数据。</li><li>使用闪回技术从逻辑破坏中恢复数据。<br>初始化参数UNDO_TABLESPACE设置默认的撤销表空间。<br>【例】使用CREATE UNDO TABLESPACE语句创建撤销表空间：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNDO</span> <span class="keyword">TABLESPACE</span> undotbs01</span><br><span class="line">     <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\undotbs01.dbf'</span> <span class="keyword">SIZE</span> <span class="number">2</span>M <span class="keyword">REUSE</span>;</span><br><span class="line">表空间已创建。</span><br></pre></td></tr></table></figure></li></ul><h2 id="设置和修改表空间属性"><a href="#设置和修改表空间属性" class="headerlink" title="设置和修改表空间属性"></a>设置和修改表空间属性</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> &lt;表空间名&gt;</span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TO</span></span><br><span class="line">|<span class="keyword">ADD</span> <span class="keyword">DATAFILE</span>|<span class="keyword">ADD</span> TEMPFILE</span><br><span class="line">|<span class="keyword">OFFLINE</span>|<span class="keyword">ONLINE</span></span><br><span class="line">|<span class="keyword">READ</span> <span class="keyword">ONLY</span>|<span class="keyword">READ</span> WRITE</span><br><span class="line">|<span class="keyword">RESIZE</span>     </span><br><span class="line">…</span><br></pre></td></tr></table></figure><h3 id="重命名表空间"><a href="#重命名表空间" class="headerlink" title="重命名表空间"></a>重命名表空间</h3><p><code>ALTER TABLESPACE …RENAME TO …</code><br>【例】将表空间OrclTBS02修改为OrclTBS03，可以使用下面的语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> OrclTBS02 <span class="keyword">RENAME</span> <span class="keyword">TO</span> OrclTBS03;</span><br><span class="line">表空间已更改。</span><br></pre></td></tr></table></figure></p><h3 id="扩展本地管理表空间"><a href="#扩展本地管理表空间" class="headerlink" title="扩展本地管理表空间"></a>扩展本地管理表空间</h3><p>【例】在ALTER TABLESPACE语句中使用ADD DATAFILE子句，可以在本地管理表空间中增加数据文件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> OrclTBS01</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">'C:\app\Administrator\oradata\orcl\OrclTBS011.dbf'</span> <span class="keyword">SIZE</span> <span class="number">10</span>M;</span><br><span class="line">表空间已更改。</span><br></pre></td></tr></table></figure></p><h3 id="更改大文件表空间大小"><a href="#更改大文件表空间大小" class="headerlink" title="更改大文件表空间大小"></a>更改大文件表空间大小</h3><p>【例】修改大文件表空间bigtbs的数据文件大小为4GB<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> bigtbs</span><br><span class="line">    <span class="keyword">RESIZE</span> <span class="number">4</span>G;</span><br><span class="line">表空间已更改。</span><br></pre></td></tr></table></figure></p><h3 id="扩展临时表空间"><a href="#扩展临时表空间" class="headerlink" title="扩展临时表空间"></a>扩展临时表空间</h3><p>【例】在临时表空间tmptbs中添加临时文件，tmptbs01.dbf，文件大小为20MB：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> tmptbs</span><br><span class="line">    <span class="keyword">ADD</span> TEMPFILE <span class="string">'C:\app\Administrator\oradata\orcl\tmptbs01.dbf'</span> <span class="keyword">SIZE</span> <span class="number">20</span>M;</span><br><span class="line">表空间已更改。</span><br></pre></td></tr></table></figure></p><h3 id="设置联机和脱机"><a href="#设置联机和脱机" class="headerlink" title="设置联机和脱机"></a>设置联机和脱机</h3><p>如下情况可将表空间设置为<strong>脱机状态</strong>：</p><ul><li>将数据库的一部分设置为不可访问，而其他部分可以访问。</li><li>执行脱机表空间备份。</li><li>在升级或维护应用程序时，将应用程序及其使用的表临时设置为不可访问。</li><li>重命名或重新分配表空间。</li></ul><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>ALTER TABLESPACE…OFFLINE</code>设置表空间为脱机状态<br><code>ALTER TABLESPACE…ONLINE</code>设置表空间为联机状态。</p><p>【例】将表空间OrclTBS01设置为脱机状态<br><figure class="highlight plain"><figcaption><span>TABLESPACE OrclTBS01 OFFLINE;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此时无法查看表空间状态，会出现错误ORA-01542:表空间’OrclTBS01’脱机，无法在其中分配空间。</span><br><span class="line">【例】将表空间OrclTBS01设置为联机状态</span><br><span class="line">```ALTER TABLESPACE OrclTBS01 ONLINE;</span><br></pre></td></tr></table></figure></p><h3 id="设置只读表空间"><a href="#设置只读表空间" class="headerlink" title="设置只读表空间"></a>设置只读表空间</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>ALTER TABLESPACE…READ ONLY</code> 只读状态。<br><code>ALTER TABLESPACE…READ WRITE</code> 可读写状态。<br>【例】将表空间OrclTBS01设置为只读表空间<br><figure class="highlight sql"><figcaption><span>ALTER TABLESPACE OrclTBS01 READ ONLY;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【例】将表空间OrclTBS01设置为可读写状态：</span><br><span class="line">```sql <span class="keyword">ALTER</span> <span class="keyword">TABLESPACE</span> OrclTBS01 <span class="keyword">READ</span> WRITE;</span><br></pre></td></tr></table></figure></p><h2 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h2><p><code>DROP TABLESPACE</code> 删除表空间。<br>【例】删除空的表空间OrclTBS01：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLESPACE</span> OrclTBS01;</span><br><span class="line">表空间已删除。</span><br><span class="line">//删除非空表空间</span><br></pre></td></tr></table></figure></p><p><code>INCLUDING CONTENTS</code>子句可以在删除表空间的同时删除其中的段，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLESPACE</span> OrclTBS01 <span class="keyword">INCLUDING</span> <span class="keyword">CONTENTS</span>;</span><br><span class="line">//该语句只会从数据字典中删除表空间信息，相关的数据文件依然在磁盘上。</span><br></pre></td></tr></table></figure></p><p><code>INCLUDING CONTENTS AND DATAFILES</code> 子句可以在删除表空间的同时，删除包含的段和数据文件：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLESPACE</span> OrclTBS03 <span class="keyword">INCLUDING</span> <span class="keyword">CONTENTS</span> <span class="keyword">AND</span> <span class="keyword">DATAFILES</span>;</span><br><span class="line">//删除操作系统级的文件</span><br></pre></td></tr></table></figure></p><h2 id="Oracle存储管理2"><a href="#Oracle存储管理2" class="headerlink" title="Oracle存储管理2"></a>Oracle存储管理2</h2><ul><li>回滚段管理 </li><li>数据库文件管理<br><a href="../Oracle-store-management-2">回滚段管理 &amp; 数据库文件管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> 表空间 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>oracle实例维护</title>
      <link href="/2017/Oracle-management/"/>
      <url>/2017/Oracle-management/</url>
      
        <content type="html"><![CDATA[<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><img src="https://image.evilpwn.me/blog/oracle-m-01.png-sign" alt="启动过程"></p><a id="more"></a><h2 id="数据库实例状态"><a href="#数据库实例状态" class="headerlink" title="数据库实例状态"></a>数据库实例状态</h2><ul><li>已启动（NOMOUNT）。只读取初始化参数文件、初始化SGA和启动后台进程，创建并启动实例，但不装载数据库。</li><li>已装载（MOUNT）。读取初始化参数文件、初始化SGA和启动后台进程，创建并启动实例。并且根据初始化参数control_files的值，找到并打开控制文件，找出数据库的物理结构信息装载数据库，但不打开数据库。</li><li>打开（OPEN）。读取初始化参数文件、初始化SGA和启动后台进程，创建并启动实例。并且根据初始化参数control_files的值，找到并打开控制文件，找出数据库的物理结构信息装载数据库，打开各种数据库文件，处于联机状态。</li><li>关闭（CLOSE）。将Oracle实例从允许用户访问数据库的状态转变为休止状态。关闭操作首先终止用户访问数据库所需的进程，然后释放计算机中供Oracle运行使用的那部分内存。</li></ul><table><br><tr><br>    <th>命令</th><br>    <th>选项</th><br>    <th>含义</th><br></tr><br><tr><br>    <th rowspan="3" align="center">startup</th><br>    <th>nomount</th><br>    <th>创建启动例程</th><br></tr><br><tr><br>    <th>mount</th><br>    <th>创建例程，并装载数据库</th><br></tr><br><tr><br>    <th>open</th><br>    <th>创建例程，装载数据库并打开</th><br></tr><br><tr><br>    <th rowspan="3" align="center">特殊</th><br>    <th>force</th><br>    <th>正常方式启动不了时，用force</th><br></tr><br><tr><br>    <th>restrict</th><br>    <th>以open状态启动数据库的受限模式</th><br></tr><br><tr><br>    <th>pfile</th><br>    <th>以pfile文件来启动</th><br></tr><br></table><h2 id="实例的关闭"><a href="#实例的关闭" class="headerlink" title="实例的关闭"></a>实例的关闭</h2><p>有以下几种方式：正常关闭；立即关闭；事务处理关闭；中止关闭。</p><table><br><tr><br>    <th>命令</th><br>    <th>选项</th><br>    <th>含义</th><br></tr><br><tr><br>    <th rowspan="4" align="center">shutdown</th><br>    <th>normal</th><br>    <th>等待所有连接都断开才关闭</th><br></tr><br><tr><br>    <th>transactional</th><br>    <th>等所有未提交事务完成关闭</th><br></tr><br><tr><br>    <th>immediate</th><br>    <th>回滚未提交事务，关闭</th><br></tr><br><tr><br>    <th>abort</th><br>    <th>不回滚未提交事务，关闭</th><br></tr><br></table>]]></content>
      
      
      <categories>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sqlplus的使用方法</title>
      <link href="/2017/Sqlplus-instructions/"/>
      <url>/2017/Sqlplus-instructions/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-PLUS作用"><a href="#SQL-PLUS作用" class="headerlink" title="SQL*PLUS作用"></a>SQL*PLUS作用</h2><ul><li>输入SQL命令，对SQL*Plus环境进行配置；</li><li>输入、编辑、存储、读取和运行SQL命令和PL/SQL块；</li><li>与终端用户进行交互式的操作；</li><li>将查询结果输出到报表表格中，设置表格格式和计算公式；</li><li>启动和关闭数据库；</li><li>连接数据库；</li><li>定义变量；</li><li>捕捉PL/SQL程序的错误；</li><li>列出表的列定义；</li><li>执行数据库管理。</li></ul><a id="more"></a><h2 id="SQL-PLUS命令"><a href="#SQL-PLUS命令" class="headerlink" title="SQL*PLUS命令"></a>SQL*PLUS命令</h2><h3 id="运行SQL-PLUS"><a href="#运行SQL-PLUS" class="headerlink" title="运行SQL*PLUS"></a>运行SQL*PLUS</h3><p>sqlplus [username]/[password][@server][AS SYSDBA|AS SYSOPER]<br>其中username用于指定数据库用户名，password用于指定用户口令，server用于指定网络服务名，AS SYSDBA表示以SYSDBA特权登录， AS SYSOPER表示以SYSOPER特权登录。当连接到本地数据库时，不需要提供网络服务名。</p><h3 id="三种命令类型"><a href="#三种命令类型" class="headerlink" title="三种命令类型"></a>三种命令类型</h3><p>可以在SQL*PLUS的命令提示符下，输入三种类型的命令：</p><ul><li>SQL命令：用于操作数据库中的信息</li><li>PL/SQL块：用于操作数据库中的信息</li><li>SQL<em>PLUS命令：用于编辑、保存、运行SQL命令、PL/SQL块、格式化查询结果、自定义SQL</em>PLUS环境等。</li></ul><h3 id="常用SQL-PLUS命令"><a href="#常用SQL-PLUS命令" class="headerlink" title="常用SQL*PLUS命令"></a>常用SQL*PLUS命令</h3><h4 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h4><p>显示SQL*Plus缓冲区中的一行或多行命令<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql&gt; list</span><br><span class="line">  1* select name,created from v$database</span><br><span class="line">sql&gt;</span><br></pre></td></tr></table></figure></p><h4 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h4><p>保存sql脚本<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql&gt; save c:/select.sql</span><br><span class="line">已创建 file C:/select.sql</span><br><span class="line"><span class="keyword">sql</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><p>编辑已输入的指令，保存后输入run或 / 执行。</p><blockquote><p>当执行SQL命令和PL/SQL块时，会将命令暂时存放到SQL缓冲区中（在输入另一个命令之前一直存放在SQL缓冲区中）。编辑器只有在SQL缓冲区中有内容时才能启动。</p></blockquote><h4 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h4><ol><li>命令行方式</li><li>SQL缓冲区方式</li><li>脚本执行方式</li></ol><ul><li><p>命令行方式</p><p>  1.运行SQL语句：输入完SQL语句之后，输入分号(;),或在新的一行输入前斜线（/），按回车键即可。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql&gt; select * from course;</span><br></pre></td></tr></table></figure><p>  2.运行PL/SQL块:输入完PL/SQL块之后，在新的一行输入前斜线（/），按回车键即可。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sql&gt; SET SERVEROUTPUT ON</span><br><span class="line">sql&gt; BEGIN</span><br><span class="line">  2  DBMS_OUTPUT.PUT_LINE('Hello Oracle!')</span><br><span class="line">  3  <span class="keyword">END</span>;</span><br><span class="line">  4  /</span><br><span class="line">Hello Oracle!</span><br><span class="line"></span><br><span class="line">PL/SQL 过程已成功完成。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SQL缓冲区方式</p><p>  SQL缓冲区保留了最后运行的命令。为了以缓冲区方式运行SQL命令或PL/SQL 块，可以使用RUN命令、/命令或菜单命令进行操作。</p><pre><code>1.RUN命令</code></pre><p>显示并运行当前存储在SQL缓冲区中的SQL语句或PL/SQL块，显示运行结果，并使SQL缓冲区中的最后一行成为当前行。</p><pre><code>2./命令</code></pre><p>只运行当前存储在SQL缓冲区中的SQL命令或PL/SQL块，显示运行结果，而不显示SQL缓冲区中的SQL命令或PL/SQL块，也不会将SQL缓冲区中的最后一行成为当前行。</p><pre><code>3.小结</code></pre><p>run显示要执行的代码，/ 不显示过程，两者都显示执行结果。</p></li></ul><ul><li><p>脚本执行方式<br>有两种运行脚本文件的方式：START命令或@命令。</p><p>  1.START命令<br>START filename[.ext][arg1,arg2,arg3…]<br>filename表示要运行的脚本文件。SQL*PLUS就使用默认的脚本文件扩展名，通常为.sql。<br>[arg1,arg2,arg3…]表示希望传递给脚本文件的参数。脚本文件中的替换参数必须使用这样的格式声明：&amp;1，&amp;2，&amp;3等。</p><blockquote><p>例:脚本文件c:\test.sql的内容如下：<br>Select ename,sal from emp where deptno=&amp;1 and sal&gt;&2;<br>使用start命令：start c:\test.sql 20 2000</p></blockquote><p>  2.@命令<br>功能与START命令类似，可以执行脚本。</p></li></ul><h4 id="连接命令"><a href="#连接命令" class="headerlink" title="连接命令"></a>连接命令</h4><p>CONNECT建立连接，DISCONNECT断开连接。<br>CONN[ECT]命令先断开前一个连接，然后建立新的连接：<br>CONN[ECT] [username]/[password]@[hoststring] [as sysdba|sysoper]<br>主机字符串省略时，表示连接本地默认数据库。</p><blockquote><p>以system用户连接之后，如果要查看scott方案中的对象，就要在对象前使用”scott.”作为前缀，否则提示不能访问。<br>但如果以用户scott的身份连接数据库实例后,再访问该方案中的对象时,就不再需要前缀。</p></blockquote><p>DISC[ONNECT]会断开连接，但不会退出SQL*PLUS。</p><h4 id="交互式命令"><a href="#交互式命令" class="headerlink" title="交互式命令"></a>交互式命令</h4><p>使SQL命令适应不同的具体条件，与用户交互。交互式命令一般被保存在脚本文件中，以进一步提高脚本文件的可重用性。</p><ul><li>替换变量<br>在变量名称前加一个&amp;。可实现define定义替换变量，避免在运行命令或脚本文件时出现反复提示、反复输入的麻烦。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define a = CLERK</span><br><span class="line"><span class="keyword">select</span> ename <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=<span class="number">20</span> <span class="keyword">and</span> job=<span class="string">'&amp;a'</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>可以直接使用define查看当前SQL*PLUS变量中保留的替换变量的情况。<br>使用undefine a可以清除定义的替换变量。</p></blockquote><ul><li><p>与用户交互<br>可以使用PROMPT命令、PAUSE命令、ACCEPT命令与用户进行通信。</p><ul><li>PROMPT命令用于输出提示信息，以便于使用户了解脚本文件的功能和运行情况。</li><li>PAUSE命令用于暂停脚本文件的运行。</li><li><p>ACCEPT命令可以让用户指定替换变量的类型（如CHAR,NUMBER,DATE等），用PROMPT选项指定提示信息，用HIDE选项隐藏输入，以便于用户输入替换变量。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> accept pwd  prompt '请输入密码：'  hide</span><br><span class="line">prompt</span><br><span class="line">prompt 显示XX部门XX工种员工姓名</span><br><span class="line">prompt =========================</span><br><span class="line">prompt 按&lt;ENTER&gt;键继续</span><br><span class="line">pause</span><br><span class="line">accept a number prompt '请输入部门：'</span><br><span class="line">accept b char prompt '请输入工种:'</span><br><span class="line"><span class="keyword">select</span> ename <span class="keyword">from</span> scott.emp <span class="keyword">where</span> deptno=&amp;a <span class="keyword">and</span> job=<span class="string">'&amp;b'</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://image.evilpwn.me/blog/Sqlplus-instructions-01.png-sign" alt="与用户交互"></p>]]></content>
      
      
      <categories>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sqlplus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用的Oracle服务及其作用</title>
      <link href="/2017/Oracle-services/"/>
      <url>/2017/Oracle-services/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的Oracle服务及其作用"><a href="#常用的Oracle服务及其作用" class="headerlink" title="常用的Oracle服务及其作用"></a>常用的Oracle服务及其作用</h2><h3 id="Oracle-ORCL-VSS-Writer-Service"><a href="#Oracle-ORCL-VSS-Writer-Service" class="headerlink" title="Oracle ORCL VSS Writer Service"></a>Oracle ORCL VSS Writer Service</h3><p>Oracle卷映射拷贝写入服务，VSS（Volume Shadow copy Service）能够让存储基础设备（比如磁盘、阵列等）创建高保真的时间点映像，即映射拷贝（Shadow Copy）。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统性能。</p><h3 id="OracleDBConsoleorcl"><a href="#OracleDBConsoleorcl" class="headerlink" title="OracleDBConsoleorcl"></a>OracleDBConsoleorcl</h3><p>Oracle数据库控制台服务，orcl是Oracle例程标识，默认的例程为orcl。在运行Oracle Enterprise Manager 11g时，需要启动此服务。<br>OracleJobSchedulerORCL。Oracle作业调度进行，ORCL是Oracle例程标识。此服务被默认设置为禁用。</p><h3 id="OracleOraDb11g-home1TNSListener"><a href="#OracleOraDb11g-home1TNSListener" class="headerlink" title="OracleOraDb11g_home1TNSListener"></a>OracleOraDb11g_home1TNSListener</h3><p>监听器服务，服务只有在数据库需要远程访问时才需要。此服务被默认设置为自动启动。</p><h3 id="OracleServiceORCL"><a href="#OracleServiceORCL" class="headerlink" title="OracleServiceORCL"></a>OracleServiceORCL</h3><p>数据库服务，这个服务会自动地启动和停止数据库。ORCL是Oracle例程标识。此服务被默认设置为自动启动。</p><a id="more"></a><h2 id="不同服务之间的关系"><a href="#不同服务之间的关系" class="headerlink" title="不同服务之间的关系"></a>不同服务之间的关系</h2><p>首先启动Oracle&lt;ORACLE_HOME_NAME&gt;TNSListener服务，然后再启动其它服务；<br>如果不启动Oracle&lt;ORACLE_HOME_NAME&gt;TNSListener，则可以使用SQL*Plus，但不能使用OEM;<br>OracleDBConsole&lt;sid&gt;依赖于OracleService&lt;SID&gt;，所以必须先启动OracleService&lt;SID&gt;，之后才能启动OracleDBConsole&lt;sid&gt;，关闭OracleService&lt;SID&gt;之前，应该先关闭OracleDBConsole&lt;sid&gt;。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>OracleServiceOrcl是实例的服务，需要开启才能打开例程。<br>OracleOraDB11g_home1TNSListener，是监听服务，在OracleServiceOrcl服务开启下，例程是存在的，但无法监听，无法连接到例程。<br>OracleDBConsoleOrcl服务是控制台服务，EM控制台的开关，关闭后无法使用EM，但可以使用SQL Plus连接数据库。</p><blockquote><p>SQL*PLUS的使用方法<br>sqlplus [username]/[password][@server][AS SYSDBA|AS SYSOPER]<br>其中username用于指定数据库用户名，password用于指定用户口令，server用于指定网络服务名，AS SYSDBA表示以SYSDBA特权登录， AS SYSOPER表示以SYSOPER特权登录。当连接到本地数据库时，不需要提供网络服务名。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识Oracle</title>
      <link href="/2017/Oracle-basic/"/>
      <url>/2017/Oracle-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据库(Database,DB)<br>数据库管理系统(DataBase Management System,DBMS)<br>数据库管理员(DataBase Administrator,DBA)<br>数据库系统(DataBase System,DBS)<br>关系型数据库(Relationship DataBase,RDB)<br>关系型数据库管理系统(RDBMS)<br>SQL语言（Structured Query Language）</p><a id="more"></a><p><img src="https://image.evilpwn.me/blog/Oracle-basic-01.png-sign" alt="图1"><br><img src="https://image.evilpwn.me/blog/oracle-basic-02.png-sign" alt="图2"></p><h3 id="数据库-Database-DB"><a href="#数据库-Database-DB" class="headerlink" title="数据库(Database, DB)"></a>数据库(Database, DB)</h3><p>数据库是长期保存在计算机存储设备上的、有组织或按一定格式存放的、可以共享的数据集合。简单地说，就是存放数据的仓库，或者说是存储在一起的相关数据的集合。<br>数据库中的数据按一定的<font color="red">数据模型</font>组织、描述和存储，具有较小的冗余度和较高的数据独立性，并可以为各种用户共享。<br>数据库是由<font color="red">数据库管理系统</font>来管理的。</p><h3 id="数据库管理系统-DataBase-System-DBS"><a href="#数据库管理系统-DataBase-System-DBS" class="headerlink" title="数据库管理系统(DataBase System,DBS)"></a>数据库管理系统(DataBase System,DBS)</h3><p>DBMS是建立在操作系统的基础上，对物理数据库进行统一管理和控制的软件，是位于用户和操作系统之间的一层数据管理软件。用户对数据库提出的访问请求是由DBMS来处理的。在DBMS中还提供了许多对数据库进行操作的使用程序。</p><p>DBMS使得能够方便的完成以下操作：</p><ul><li>建立和维护数据库</li><li>定义数据</li><li>操作数据</li><li>保证数据的安全性、完整性</li><li>多用户实现数据的共享</li><li>发生故障之后进行数据恢复</li></ul><h3 id="数据库系统-DataBase-System-DBS"><a href="#数据库系统-DataBase-System-DBS" class="headerlink" title="数据库系统(DataBase System, DBS)"></a>数据库系统(DataBase System, DBS)</h3><p>数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员和用户构成。应当指出的是，数据库的建立、使用和维护等工作只靠一个DBMS远远不够，还要有专门的人员来完成，这些人被称为数据库管理员(DBA)。</p><h3 id="数据库管理员-DataBase-Administrator-DBA"><a href="#数据库管理员-DataBase-Administrator-DBA" class="headerlink" title="数据库管理员(DataBase Administrator, DBA)"></a>数据库管理员(DataBase Administrator, DBA)</h3><p>负责整个数据库系统的建立、维护和协调的专门人员，是掌握数据库全局并进行数据库设计和管理的骨干人员。  </p><h3 id="数据管理历程"><a href="#数据管理历程" class="headerlink" title="数据管理历程"></a>数据管理历程</h3><ol><li>人工阶段<br>数据不保存<br>数据由应用程序管理<br>数据不能共享<br>数据不具有独立性，随其逻辑结构和物理结构而改变</li><li>文件管理阶段<br>数据以文件形式长期存在<br>数据由文件系统管理<br>数据共享性差、独立性差</li><li>数据库管理阶段<br>有利于实现数据共享<br>数据面向应用，而非面向程序</li></ol><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系模型是在逻辑模型的基础上建立的适用于具体数据库实现的一种数据模型。关系模型是目前最重要的一种<font color="red">数据模型</font>。它是<code>实体、属性、关系</code>在数据库中的具体体现。为了将逻辑模型转换为关系模型，需要将实体映射为<font color="red">数据库表</font>，将<font color="red">属性</font>映射为<font color="red">数据库列</font>，将关系映射为数据库表的<font color="red">主键或外键</font>。<br> 在用户的观点下，关系模型中数据的逻辑结构是一张二维表，由行和列组成。 </p><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ul><li>关系：整个二维表</li><li>关系名：表格名称</li><li>元组：行数据（记录）</li><li>属性：列数据（字段/分量）</li><li>属性名：列名称（字段名）</li><li>主键：唯一确定元组的属性组（关键字）</li><li>域：属性的取值范围</li><li>关系模式：对关系的描述，表示为：关系名（属性列表）<br>如：学生（学号，姓名，性别，系别，年龄，籍贯）</li><li>关系的约束<br>域完整性约束<br>实体完整性约束<br>参照完整性约束</li></ul><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul><li>关系型数据库是建立在关系模型基础上的数据库。它由一些相关的表和其他数据库对象组成。</li><li>这个定义包含几层含义：第一：建立在关系模型基础上；第二，信息被存放在表（二维表)中；第三，表之间是相互关联的；第四，除了表之外，还有其他数据库对象，如索引、视图、存储过程等。</li><li>当前流行的大型关系型数据库： Oracle、IBM DB2、SQL Server、SyBase、Informix等。</li><li>关系型数据库采用结构化查询语言（SQL）作为客户端程序与数据库服务器间沟通的桥梁——客户端发送SQL指令到服务器端，服务器端执行相关的指令并返回其查询的结果。</li></ul><h2 id="Oracle-与-SQL-Server-比较"><a href="#Oracle-与-SQL-Server-比较" class="headerlink" title="Oracle 与 SQL Server 比较"></a>Oracle 与 SQL Server 比较</h2><table><thead><tr><th>比较</th><th>Oracle</th><th>SQL Server</th></tr></thead><tbody><tr><td>所支持操作系统</td><td>UNIX、LINUX、SUN SOLARIS、WINDOWS</td><td>WINDOWS</td></tr><tr><td>数据吞吐量</td><td>面对大中型应用，最大可管理170TG左右</td><td>面对中小型应用，一般30-40G左右</td></tr><tr><td>多语言支持</td><td>不按照语言划分版本，共支持100多种语言</td><td>分为各种语言的版本，每种版本只支持一种语言，语言支持的数目不多</td></tr></tbody></table><h2 id="Oracle-11g-体系结构"><a href="#Oracle-11g-体系结构" class="headerlink" title="Oracle 11g 体系结构"></a>Oracle 11g 体系结构</h2><p>数据库的体系结构可以按照<font color="red">逻辑结构</font>和<font color="red">物理结构</font>来划分 :<br><img src="https://image.evilpwn.me/blog/Oracle-basic-03.png-sign" alt="图3"></p><h3 id="数据库物理结构"><a href="#数据库物理结构" class="headerlink" title="数据库物理结构"></a>数据库物理结构</h3><ul><li>Oracle将数据库按照规定的结构划分为不同级别的<font color="red">逻辑单元</font>。这里指的逻辑单元包括表、视图等常见的数据库组件。</li><li>逻辑结构和物理结构是分离的，对物理结构的管理可以不影响对逻辑存储结构的访问。 </li><li>物理结构由构成数据库的操作系统文件所决定。</li><li>每个Oracle数据库都由3种类型的文件组成：<font color="red">数据文件、日志文件、控制文件</font>。 </li></ul><h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><p>Oracle数据库有一个或多个物理的数据文件。数据库的数据文件包含全部数据库数据。逻辑数据物理地存储在数据文件中。<br>数据文件有下列特征：</p><ol><li>一个数据文件仅与一个数据库联系。</li><li>当数据库容量越界时，数据文件能够自动扩展。</li><li>一个或多个数据文件组成一个表空间。</li></ol><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>每个数据库有两个或多个日志文件组，日志文件组用于收集数据库日志。<br>日志的主要功能是记录对数据所作的修改，所以对数据库作的全部修改记录在日志中。</p><h4 id="控制文件"><a href="#控制文件" class="headerlink" title="控制文件"></a>控制文件</h4><p>每个Oracle数据库有一个控制文件，记录数据库的物理结构。（类似Windows注册表的作用）<br>控制文件包含数据库名、数据库数据文件和日志文件的名字、位置和数据库建立日期等信息。</p><h3 id="数据库逻辑结构"><a href="#数据库逻辑结构" class="headerlink" title="数据库逻辑结构"></a>数据库逻辑结构</h3><p>数据库由<font color="red">表空间</font>或者说由<font color="red">方案</font>组成。<br>Oracle 数据库的逻辑结构包括<font color="red">数据块（data block）、区间（extent）、段（segment）和表空间（tablespace）</font>等。数据库由若干个表空间组成，表空间由表组成，表由段组成，段由区间组成，区间则由数据块组成。<br><img src="https://image.evilpwn.me/blog/Oracle-basic-04.png-sign" alt="图4"><br><img src="https://image.evilpwn.me/blog/Oracle-basic-05.png-sign" alt="图5"></p><h4 id="表，视图，索引，簇"><a href="#表，视图，索引，簇" class="headerlink" title="表，视图，索引，簇"></a>表，视图，索引，簇</h4><ul><li>表：数据库中最常用的数据存储单元，它包括所有用户可以访问的数据。</li><li>视图：<font color="red">虚拟的表</font>，它在物理上并不存在。视图可以把表或其他视图的数据按照一定的条件组合起来，所以也可以把它看成是一个存储的查询。视图并不包含数据，它只是从基表中读取数据。 </li><li>索引：<font color="red">与表相关联的可选结构。</font>创建索引可以提高读取数据的效率。</li><li>簇：<font color="red">有些表共享公共的列，并经常被同时访问，为了提高数据存取的效率，把这些表在物理上存储在一起，得到的表的组合就是簇。</font>与索引相似，簇并不影响应用程序的设计。用户和应用程序并不关心表是否是簇的一部分，因为无论表在不在簇中，访问表的SQL语句都是一样的。</li></ul><h4 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h4><p><img src="https://image.evilpwn.me/blog/Oracle-basic-07.png-sign?imageMogr2/auto-orient/thumbnail/x300/blur/1x0/quality/75|imageslim" alt="图7"></p><ul><li>数据块是<font color="red">Oracle管理数据库存储空间的最小数据存储单位。</font></li><li>一个数据块对应磁盘上一定数量的数据库空间，标准的数据块大小由初始参数DB_BLOCK_SIZE指定。</li><li><font color="red">数据块既是逻辑单位，也是物理单位。</font></li><li>块的大小是操作系统块大小的整数倍。（以Win2K为例,操作系统块(OS block)的大小为4kb，所以Oracle Block的大小可以是4kb,8kb,16kb等等。）</li></ul><ul><li>公共的变长头：包含数据块的通用信息，如块地址和段类型等</li><li>表目录：包含在此块中有行数据的表的信息</li><li>行目录：包含此块中实际行数据的信息（包括在行数据区中每个行数据片的地址）</li><li>空闲空间：插入新行时需要存储空间，更新行数据时也可能造成存储空间的增加，这些存储空间都需要从空闲空间中分配</li><li>行数据：包含表或索引数据。行数据的存储可以跨越数据块</li></ul><h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><ul><li>区间是数据库存储空间中分配的一个逻辑单元，由一组相邻的数据块组成，它是<font color="red">Oracle分配磁盘空间的最小单位。</font></li><li>，在创建段时，它所包含的区间数量只能为MINEXTENTS。随着段中数据的增加，区间数量也可以不断增加，但不能超过MAXEXTENTS中定义的数量，否则会出现错误。 </li></ul><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><font color="red">段是由一组区间组成。</font><table><thead><tr><th>段类型</th><th>说明</th></tr></thead><tbody><tr><td>数据段</td><td>每个不在簇中的表都有一个数据段。表中的所有数据都存储在数据段的区间中。每个簇都有一个数据段。簇中每个表的数据都存储在簇的数据段中</td></tr><tr><td>索引段</td><td>每个索引都有一个索引段，存储所有的索引数据</td></tr><tr><td>临时段</td><td>当执行SQL语句需要临时工作区时，Oracle将创建临时段。执行完毕后，临时段的区间将被系统回收，以备需要时分配使用</td></tr><tr><td>回滚段</td><td>如果当前系统处于自动重做管理模式，则数据库服务器使用表空间来管理重做空间。这是Oracle公司推荐使用的模式。<br>但是，如果使用手动重做管理模式，则数据库管理员需要创建一个或多个回滚段，用于临时存储重做信息。<br>回滚段中的信息将在数据库恢复过程中使用到</td></tr></tbody></table><h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><ul><li>数据库可以划分<font color="red">为若干的逻辑存储单元</font>，这些存储单元被称为表空间。</li><li><font color="red">每个数据库都至少有一个系统表空间（称为SYSTEM表空间）</font>。</li><li>在创建表时，需要定义保存表的表空间。 </li></ul><table><thead><tr><th style="text-align:center">表空间</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">系统表空间<br>（SYSTEM Tablespace）</td><td>Oracle数据库必须具备的部分。用于存放表空间名称、表空间所包含的数据文件等管理数据库自身所需要的信息</td></tr><tr><td style="text-align:center">辅助表空间<br>（SYSAUX Tablespace）</td><td>系统表空间的辅助表空间，很多数据库组件把系统表空间作为存储数据的默认位置</td></tr><tr><td style="text-align:center">撤消表空间<br>（Undo Tablespace）</td><td>用于事务的回滚和撤销的表空间</td></tr><tr><td style="text-align:center">临时表空间<br>（Temporary Tablespace）</td><td>用于存储数据库的临时表</td></tr><tr><td style="text-align:center">用户表空间<br>（Users Tablespace）</td><td>用于存储用户的私有数据</td></tr><tr><td style="text-align:center">大文件表空间<br>（Bigfile Tablespaces）</td><td>Oracle 10g提供的一种新的表空间，它只能包含一个大文件，但文件大小可以达到4G个数据块</td></tr></tbody></table><h4 id="数据库、表空间和数据文件的关系"><a href="#数据库、表空间和数据文件的关系" class="headerlink" title="数据库、表空间和数据文件的关系"></a>数据库、表空间和数据文件的关系</h4><ul><li>每个表空间由一个或多个数据文件组成。数据文件用于在物理上存储表空间中所有逻辑结构的数据。</li><li>表空间中数据文件的大小之和就是表空间的存储容量。</li><li>数据库中表空间的存储容量之和就是数据库的存储容量。</li></ul><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ul><li>方案是一组数据库对象的集合。在创建用户的时候，会同时生成一个与用户同名的方案，此方案归同名用户所有。</li><li>方案对象直接处理数据库数据的逻辑结构，例如表（table）、视图（view）、索引（index）和簇（Clusters）等。 </li></ul><h4 id="表空间和方案之间的关系"><a href="#表空间和方案之间的关系" class="headerlink" title="表空间和方案之间的关系"></a>表空间和方案之间的关系</h4><ul><li>同一方案中的对象可以存储在不同的表空间中</li><li>表空间可以存储不同方案中的对象<br><img src="https://image.evilpwn.me/blog/Oracle-basic-08.png-sign" alt="图8"></li></ul><h3 id="逻辑和物理结构关系"><a href="#逻辑和物理结构关系" class="headerlink" title="逻辑和物理结构关系"></a>逻辑和物理结构关系</h3><p><img src="https://image.evilpwn.me/blog/Oracle-basic-06.png-sign" alt="图6"></p><h2 id="数据库例程（Oracle-Instance）"><a href="#数据库例程（Oracle-Instance）" class="headerlink" title="数据库例程（Oracle Instance）"></a>数据库例程（Oracle Instance）</h2><ul><li>当用户连接到数据库，使用数据库时，实际上连接到该数据库的例程，通过例程来连接、使用数据库。</li><li><p>例程是用户和数据库之间的一个中间层。</p><blockquote><p>例程和数据库的区别：<br>数据库主要只用于<font color="red">存储数据的物理结构</font>，总是实际存在的<br>例程是由操作系统的<font color="red">内存结构</font>和<font color="red">一系列的进程</font>组成，可以启动和关闭</p></blockquote></li><li><p>每个运行的Oracle数据库都对应一个Oracle例程（Instance），也可以称为实例。</p></li><li>一台计算机上可以创建多个Oracle数据库，一个数据库上可以有多个例程。<br><img src="https://image.evilpwn.me/blog/Oracle-basic-09.png-sign" alt="图9"></li></ul><h3 id="例程的组成"><a href="#例程的组成" class="headerlink" title="例程的组成"></a>例程的组成</h3><p>例程（INSTANCE）是存取和控制数据库的软件机制，它由系统全局区（System Global Area，简称SGA）和进程组成。<br><img src="https://image.evilpwn.me/blog/Oracle-basic-10.png-sign" alt="图10"></p><h2 id="内部存储结构"><a href="#内部存储结构" class="headerlink" title="内部存储结构"></a>内部存储结构</h2><ul><li>系统全局区（System Global Area，SGA）</li><li>程序全局区（Program Global Area，PGA） </li></ul><h3 id="系统全局区-SGA"><a href="#系统全局区-SGA" class="headerlink" title="系统全局区(SGA)"></a>系统全局区(SGA)</h3><p>SGA是ORACLE系统为实例分配的一组共享缓冲存储区，用于存放数据库数据和控制信息，以实现对数据库数据的管理和操作。</p><font color="red"><br>每个例程都只有一个SGA.<br>它是不同用户进程与服务进程进行通信的中心,数据库的各种操作主要在SGA中进行。<br>创建例程时,Oracle为SGA分配内存；<br>终止例程时,释放SGA所占用的内存。<br></font><p><img src="https://image.evilpwn.me/blog/Oracle-basic-11.png-sign" alt="图11"></p><ul><li>数据库缓冲区：保存最近从数据文件中读取的数据块；</li><li>重做日志缓冲区：用于存储重做记录；</li><li>SQL共享池：最近执行的SQL语句、PL/SQL程序和数据字典信息,是对SQL语句和PL/SQL程序进行语法分析、编译、执行的内存区；</li><li>Java池：为Java命令提供语法分析；</li><li>大池：DBA配置的可选内存区域，用于分配大量的内存；</li><li>数据词典缓冲区：保存数据库对象的信息，如帐号、数据文件名、段名、表说明和权限等；</li></ul><h3 id="程序全局区-PGA"><a href="#程序全局区-PGA" class="headerlink" title="程序全局区(PGA)"></a>程序全局区(PGA)</h3><p>PGA是在用户进程连接到数据库，并创建一个对应的会话时，由oracle为服务进程分配的，专门用于当前用户会话的内存区。这个内存区是非共享的，只有服务进程本身才能访问它自己的PGA。<br>包含Oracle进程数据和控制信息的内存区域。</p><font color="red"><br>PGA是非共享的，而SGA是共享的。<br>PGA大小由操作系统决定，并且分配后保持不变；<br>会话终止时，自动释放PGA所占的内存。<br></font><p><img src="https://image.evilpwn.me/blog/Oracle-basic-12.png-sign" alt="图12"></p><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><p>进程是操作系统中的一个概念，是一个可以独立调用的活动，用于完成指定的任务。</p><blockquote><p>进程与程序的区别是：</p></blockquote><font color="red"><br>&gt; 进程是动态创建的，完成后销毁；程序是静态的实体，可以复制、编辑。<br>&gt; 进程强调执行过程，程序仅仅是指令的有序集合。<br>&gt; 进程在内存中，程序在外存中。<br></font><p><img src="https://image.evilpwn.me/blog/Oracle-basic-13.png-sign" alt="图13"></p><h3 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h3><p>运行应用程序或Oracle工具。<br>当用户运行一个应用程序时，就建立一个用户进程。</p><h3 id="服务器进程"><a href="#服务器进程" class="headerlink" title="服务器进程"></a>服务器进程</h3><p>用于处理连接到数据库例程的用户进程的请求。</p><blockquote><p>主要完成以下工作：<br>分析并运行应用程序中的SQL语句；<br>如果需要的数据块不在SGA中，则把它从数据文件中读取到SGA的共享数据库缓冲区中；<br>返回应用程序需要的结果；</p></blockquote><h3 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h3><p>为了实现系统的最佳性能，并协调多个用户，在多进程Oracle系统中使用的一些附加进程，多由操作系统自动创建。</p><blockquote><p>主要的后台进程有：</p><ul><li>DBWn：数据库写进程</li><li>LGWR：日志写进程</li><li>CKPT：检查点写进程</li><li>SMON：系统监控进程</li><li>PMON：进程监控进程</li><li>ARCn：归档进程</li><li>RECO：恢复进程</li><li>LCKn：封锁进程</li></ul></blockquote><h2 id="Oracle数据库用户类型"><a href="#Oracle数据库用户类型" class="headerlink" title="Oracle数据库用户类型"></a>Oracle数据库用户类型</h2><ul><li>数据库管理员</li><li>安全官员</li><li>网络管理员</li><li>应用程序开发员</li><li>应用程序管理员</li><li>数据库用户 </li></ul><h3 id="数据库管理员"><a href="#数据库管理员" class="headerlink" title="数据库管理员"></a>数据库管理员</h3><ul><li>安装和升级Oracle数据库服务器和其他应用工具。</li><li>分配系统存储空间，并计划数据库系统未来需要的存储空间。</li><li>当应用程序开发员设计完成一个应用程序之后，为其创建主要的数据库存储结构，例如表空间。</li><li>根据应用程序开发员的设计创建主要的数据库对象，例如表、视图和索引。</li><li>根据应用程序开发员提供的信息修改数据库结构。</li><li>管理用户，维护系统安全。</li><li>确保对Oracle的使用符合Oracle的许可协议。</li><li>控制和监视用户对数据库的访问。</li><li>监视和优化数据库的行为。</li><li>做好备份和恢复数据库的计划。</li><li>维护磁带中归档的数据。</li><li>备份和恢复数据库。</li><li>在必要时联系Oracle公司获取技术支持。</li></ul><h3 id="安全管理员"><a href="#安全管理员" class="headerlink" title="安全管理员"></a>安全管理员</h3><p>安全官员可以管理用户、控制和监视用户对数据库的访问，以及维护数据库的安全。如果拥有单独的安全官员，则DBA就不需要关注这些问题。</p><h3 id="网络管理员"><a href="#网络管理员" class="headerlink" title="网络管理员"></a>网络管理员</h3><p>网络管理员可以管理Oracle的网络产品。</p><h3 id="应用程序开发员"><a href="#应用程序开发员" class="headerlink" title="应用程序开发员"></a>应用程序开发员</h3><ul><li>设计和开发数据库应用程序。</li><li>为应用程序设计数据库结构。</li><li>估算应用程序需要的数据库存储空间。</li><li>定义应用程序需要对数据库结构所进行的修改。</li><li>将上述信息提供给数据库管理员。</li><li>在开发过程中对应用程序进行调整。</li><li>在开发过程中对应用程序的安全性进行检测。</li></ul><h3 id="应用程序管理员"><a href="#应用程序管理员" class="headerlink" title="应用程序管理员"></a>应用程序管理员</h3><p>应用程序管理员可以对指定的应用程序进行管理，每个应用程序都可以有自己的管理员。</p><h3 id="数据库用户"><a href="#数据库用户" class="headerlink" title="数据库用户"></a>数据库用户</h3><p>数据库用户通过应用程序与数据库打交道。<br>数据库用户最常用的权限如下：</p><ul><li>在权限的范围内添加、修改和删除数据。</li><li>从数据库中生成统计报表。</li></ul><h3 id="默认数据库管理员用户"><a href="#默认数据库管理员用户" class="headerlink" title="默认数据库管理员用户"></a>默认数据库管理员用户</h3><p><font color="red">数据库管理员</font>可以拥有两种类型的用户:</p><ul><li>操作系统账户</li><li>Oracle数据库账户</li></ul><ol><li>数据库管理员的操作系统账户。<br>为了完成许多数据库管理任务，数据库管理员必须能够执行操作系统命令，因此数据库管理员需要拥有一个操作系统账户用于访问操作系统。</li><li>数据库管理员的用户名。<br>在创建Oracle数据库时，如下两个用户被自动创建：<br>SYS，默认密码为CHANGE_ON_INSTALL。<br>SYSTEM，默认密码为MANAGER。</li></ol><blockquote><p>sys和system用户区别</p><ol><li>最重要的区别，存储的数据的重要性不同<br>sys所有oracle的数据字典的基表和视图都存放在sys用户中，这些基表和视图对于oracle的运行是至关重要的，由数据库自己维护，任何用户都不能手动更改。sys用户拥有sysdba，sysoper等角色或权限，是oracle权限最高的用户。<br>system用户用于存放次一级的内部数据，如oracle的一些特性或工具的管理信息。system用户拥有sysdba角色权限。</li><li>其次的区别，权限的不同<br>system用户只能用normal身份登陆em，除非你对它授予了sysdba的系统权限或者syspoer系统权限。sys用户具有“SYSDBA”或者“SYSOPER”系统权限，登陆em也只能用这两个身份，不能用normal。<br>以sys用户登陆Oracle，执行select * from V_$PWFILE_USERS;可查询到具有sysdba权限的用户。</li></ol></blockquote><p>SYSDBA与SYSOPER权限的区别</p><table><thead><tr><th>SYSDBA</th><th>SYSOPER</th></tr></thead><tbody><tr><td>startup</td><td>startup</td></tr><tr><td>shutdown</td><td>shutdown</td></tr><tr><td>alter database Open/mount/backup</td><td>alter database Open/mount/backup</td></tr><tr><td>改变字符集</td><td></td></tr><tr><td>create database</td><td></td></tr><tr><td>drop database</td><td></td></tr><tr><td>create spfile</td><td>create spfile</td></tr><tr><td>alter database archivelog</td><td>alter database archivelog</td></tr><tr><td>alter database recover</td><td>alter database recover</td></tr><tr><td>拥有restricted session权限</td><td>拥有restricted session权限</td></tr><tr><td>对应的方案是SYS</td><td>对应的方案是PUBLIC</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
