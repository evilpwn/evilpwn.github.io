<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解OSPF开放式最短路径优先协议]]></title>
    <url>%2F2017%2Fdeeply-OSPF%2F</url>
    <content type="text"><![CDATA[RIP缺陷 以跳数评估的路由并非最优路径 最大跳数16导致网络尺度小 收敛速度慢 更新发送全部路由表浪费网络资源 以跳数评估的路由并非最优路径 如果RTA选择S0/0传输，传输需时会大大缩短为3s 最大跳数16导致网络尺度小 RIP协议限制网络直径不能超过16跳！ 收敛速度慢 RTA和RTB收到路由不可达信息后进入抑制时间抑制时间结束前，即使有新的设备发布路由RTA和RTB的路由也不能更新 更新发送全部路由表浪费网络资源 假设RTA和RTB各有1000条路由，每条路由需占用20个字节每次路由更新时，RTA和RTB之间单向需消耗至少160Kb的带宽资源 链路状态路由协议的特点 对网络发生的变化能够快速响应。 当网络发生变化的时候发送触发式更新（triggered update）。 发送周期性更新（链路状态刷新），间隔时间为30分钟。 OSPF是一种链路状态路由选择协议。 链路状态路由协议只在网络拓扑发生变化以后产生路由更新。链路状态发生变化后，检测到变化的路由器生成并发送LSA（Link-State Advertisement，链路状态通告），并通过组播地址发送给所有的邻居路由器。接受到LSA的每个路由器会复制一份LSA，更新它自己的LSDB（Link-State Database），再将LSA转发给其他邻居。这种扩散机制被称为泛洪（Flooding）。 OSPF必须维护以下信息： 邻居表（neighbor table）：也叫邻接数据库（adjacency database）。存储了邻居路由器的信息，如果一个OSPF路由器和它的邻居路由器失去联系，在几秒中的时间内，它会标记所有到达那条路由均为无效并且重新计算到达目标网络的路径。 拓扑表（topology table）：一般叫做LSDB，OSPF路由器通过LSA学习到其他的路由器和网络状况,LSA存储在LSDB中。 路由表（routing table）：也就是我们所说的路由表了，也叫forwarding database，包含了到达目标网络的最佳路径的信息。 链路状态路由协议和距离矢量路由协议（OSPF和RIP）的一个重要区别：距离矢量路由协议是基于流言的路由协议（Routing By Rumors）,即：距离矢量路由协议依靠邻居发给它的信息来作路由决策，而且路由器不需要保持完整的网络信息。而链路状态路由协议的路由器拥有完整的网络信息，而且每个路由器自己做出路由决策。 OSPF工作机制OSPF对比RIPOSPF不再采用跳数的概念，而是根据接口的吞吐率、拥塞状况、往返时间、可靠性等实际链路的负载能力定出路由的代价，同时选择最短、最优路由并允许保持到达同一目标地址的多条路由，从而平衡网络负荷；OSPF支持不同服务类型的不同代价，从而实现不同QoS的路由服务；OSPF路由器不再交换路由表，而是同步各路由器对网络状态的认识。 特性 OSPF RIPv2 RIPv1 协议类型 链路状态 距离矢量 距离矢量 无类支持 是 是 否 VLSM支持 是 是 否 自动汇总 否 是 是 手动汇总 是 否 否 不连继支持 是 是 否 路由转播 可变化转播 周期性转播 周期性转播 路由度量 宽带 跳 跳 跳计数限制 无 15 15 会聚 快 慢 慢 对等认证 是 是 否 分层网络 是（使用地区） 否（只是平面） 否（只是平面） 更新 事件触发 路由表更新 路由表更新 路由计算 Dijkstra Bellman-Ford Bellman-Ford OSPF邻居关系广播网络中的Hello报文：交换Hello报文进行邻接： 路由器和别的路由器交换hello包,目标地址采用多播地址 hello包交换完毕，邻接关系形成。 接下来通过交换LSA和对接收方的确认进行同步LSDB。对于OSPF路由器而言，进入完全邻接状态。 如果需要的话，路由器转发新的LSA给其他的邻居，来保证整个区域内LSDB的完全同步。 OSPF泛洪机制LSA工作原理： OSPF路由类型。。。。。。待补充。。。。。。 LSDBLSA：描述本地路由器或网络的数据单元，对路由器来说，它描述了路由器的接口状态和邻接状态。 LSA类型 描述 1类 路由器LSA 2类 网络LSA 3类和4类 汇总LSA 5类 AS外部LSA 6类 组播OSPF LSA 7类 为次未节区域定义的 8类 BGP的外部属性LSA 9、10或11类 不透明LSA SPF算法 在地区内部,每台路由器都计算到达同一地区中每个网络的最佳/最短路径。这种计算基于拓扑数据库中收集的信息和一种称为最短路径优先(SPF)的算法。假想地区中的每台路由器都会构造一棵树,很像是一棵家谱树,在那里该路由器就是树根,而其他网络则沿树枝和树叶被编排。最短路径树被路由器用来将路由插人到路由表中。如果某个路由器的接口存在于多个地区中,那么需要为每个地区都构建一棵单独的树。在路由器执行SPF算法时,一个关键标准是去往某网络的每个潜在路径的度量或开销值。 SPF算法也称Dijkstra算法（Dijkstra发明的），是OSPF路由协议的基础。 。。。。。。待补充。。。。。。 OSPF报文类型邻居状态和数据库同步OSPF区域虚链路（Virtual Link）OSPF协议中要求每个区域与骨干区域（Area 0）必须直接相连，但是实际组网中，网络情况非常的复杂，有时候在划分区域时，无法保证每个区域都满足这个要求。这个时候就需要使用虚链接（Virtual Link）技术来解决这个问题。 常规区域只能和骨干区域交换LSA，常规区域与常规区域之间即使直连也无法互换LSA， 虚连接是指在两台ABR（Area Border Routers，区域边界路由器）之间，穿过一个非骨干区域（也称为转换区域，Transit Area），建立的一条逻辑上的连接通道（须在两端的ABR上同时配置）。如上图，在路由器C和路由器E之间建立了一条虚链接，使Area 3和骨干区域Area 0之间有了逻辑连接，Area 1为转换区域。“逻辑通道”是指两台ABR之间的其它运行OSPF的路由器只是转发报文，相当于在两个ABR之间形成了一个点到点的连接。因此在这个连接上，和物理接口一样可以配置接口的各类参数。 常见模型骨干区域被分割 非骨干区域无法和骨干区域保持连通 OSPF网络类型OSPF基本配置总结]]></content>
      <categories>
        <category>路由与交换</category>
      </categories>
      <tags>
        <tag>路由</tag>
        <tag>OSPF协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL简单示例]]></title>
    <url>%2F2017%2FOpenGL_entry%2F</url>
    <content type="text"><![CDATA[两点距离计算与线段绘制 Point.h123456789101112131415class Point&#123;public: //Point(); Point(float x=0,float y=0,float z=0)&#123;this-&gt;x=x; this-&gt;y=y; this-&gt;z=z;&#125;; Point(Point &amp;p)&#123;x=p.x; y=p.y; z=p.z;&#125;; ~Point()&#123;&#125;; float getX()&#123;return x;&#125;; float getY()&#123;return y;&#125;; float getZ()&#123;return z;&#125;; void move(float dx=0,float dy=0,float dz=0)&#123;x+=dx; y+=dy; z+=dz;&#125;;private: float x; float y; float z;&#125;; Line.h1234567891011121314151617181920212223242526272829303132333435#include &lt;math.h&gt;#include "Point.h"class Line&#123;public: Line(); Line(Point &amp;a,Point &amp;b); Line(Line &amp;line); ~Line()&#123;&#125;; float getLength();protected:private: Point p1; Point p2;&#125;;Line::Line():p1(0,0,0),p2(0,0,0)&#123;&#125;Line::Line(Point &amp;a, Point &amp;b):p1(a),p2(b)&#123;&#125;Line::Line(Line &amp;line):p1(line.p1),p2(line.p2)&#123;&#125;float Line::getLength()&#123; float x=p1.getX()-p2.getX(); float y=p1.getY()-p2.getY(); float z=p1.getZ()-p2.getZ(); return sqrt(x*x+y*y+z*z);&#125; main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;windows.h&gt; // codeblocks要导入，VS无所谓#include &lt;GL/glut.h&gt; // OPenGL实用工具库#include &lt;math.h&gt;#include "Line.h"#include &lt;iostream&gt;//#include "include/glut.h"using namespace std;int dx=0, dy=0; // 平移变量float angle=0; // 旋转角度int mouseX=0,mouseY=0; //鼠标位置const int XL=100,XR=300,YB=100,YT=300;//const int LEFT=1,RIGHT=2,BOTTOM=4,TOP=8;Point A,B;void init(void)&#123; glClearColor(1.0, 1.0, 1.0, 0.0); // 设置背景颜色 glMatrixMode(GL_PROJECTION); // 设置投影参数 gluOrtho2D(-300.0, 300.0, -200, 200.0); // 设置场景的大小&#125;//按上下左右键移动图形void move(int key,int x,int y)&#123; switch (key) &#123; case GLUT_KEY_LEFT:dx -= 10;break; case GLUT_KEY_RIGHT:dx += 10;break; case GLUT_KEY_UP:dy += 10;break; case GLUT_KEY_DOWN:dy -= 10;break; &#125; glutPostRedisplay();&#125;// 按下鼠标左键记下当前位置void mouseButtonDown(int key,int action,int x,int y)&#123; if(key==GLUT_LEFT_BUTTON &amp;&amp; action==GLUT_DOWN) &#123; mouseX=x; mouseY=y; &#125;&#125;// 移动鼠标确定旋转角度void mouseMotion(int x,int y)&#123; angle+=360*(mouseY-y)/1600; mouseX=x; mouseY=y; glutPostRedisplay();&#125;void draw(void)&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0, 0.0, 0.0); // 设置画图颜色 glLineWidth(3); glPointSize(5); glPushMatrix(); glTranslatef(dx,dy,0); glRotatef(angle,0,0,1); /*glBegin(GL_LINE_LOOP); glVertex2i(XL,YT); glVertex2i(XL,YB); glVertex2i(XR,YB); glVertex2i(XR,YT); glEnd( ); */ /*glBegin(GL_POLYGON); glVertex2i(10,10); glVertex2i(200,30); glVertex2i(100,100); glVertex2i(-10,10); glVertex2i(-200,30); glVertex2i(-100,-100); glEnd();*/ glBegin(GL_LINES); glVertex2f(A.getX(),A.getY()); glVertex2f(B.getX(),B.getY()); glEnd(); glPopMatrix(); glFlush(); // 处理绘图pipeLine&#125;int main(int argc, char** argv)&#123; float x1,x2,y1,y2; cout&lt;&lt;"Input two plane Points:"; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; Point a(x1,y1),b(x2,y2); A=a,B=b; Line line(a,b); cout&lt;&lt;"Length is "&lt;&lt;line.getLength()&lt;&lt;endl; glutInit(&amp;argc, argv); // 初始化GLUT环境 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); // GLUT显示模式：单缓冲区、RGB颜色模型 glutInitWindowPosition(50, 100); // 窗口左上角的位置 glutInitWindowSize(800, 600); // 显示窗口的大小 glutCreateWindow("An Example of OpenGL"); // 创建显示窗口，加上标题 init( ); glutDisplayFunc(draw); // 调用绘图函数 glutSpecialFunc(move); // 功能键响应 glutMouseFunc(mouseButtonDown); // 鼠标按键响应 glutMotionFunc(mouseMotion); // 鼠标移动响应 glutMainLoop( ); // 进入事件处理循环 return 0;&#125;]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sudoers文件详解]]></title>
    <url>%2F2017%2Fsudoers_file%2F</url>
    <content type="text"><![CDATA[sudoers文件详解/etc/sudoers 是sudo的配置文件 缺省配置：root ALL=(ALL) ALL 配置方法：123user ALL=(ALL) ALLuser ALL=(ALL) NOPASSWD: ALL#用户 主机=(身份) 命令 具体如下：12345678910111213141516171819# sudoers file.## This file MUST be edited with the 'visudo' command as root.## See the sudoers man page for the details on how to write a sudoers file.## Host alias specification# User alias specification# Cmnd alias specification# Defaults specification# User privilege specificationroot ALL=(ALL) ALL# Uncomment to allow people in group wheel to run all commands# %wheel ALL=(ALL) ALL# Same thing without a password# %wheel ALL=(ALL) NOPASSWD: ALL# Samples# %users ALL=/sbin/mount /cdrom,/sbin/umount /cdrom# %users localhost=/sbin/shutdown -h now 配置一最简单的配置123user ALL=(ALL) ALLuser ALL=(ALL) NOPASSWD: ALL#用户 主机=(身份) 命令 普通用户user登陆后，执行sudo su -输入自己的密码(或不输密码)，然后就能够执行root权限的所有命令 配置二让普通用户user只能在某几台服务器上，执行root能执行的某些命令先配置Alias（别名），这样在配置权限时，会方便些，Alias主要分成4种：Host_AliasCmnd_AliasUser_AliasRunas_Alias Host_Alias：主机列表1Host_Alias HOST_FLAG = hostname1, hostname2, hostname3 Cmnd_Alias：允许执行的命令列表，命令前加上!表示不能执行此命令。命令一定要使用绝对路径，避免其他目录的同名命令被执行，造成安全隐患 ,因此使用的时候也是使用绝对路径。1Cmnd_Alias COMMAND_FLAG = command1, command2, command3, !command4 User_Alias：具有sudo权限的用户列表1User_Alias USER_FLAG = user1, user2, user3 Runas_Alias：用户以什么身份执行（例如root，或者oracle）的列表1Runas_Alias RUNAS_FLAG = operator1, operator2, operator3 配置权限1234USER_FLAG HOST_FLAG=(RUNAS_FLAG) COMMAND_FLAG 用户 主机 = (身份) 命令若不需要密码验证：USER_FLAG HOST_FLAG=(RUNAS_FLAG) NOPASSWD: COMMAND_FLAG 配置示例：123456789101112131415161718192021222324# sudoers file.## This file MUST be edited with the 'visudo' command as root.## See the sudoers man page for the details on how to write a sudoers file.## Host alias specificationHost_Alias HOSTS = 192.168.1.1, 192.168.1.2# User alias specification# Cmnd alias specificationCmnd_Alias SQUID = /opt/vtbin/squid_refresh, !/sbin/service, /bin/rmCmnd_Alias ADMPW = /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd, !/usr/bin/passwd root# Defaults specification# User privilege specificationroot ALL=(ALL) ALLuser HOSTS=(ALL) NOPASSWD: SQUIDuser HOSTS=(ALL) NOPASSWD: ADMPW# Uncomment to allow people in group wheel to run all commands# %wheel ALL=(ALL) ALL# Same thing without a password# %wheel ALL=(ALL) NOPASSWD: ALL# Samples# %users ALL=/sbin/mount /cdrom,/sbin/umount /cdrom# %users localhost=/sbin/shutdown -h now]]></content>
      <categories>
        <category>Linux网络架构</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器集群</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器安全运维]]></title>
    <url>%2F2017%2FServer-security-operations%2F</url>
    <content type="text"><![CDATA[服务器安全运维删除特殊的用户和用户组 可删除用户adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher等。 可删除用户组adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers等。 12[root@localhost ~]# userdel games[root@localhost ~]# groupdel games 有时，某些用户仅仅作用进程调用或者用户组调用，并不需要登陆功能。1[root@localhost ~]# usermod -s /sbin/nologin nagios 关闭系统不需要的服务运行服务越多，系统越不安全。 一般可以关闭的服务anacron、auditd、autofs、avahi-daemon、avahi-dnsconfd、bluetooth、cpuspeed、firstboot、gpm、haldaemon、hidd、ip6tables、ipsec、isdn、lpd、mcstrans、messagebus、netfs、nfs、nfslock、nscd、pcscd portmap、readahead_early、restorecond、rpcgssd、rpcidmapd、rstatd、sendmail、setroubleshoot、yppasswdd ypserv 通过chkconfig命令关闭服务的自动启动：1chkconfig --level 345 bluetooth off level0：关机；1：单用户；2：无网络的多用户命令行模式；3：有网络的多用户命令行模式；4：不可用；5：带推行界面的多用户模式；6：重新启动。 系统运行必须的服务 服务名称 服务内容 acpid 电源管理，建议开启 apmd 高级电源能源管理服务，可监控电池性能 kudzu 检测硬件是否变化的服务，建议开启 crond 为Linux下自动安排的进程提供运行服务，建议开启 atd 类似crond，提供在指定的时间做指定的事情的服务，与windows下的计划任务功能相同 keytables 用于装载入镜像键盘 iptables Linux内置的访华强软件，为了系统安全，必须开启 xinetd 支持多种网络服务的核心守候进程，建议开启 xfs 使用X Windows 桌面系统必需的服务 network 激活已配置网络接口的脚本程序，也就是启动网络服务，必须必须要启动 sshd 提供远程登陆Linux上的服务，为了系统维护方便，一般建议开启 syslog 记录系统日志的服务，很重要，建议开启 密码安全策略Linux远程登陆有两种认证方式：密码认证和密钥认证。密钥认证：公钥存储在远程服务器上，专用密钥保存在本地，登陆时进行配对认证。 SSH 全称Secure SHell 配置方法： 使用rz命令将公钥上传到服务器，然后导入： 1[user@localhost ~]$ ssh-keygen -i -f Identity.pub &gt;&gt; ~/.ssh/authorized_key2 修改SSH2的配置文件 1234567vim /etc/ssh/sshd-config修改如下几个配置：Protocol 2 # 仅允许使用SSH2PubkeyAuthentication yes # 启用PublicKey认证AuthorizedkeyFile .ssh/authorized_key2 # PublicKey文件路径PasswordAuthentication no # 不使用口令认证 重启sshd服务 123service sshd restart或/etc/rc.d/init.d/sshd restart 合理使用su，sudo命令为了保证服务器的安全，几乎所有服务器都禁止了超级用户直接登陆系统，而是通过普通用户登陆系统，然后通过su命令切换超级用户下，执行一些需要超级权限的工作。 sudo命令允许系统管理员分配给普通用户一些合理的“权力”，并且不需要普通用户指导超级用户密码。sudo相对于权限无限制的su命令来说，比较安全，所以，sudo也成为受限制的su。 sudoers文件/etc/sudoers 是sudo的配置文件 缺省配置：root ALL=(ALL) ALL [sudoers文件详解] 配置/etc/sudoers来使普通用户具有特殊权限。 设计sudo的宗旨是：赋予用户尽可能少的权限但仍允许他们完成自己的工作。兼顾了安全性和易用性。 网络安全运维test 数据安全工具 DRBD、extundeletetest]]></content>
      <categories>
        <category>Linux网络架构</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器集群</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块——Turtle]]></title>
    <url>%2F2017%2FPython-turtle%2F</url>
    <content type="text"><![CDATA[turtle简介turtle 海龟绘图 简单实例用turtle画一个python小蟒蛇123456789101112131415161718192021import turtledef drawSnake(rad,angle,len,neckrad): for i in range(len): turtle.circle(rad,angle) # 圆形轨迹爬行，rad半径（找到原点，开始画圆） turtle.circle(-rad,angle) # 正表示原点在轨迹左侧，负表示在轨迹右侧 turtle.circle(rad,angel/2) # angle表示沿圆形爬行的弧度值 turtle.fd(rad) # turtle.forward();表示向前直线爬行，参数表距离 turtle.circle(neckrad+1,180) turtle.fd(rad*2/3)def main(): turtle.setup(1300,800,0,0) # 在屏幕左上角创建一个1300x800的画布 pythonsize=30 # 轨迹宽度为30像素 turtle.pensize(pythonsize) turtle.pencolor("blue") # 轨迹颜色,也可输入RPG，如："#3B9909" turtle.seth(-40) # 初始轨迹方向，参数为角度值 drawSnake(40,80,5,pythonsize/2) # 绘制main() 库函数详解画笔绘制状态函数（共3个） 函数 描述 pendown() 放下画笔 pendup() 提起画笔，与pendown()配对使用 pensize(width) 设置画笔线条的粗细为指定大小 画笔运动函数（共13个） 函数 描述 forward() 沿着当前方向前进指定距离 backward() 沿着当前相反方向后退指定距离 right(angle) 向右旋转angle角度 left(angle) 向左旋转angle角度 goto(x,y) 移动到绝对坐标（x,y）处 setx() 将当前x轴移动到指定位置 sety() 将当前y轴移动到指定位置 setheading(angle) 设置当前朝向为angle角度 home() 设置当前画笔位置为原点，朝向东 circle(step) 绘制一个指定半径，角度、以及绘制步骤step的圆 dot(r,color) 绘制一个指定半径r和颜色color的圆点 undo() 撤销画笔最后一步动作 speed() 设置画笔的绘制速度，参数为0-10之间 画笔颜色和字体函数（共11个） 函数 描述 color() 设置画笔的颜色 begin_fill() 填充图形前，调用该方法 end_fill() 填充图形结束 filling() 返回填充的状态，True为填充，False为未填充 clear() 清空当前窗口，但不改变当前画笔的位置 reset() 清空当前窗口，并重置位置等状态为默认值 screensize() 设置画布的长和宽 hideturtle() 隐藏画笔的turtle形状 showturtle() 显示画笔的turtle形状 isvisible() 如果turtle 可见，则返回True write(str,font=None) 输出font字体的字符串]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Python</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H3C-NAPT配置]]></title>
    <url>%2F2017%2FH3C-NAPT%2F</url>
    <content type="text"><![CDATA[配置命令 实例 123### 全网互通 ###[RT1]ip route-static 0.0.0.0 0 192.68.0.2[RT2]ip route-static 0.0.0.0 0 192.68.0.1 1234567891011121314### NAPT配置 ###[RT1]acl basic 2001[RT1-acl-ipv4-basic-2001]rule permit source 10.0.0.0 0.0.0.255[RT1]nat address-group 1[RT1-address-group-1]address 192.68.0.11 192.68.0.20[RT1-address-group-1]int g 0/1[RT1-GigabitEthernet0/1]nat outbound 2001 address-group 1[RT2]acl basic 2001[RT2-acl-ipv4-basic-2001]rule permit source 20.0.0.0 0.0.0.255[RT2]nat address-group 1[RT2-address-group-1]address 192.68.0.21 192.68.0.30[RT2-address-group-1]int g 0/1[RT2-GigabitEthernet0/1]nat outbound 2001 address-group 1 结果验证：dis nat session verbosePC1报文：PC2报文：]]></content>
      <categories>
        <category>路由与交换</category>
      </categories>
      <tags>
        <tag>H3C</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H3C基础配置]]></title>
    <url>%2F2017%2FH3C-cmd%2F</url>
    <content type="text"><![CDATA[基本命令信息查看命令 查看当前配置：display current-configuration 显示接口信息：display interface 显示接口ip状态与配置：display ip interface brief 显示系统统计信息：display diagnostic-information 查看历史命令记录：display history-command 设备管理命令 进入系统视图：system-view 配置设备名称：sysname 配置系统时间：clock datetime 显示系统时间：display clock 配置欢迎/提示信息：header Telnet配置12345&lt;RT1&gt;system-view[RT1]sysname client[client]interface GigabitEthernet 0/0/0[client-GigabitEthernet0/0/0]ip add 192.168.1.1 24[client-GigabitEthernet0/0/0]quit 1234567891011121314151617181920&lt;RT2&gt;system-view[RT2]sysname server[server]int GigabitEthernet 0/0/0[server-GigabitEthernet0/0/0]ip add 192.168.1.2 24[server-GigabitEthernet0/0/0]quit[server]ping 192.168.1.1 PING 192.168.1.1: 56 data bytes, press CTRL_C to break Reply from 192.168.1.1: bytes=56 Sequence=1 ttl=255 time=34 ms Reply from 192.168.1.1: bytes=56 Sequence=2 ttl=255 time=16 ms Reply from 192.168.1.1: bytes=56 Sequence=3 ttl=255 time=15 ms Reply from 192.168.1.1: bytes=56 Sequence=4 ttl=255 time=16 msReply from 192.168.1.1: bytes=56 Sequence=5 ttl=255 time=16 ms[server]telnet server enable # 开启telnet[server]local-user test # 添加本地用户[server-luser-test]password simple admin # 设置密码[server-luser-test]service-type telnet # 设置服务类型[server-luser-test]authorization-attribute level 3 # 设置用户级别（新版最高为15）[server-luser-test]quit[server]user-interface vty 0 4 # 虚拟用户数量[server-ui-vty0-4]authentication-mode scheme # 验证模式设为混合验证 VLAN与链路聚合SW2为网关设备，SW2和SW1之间采用端口聚合。123456789101112131415161718192021&lt;SW1&gt;system-view[SW1]vl 10 # 进入vl视图（不是int vl 10）[SW1-vlan10]port E 0/4/1 # 把接口接入vl[SW1-vlan10]quit[SW1]int e 0/4/0[SW1-Ethernet0/4/0]port link-type trunk # 配置trunk[SW1-Ethernet0/4/0]port trunk permit vl all # 允许所有vl通过 Please wait........................................... Done.### 端口聚合 ###[SW1]int Bridge-Aggregation 1 # 创建链路聚合组[SW1-Bridge-Aggregation1]int e 0/4/3[SW1-Ethernet0/4/3]port link-aggregation group 1 # 接入聚合组1[SW1-Ethernet0/4/3]int e 0/4/4 [SW1-Ethernet0/4/4]port link-aggregation group 1[SW1-Ethernet0/4/4]int e 0/4/5 [SW1-Ethernet0/4/5]port link-aggregation group 1[SW1-Ethernet0/4/5]quit[SW1]int Bridge-Aggregation 1 [SW1-Bridge-Aggregation1]port link-type trunk # 配置聚合端口trunk[SW1-Bridge-Aggregation1]port trunk permit vl all # 允许所有vl通过 其他配置： 设置trunk端口的缺省vlan[Switch-Ethernet1/0/1] port trunk pvid vlan vlan-id 配置端口的链路类型为Hybrid类型[Switch-Ethernet1/0/1] port link-type hybrid 允许指定的VLAN通过当前Hybrid端口[Switch-Ethernet1/0/1] port hybrid vlan vlan-id-list { tagged | untagged } 设置Hybrid端口的缺省VLAN[Switch-Ethernet1/0/1] port hybrid pvid vlan vlan-id DHCP在交换机SW2上配置多个dhcp地址池，分配给不同vlan，利用静态路由实现全网互通，RT2和RT3使用dhcp分配ip。 12345678910111213141516171819202122232425### DHCP配置 ###[SW2]dhcp server forbidden-ip 192.168.10.1 192.168.10.10 # DHCP服务中不参与分配的地址（范围）[SW2]dhcp server ip-pool 1 # 创建DHCP地址池1[SW2-dhcp-pool-1]network 192.168.10.0 mask 255.255.255.0 # 配置动态分配的ip地址范围[SW2-dhcp-pool-1]gateway-list 192.168.10.254 # 配置DHCP客户端分配的网关地址[SW2-dhcp-pool-1]dns-list 10.10.10.10 # 配置DHCP客户端分配的DNS服务器地址[SW2-dhcp-pool-1]expired day 1 # 配置动态分配的IP地址的租用有效期限[SW2-dhcp-pool-1]qu[SW2]dhcp server ip-pool 2 # 创建DHCP地址池2[SW2-dhcp-pool-1]network 192.168.20.0 mask 255.255.255.0 # 配置动态分配的ip地址范围[SW2-dhcp-pool-1]gateway-list 192.168.20.254 # 配置DHCP客户端分配的网关地址[SW2-dhcp-pool-1]dns-list 20.20.20.20 # 配置DHCP客户端分配的DNS服务器地址[SW2-dhcp-pool-1]expired day 1 # 配置动态分配的IP地址的租用有效期限[SW2-dhcp-pool-1]qu[SW2]dhcp enable # dhcp开启### vl配置 #### vl10 虚拟接口配dhcp地址池1中的地址，这里兼网关192.168.10.254 ## vl20 虚拟接口配dhcp地址池2中的地址，这里兼网关192.168.20.254 ## E 0/4/0 配置trunk，允许所有vl通过 #### 配置 G 0/0/0 ### 12RT2/RT3端口开启dhcp自动获取[RT-GigabitEthernet0/0/×]ip add dhcp-alloc 1RT4配置ip和静态路由到172.16.10.254 单臂路由RT2,3,4模拟PC1vlan-type dot1q vid 10 # 单臂路由协议封装 OSPF单、多区域单区域配置 123456789[RTA] interface loopback 0[RTA-loopback-0]ip address 1.1.1.1 255.255.255.255[RTA-loopback-0]quit[RTA] router id 1.1.1.1 # 配置路由id[RTA] ospf # 启动ospf进程[RTA-ospf-1] area 0 # 配置ospf区域[RTA-ospf-1-area-0.0.0.0] network 1.1.1.1 0.0.0.0 # 在指定接口上启动ospf[RTA-ospf-1-area-0.0.0.0] network 10.0.0.0 0.0.0.255[RTA-ospf-1-area-0.0.0.0] network 20.0.0.0 0.0.0.255 123456789[RTB]interface loopback 0[RTB-loopback-0]ip address 2.2.2.2 255.255.255.255[RTB-loopback-0]quit[RTB]route id 2.2.2.2[RTB]ospf 1[RTB-ospf-1]area 0[RTB-ospf-1-area-0.0.0.0]network 2.2.2.2 0.0.0.0[RTB-ospf-1-area-0.0.0.0]network 10.0.0.0 0.0.0.255[RTB-ospf-1-area-0.0.0.0]network 30.0.0.0 0.0.0.255 123456789[RTC]interface loopback 0[RTC-loopback-0]ip address 3.3.3.3 255.255.255.255[RTC-loopback-0]quit[RTC]router id 3.3.3.3[RTC]ospf 1[RTC-ospf-1]area 0[RTC-ospf-1-area-0.0.0.0]network 3.3.3.3 0.0.0.0[RTC-ospf-1-area-0.0.0.0]network 20.0.0.0 0.0.0.255[RTC-ospf-1-area-0.0.0.0]network 30.0.0.0 0.0.0.255 多区域 1 12RTA和RTC配置域单区域OSPF配置相同。RTB需要加入两个区域，RTA和RTC有到达彼此的路由。 1234567891011[RTB] interface loopback 0[RTB-loopback-0] ip address 2.2.2.2 255.255.255.255[RTB-loopback-0] quit[RTB] route id 2.2.2.2[RTB] ospf 100[RTB-ospf-100] area 0[RTB-ospf-100-area-0.0.0.0] network 2.2.2.2 0.0.0.0[RTB-ospf-100-area-0.0.0.0] network 10.0.0.0 0.0.0.255[RTB-ospf-100-area-0.0.0.0] quit[RTB-ospf-100] area 192.168.10.1[RTB-ospf-100-area-192.168.10.1] network 20.0.0.0 0.0.0.255 多区域 2虚链接（Virtual Link）建立 解决骨干区域被分割的问题 解决非骨干区域无法和骨干区域保持连通的问题 配置虚连接命令[Router-ospf-area-0.0.0.1] vlink-peer router-id [hello seconds | retransmit seconds | trans-delay seconds | dead seconds] 其他配置： 配置OSPF接口优先级：[Router-Ethernet0/0] ospf dr-priority priority 配置OSPF接口cost：[Router-Ethernet0/0] ospf cost value 显示OSPF摘要[Router] display ospf brief 显示启动OSPF的接口信息[Router] display ospf interface 显示OSPF的出错信息[Router] display ospf error 显示OSPF的进程信息[Router] display ospf INTEGER OSPF事件调试信息 debugging ospf event OSPF链路状态通告调试 debugging ospf lsa OSPF包调试信息 debugging ospf packet OSPF路由计算调试信息 debugging ospf spf OSPF进程调试信息 debugging ospf INTEGER ACL访问列表详解通配符掩码 通配符号掩码和IP地址结合使用以描述一个地址范围 通配符掩码和子网掩码相似，但含义不同0表示对应位须比较1表示对应位不比较 IP地址 通配符掩码 表示的地址范围 192.168.0.1 0.0.0.255 192.168.0.0/24 192.168.0.1 0.0.3.255 192.168.0.0/22 192.168.0.1 0.255.255.255 192.168.0.0/8 192.168.0.1 0.0.0.0 192.168.0.0 192.168.0.1 255.255.255.255 0.0.0.0/0 192.168.0.1 0.0.2.255 192.168.0.0/24 或 192.168.2.0/24有歧义，一般没这种情况 ACL标识 数字序号标识 访问控制列表的分类 数字序号的范围 基本访问控制列表 2000-2999 扩展访问控制列表 3000-3999 基于二层的访问控制列表 4000-4999 用户自定义的访问控制列表 5000-5999 名称标识 基本ACL：根据报文的源MAC地址、目的MAC地址、802.1p优先级、二层协议类型等二层信息制定匹配规则高级ACL：根据报文的源IP地址、目的IP地址、IP承载的协议类型、协议特性等三、四层信息制定规则二层ACL：根据报文的源MAC地址、目的MAC地址、802.1p优先级、二层协议类型等二层信息制定匹配规则用户自定义ACL：根据任意位置的任意字串制定匹配规则（报文的报文头、IP头等为基准，指定从第几个字节开始与掩码进行“与”操作，将从报文提取出来的字符串和用户定义的字符串进行比较，找到匹配的报文。） 配置流程 启动包过滤防火墙功能，设置默认的过滤规则 根据需要选择合适的ACL分类 创建正确的规则设置匹配条件设置合适的动作（Permit/Deny) 在路由器的接口上应用ACL，并指明过滤报文的方向（入站/出站） ACL配置要求PCA不能访问NetworkA和NetworkB，但可以访问其他所有网络两种部署方案： 高级ACL部署： 12345[RTC] firewall enable # 开启防火墙 ### firewall default &#123; permit | deny &#125; # 防火墙默认是permit，此处可以不更改[RTC] acl number 3000 # 指定ACL序号[RTC-acl-adv-3000] rule deny ip source 172.16.0.1 0 destination 192.168.0.0 0.0.1.255 # 定义规则[RTC-Ethernet0/0] firewall packet-filter 3000 inbound # 应用到接口 基本ACL部署： 1234[RTA] firewall enable[RTA] acl number 2000[RTA-acl-basic-2000] rule deny source 172.16.0.1 0[RTA-Ethernet0/1] firewall packet-filter 2000 inbound 其他配置 配置高级IPv4 ACL高级IPv4 ACL的序号取值范围为3000～3999定义规则来匹配源IP地址、目的IP地址、IP承载的协议类型、协议端口号等信息: 1[sysname-acl-adv-3000] rule [ rule-id ] &#123; deny | permit &#125; protocol [ destination &#123; dest-addr dest-wildcard | any &#125; | destination-port operator port1 [ port2 ] established | fragment | source &#123; sour-addr sour-wildcard | any &#125; | source-port operator port1 [ port2 ] | time-range time-name] 配置二层 ACL，二层ACL的序号取值范围为4000～4999定义规则来匹配源MAC地址、目的MAC地址、802.1p优先级、二层协议类型等二层信息： 1[sysname-acl-ethernetframe-3000] rule [ rule-id ] &#123; deny | permit &#125; [ cos vlan-pri | dest-mac dest-addr dest-mask | lsap lsap-code lsap-wildcard | source-mac sour-addr source-mask | time-range time-name] 禁止FTP、telnet等协议[SW1-acl-adv-3001]rule 0 deny tcp source 192.168.10.0 0.0.0.255 destination 192.168.1.2 0.0.0.255 destination-port eq telnet ACL包过滤的局限性 ACL包过滤防火墙是根据数据包头中的二、三、四层信息来进行报文过滤的，对应用层的信息无法识别 无法根据用户名来决定数据是否通过 无法给不同的用户授予不同的权限级别 ACL包过滤防火墙是静态防火墙，无法对应用层协议进行动态检测 综合实验1在学校内部署一个小型中心机房，组网如下图，RT1、RT2属于不同VLAN，并且能够通过自动湖区地址的方式配置IP地址，网关在核心层交换机上，并且与下行链路构成聚合链路，在所有交换机和路由器上配置telnet服务器，能够远程通过自己电脑登陆上去，配置合理的路由协议达到全网互通。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960SW1[SW1]vl 10[SW1-vlan10]int vl 10[SW1-Vlan-interface10]ip add 192.168.10.254 24[SW1-Vlan-interface10]vl 20[SW1-vlan20]int vl 20[SW1-Vlan-interface20]ip add 192.168.20.254 24[SW1-Vlan-interface20]qu[SW1][SW1]dhcp server ip-pool 1[SW1-dhcp-pool-1]net 192.168.10.0 24[SW1-dhcp-pool-1]gateway-list 192.168.10.254[SW1-dhcp-pool-1]dns-list 10.10.10.10[SW1-dhcp-pool-1]expired day 1[SW1-dhcp-pool-1]qu[SW1][SW1]dhcp server ip-pool 2[SW1-dhcp-pool-2]net 192.168.20.0 24[SW1-dhcp-pool-2]gateway-list 192.168.20.254[SW1-dhcp-pool-2]dns-list 20.20.20.20[SW1-dhcp-pool-2]qu[SW1][SW1]dhcp enableDHCP is enabled successfully![SW1]int g 0/0/0[SW1-GigabitEthernet0/0/0]ip add 192.168.1.1 24[SW1-GigabitEthernet0/0/0]qu[SW1][SW1][SW1]int Bridge-Aggregation 1[SW1-Bridge-Aggregation1]int e 0/4/2[SW1-Ethernet0/4/2]port link-aggregation group 1%Sep 8 08:25:47:453 2011 SW1 LAGG/5/LAGG_ACTIVE: Member port Ethernet0/4/2 of aggregation group BAGG1 becomes ACTIVE.%Sep 8 08:25:47:453 2011 SW1 IFNET/3/LINK_UPDOWN: Bridge-Aggregation1 link status is UP.[SW1-Ethernet0/4/2]int e 0/4/3 [SW1-Ethernet0/4/3]port link-aggregation group 1%Sep 8 08:25:52:515 2011 SW1 LAGG/5/LAGG_ACTIVE: Member port Ethernet0/4/3 of aggregation group BAGG1 becomes ACTIVE.[SW1-Ethernet0/4/3]int Bridge-Aggregation 1 [SW1-Bridge-Aggregation1]port link-type trunk [SW1-Bridge-Aggregation1]port trunk permit vl all Please wait...%Sep 8 08:26:14:422 2011 SW1 IFNET/3/LINK_UPDOWN: Vlan-interface10 link status is UP.%Sep 8 08:26:14:422 2011 SW1 IFNET/5/LINEPROTO_UPDOWN: Line protocol on the interface Vlan-interface10 is UP.%Sep 8 08:26:14:422 2011 SW1 IFNET/3/LINK_UPDOWN: Vlan-interface20 link status is UP.%Sep 8 08:26:14:422 2011 SW1 IFNET/5/LINEPROTO_UPDOWN: Line protocol on the interface Vlan-interface20 is UP......................................... Done. Configuring Ethernet0/4/2........................................... Done. Configuring Ethernet0/4/3........................................... Done.[SW1-Bridge-Aggregation1]qu[SW1][SW1] [SW1]ospf [SW1-ospf-1]a 0[SW1-ospf-1-area-0.0.0.0]net 192.168.10.0 0.0.0.255[SW1-ospf-1-area-0.0.0.0]net 192.168.20.0 0.0.0.255[SW1-ospf-1-area-0.0.0.0]qu[SW1-ospf-1]a 1 [SW1-ospf-1-area-0.0.0.1]net 192.168.1.0 0.0.0.255[SW1-ospf-1-area-0.0.0.1]qu[SW1-ospf-1]qu 1234567891011121314151617181920212223242526272829SW2[SW2]vl 10[SW2-vlan10]port e 0/4/0[SW2-vlan10]vl 20[SW2-vlan20]port e 0/4/1[SW2-vlan20]qu[SW2][SW2]int Bridge-Aggregation 1 [SW2-Bridge-Aggregation1]int e 0/4/2[SW2-Ethernet0/4/2]port link-aggregation group 1[SW2-Ethernet0/4/2][SW2-Ethernet0/4/2]int e 0/4/3[SW2-Ethernet0/4/3]port link-aggregation group 1[SW2-Ethernet0/4/3]qu [SW2][SW2]int Bridge-Aggregation 1[SW2-Bridge-Aggregation1]port link-type trunk [SW2-Bridge-Aggregation1]port trunk permit vl all Please wait........................................... Done. Configuring Ethernet0/4/2........................................... Done. Configuring Ethernet0/4/3........................................... Done.[SW2-Bridge-Aggregation1][SW2][SW2][SW2]int vl 10[SW2-Vlan-interface10]ip add 192.168.10.100 24[SW2-Vlan-interface10]qu[SW2]ip route-static 0.0.0.0 0 192.168.10.254 [SW2] 12345RT1[RT1-GigabitEthernet0/0/0]ip add dhcp-allocRT2[RT2-GigabitEthernet0/0/1]ip add dhcp-alloc 123456789101112131415RT3[RT3]int g 0/0/0 [RT3-GigabitEthernet0/0/0]ip ad 192.168.1.2 24[RT3-GigabitEthernet0/0/0]int g 0/0/1[RT3-GigabitEthernet0/0/1]ip add 172.16.10.1 26[RT3-GigabitEthernet0/0/1]qu[RT3][RT3][RT3]ospf[RT3-ospf-1]a 1[RT3-ospf-1-area-0.0.0.1]net 172.16.10.0 0.0.0.63[RT3-ospf-1-area-0.0.0.1]net 192.168.1.0 0.0.0.255[RT3-ospf-1-area-0.0.0.1]qu[RT3-ospf-1]qu[RT3] 123456789101112131415161718192021RT4[RT4]int g 0/0/1[RT4-GigabitEthernet0/0/1]ip add 172.16.10.2 26[RT4-GigabitEthernet0/0/1]qu[RT4][RT4]ospf [RT4-ospf-1]a 1[RT4-ospf-1-area-0.0.0.1]net 172.16.10.0 0.0.0.63[RT4-ospf-1-area-0.0.0.1]int g 0/0/0 [RT4-GigabitEthernet0/0/0]ip add 202.114.10.1 24[RT4-GigabitEthernet0/0/0]qu[RT4]ospf[RT4-ospf-1]a 1[RT4-ospf-1-area-0.0.0.1]net 202.114.10.0 0.0.0.255[RT4-ospf-1-area-0.0.0.1]qu[RT4-ospf-1][RT4-ospf-1][RT4-ospf-1]int g 0/0/0 [RT4-GigabitEthernet0/0/0]ip add 202.114.10.1 24[RT4-GigabitEthernet0/0/0]qu[RT4] 12345678RT1-telnet配置[RT1]telnet server enable% Start Telnet server[RT1]user-interface vty 0 4[RT1-ui-vty0-4]set authentication password simple 123456[RT1-ui-vty0-4]authentication-mode password[RT1-ui-vty0-4]user privilege level 3[RT1-ui-vty0-4]qu]]></content>
      <categories>
        <category>路由与交换</category>
      </categories>
      <tags>
        <tag>H3C</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python内置函数]]></title>
    <url>%2F2017%2FPython-built-in-functions%2F</url>
    <content type="text"><![CDATA[内置函数 print()123456print(*objects, sep=' ', end='\n', file=sys.stdout)- objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。- sep -- 用来间隔多个对象，默认值是一个空格。- end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。- file -- 要写入的文件对象。 format()str.format()格式化字符串，通过{}和:代替以前的%。format 函数可以接受不限个参数，位置可以不按顺序。1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt;"&#123;&#125; &#123;&#125;".format("hello", "world") # 不设置指定位置，按默认顺序'hello world' &gt;&gt;&gt; "&#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置'hello world' &gt;&gt;&gt; "&#123;1&#125; &#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置'world hello world'----------------------------------------------# 设置参数print("网站名：&#123;name&#125;, 地址 &#123;url&#125;".format(name="百度", url="www.baidu.com")) # 通过字典设置参数site = &#123;"name": "百度", "url": "www.baidu.com"&#125;print("网站名：&#123;name&#125;, 地址 &#123;url&#125;".format(**site)) # 通过列表索引设置参数my_list = ['百度', 'www.baidu.com']print("网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;".format(my_list)) # "0" 是可选的# 以上输出结果均为：网站名：百度, 地址 www.baidu.com-----------------------------------------------# 向 str.format() 传入对象class AssignValue(object): def __init__(self, value): self.value = valuemy_value = AssignValue(6)print('value 为: &#123;0.value&#125;'.format(my_value)) # "0" 是可选的# 输出结果：value 为: 6 数字格式化12&gt;&gt;&gt; print("&#123;:.2f&#125;".format(3.1415926));3.14 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:10d} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 11 ‘{:b}’.format(11)‘{:d}’.format(11)‘{:o}’.format(11)‘{:x}’.format(11)‘{:#x}’.format(11)‘{:#X}’.format(11) 10111113b0xb0XB 进制转换 ^, &lt;, &gt;分别是居中、左对齐、右对齐，后面带宽度:后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。+表示在正数前显示+，负数前显示-； （空格）表示在正数前加空格b、d、o、x 分别是二进制、十进制、八进制、十六进制。其他：c 输出整数对应的Unicode字符e 输出浮点数对应的小写字母e的指数形式E 输出浮点数对应的大写字母E的指数形式 此外，还可以使用大括号{}来转义大括号：12print ("&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;".format("abc"))# abc 对应的位置是 &#123;0&#125; eval() 和 repr()eval()：将字符串当成有效的Python表达式来求值并返回计算结果。repr()：将Python的变量和表达式转换为字符串表示123456789101112x = 1eval('x+1')eval('x==1')s="123+456"eval(s)&gt;&gt;&gt; x=1&gt;&gt;&gt; repr(x==1)'True'&gt;&gt;&gt; repr(1+2)'3']]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习]]></title>
    <url>%2F2017%2FPython-basic%2F</url>
    <content type="text"><![CDATA[Python 简介 Python是一种解释型语言：没有编译这个环节，类似与PHP和Perl Python是交互式语言：可以在Python提示符中，直接互动执行写的程序 Python是面向对象语言：支持面向对象的风格或代码封装在对象的编程技术 编译与解释 编译将高级语言源代码转换成目标代码（机器语言），程序便可执行。优点：目标代码执行速度更快，在相同操作系统上使用灵活。 解释将源代码逐条转换成目标代码同时逐条执行，每次运行程序都需要源代码和解释器。优点：便于维护源代码，良好的可移植性。 编译执行的编程语言叫静态语言，如C，JAVA解释执行的编程语言叫脚本语言，如PHP，JavaScript 程序的基本编写方法IPO模式I：InputP：Process 处理O：Output 变量字符串常用方法：upper(),lower(),relace(old,new),find(“abc”) 函数 含义 upper(),lower() 大小写转换 capitalize() 首字母大写，如：’Abc def dfe.dfe’ title() 标题化（所有单词首字母大写），如：’Abc def dfe.dfe’ strip() 去两边空格及去指定字符 lstrip()、rstrip() 去左/右边空格及去指定字符 split() 按指定字符分割字符串为数组 isdigit() 判读是否为数字类型 find(“abc”) 搜索字符串 relace(old,new) 字符串替换 12# 遍历字符串中每个字符for &lt;var&gt; in &lt;string&gt;: 列表list用[]标识，加号+是列表连接运算符，星号*是重复操作。1234567891011121314151617181920list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]tinylist = [123, 'john'] print list # 输出完整列表print list[0] # 输出列表的第一个元素print list[1:3] # 输出第二个至第三个的元素 print list[2:] # 输出从第三个开始至列表末尾的所有元素print tinylist * 2 # 输出列表两次print list + tinylist # 打印组合的列表list.append(21) # 末尾添加元素21list.remove(21) # 删除元素21list.reverse() # 反转元素list.sort() # 给列表元素排序pos=list.index(21) # 找出指定元素的索引list.insert(i,x) # 位置i中插入新元素xlist.count(x) # 元素x在列表中的数量list.pop(i) # 取出列表中位置为i的元素，并删除len(list) # 获取元素个数21 in list # 检查是否在序列中 字符串拆分成列表：12&gt;&gt;&gt; "python is an excellent language".split()['python', 'is', 'an', 'excellent', 'language'] 元组tuple类似于列表，但不能二次赋值，相当于只读列表。元组用()标识，也可以不使用123tuple1 = ( 'runoob', 786 , 2.23, 'john', 70.2 )tuple2 = "abc",123tuple1 = "ssd",123,("找你",31) # 元组中包含元组 元组中元素不可修改、删除和添加；列表可以。但两者都可以使用+,*,=来扩展。 字典dict字典（dictionary）是除列表以外python中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者区别在于：字典中元素通过键来存取，而不是通过偏移存取。字典用{}标识，由索引（key）和它对应的值value组成。 123456789101112dict=&#123;'ftp':21,'ssh':22,'telnet':23,123:666&#125;print dict['ftp'] # 输出键为“ftp”的值print dict[123] # 输出键为123的值print dict # 输出完整字典# &#123;'ftp': 21, 123: 666, 'ssh': 22, 'telnet': 23&#125;print dict.keys() # 输出所有键# ['ftp', 123, 'ssh', 'telnet']print dict.values() # 输出所有值# [21, 666, 22, 23]print dict.items() # .items()方法返回字典中所有向的完整信息的列表# [('ftp', 21), (123, 666), ('ssh', 22), ('telnet', 23)] 数据类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 12int(10.3) # 10int('F',16) # 15 运算符 算数运算符 比较运算符 赋值运算符 位运算符 逻辑运算符 成员运算符 身份运算符 算数运算符12345672**4 # 16 幂12%10 # 2 取模12//10 # 1 取整除1/2 # 01.0/2 # 0.51/float(2) # 0.5 位运算符按位运算符是把数字看成二进制进行计算。12345678910a为60，b为13 a = 0011 1100 b = 0000 1101-----------------a&amp;b = 0000 1100 # 输出结果12a|b = 0011 1101 # 输出结果61a^b = 0011 0001 # 按位异或，相异为1，相同为0;输出结果49~a = 1100 0011 # 按位取反;输出结果-61a&lt;&lt;2= 1111 0000 # 左移动运算符，输出结果240；高位丢弃，低位补0a&gt;&gt;2= 0000 1111 # 输出15 逻辑运算符a=10,b=20 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 先从前往后判断，判断出Ture或False的位置就是返回结果。not只返回True或False。 成员运算符in,not in，返回 True 或 False123a = 10list = [1, 2, 3, 4, 5 ]a in list 身份运算符判断两个标识符是不是引用自一个对象。is：x is y 类似 id(x) == id(y)is not：x is not y 类似 id(a) != id(b)也就是is传递了指针，判断是否指向同一地址块，==传递了值。 123456789101112131415161718&gt;&gt;&gt; a=2.0&gt;&gt;&gt; b=2.0&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a=2&gt;&gt;&gt; b=2&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a=6666&gt;&gt;&gt; b=6666&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a=6666;b=6666&gt;&gt;&gt; a is bFalse python中会为每个出现的对象分配内存，哪怕他们的值完全相等（注意是相等不是相同）。但是为了提高内存利用效率对于一些简单的对象，如一些数值较小的int对象，python采取重用对象内存的办法。如但果赋值的不是2而是大的数值，情况就跟前面的一样了变量写在同一行,将会指向同一个对象这点可以细细体会 (●’◡’●) 运算符优先级由高到低： 函数库的引用123456789101112import &lt;库名&gt;&lt;库名&gt;.&lt;函数名&gt;import turtleturtle.fd(100)或from &lt;库名&gt; import *from &lt;库名&gt; import &lt;函数名&gt;fd(100)from的这两种方式调用函数时，不再需要库名。注意此时代码中不能再创建与库函数名一样的变量或函数。 异常处理try…except…1234567891011121314try: &lt;body&gt;except &lt;ErrorType1&gt;: &lt;handler1&gt;except &lt;ErrorType2&gt;: &lt;handler2&gt;except: &lt;handler0&gt;[else: 无异常时执行finally: 无论有无异常均执行] 异常会在未处理时，打印处理，从而找到异常，如： ZeroDivisionError，NameError，TypeError。一个except子句可以处理多个异常：except (RuntimeError, TypeError, NameError):raise 语句可以抛出一个指定的异常：1234&gt;&gt;&gt; raise NameError('HiThere')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in ?NameError: HiThere 内置函数[Python内置函数]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE文件格式]]></title>
    <url>%2F2017%2FPE-file%2F</url>
    <content type="text"><![CDATA[PE文件概念PE(Portable Executable File Format)，可移植的执行体，常见的有EXE文件、动态链接库文件DLL文件以及许多DLL的扩展组件，如OCX控件已经控制面板程序（.CPL）。Windows PE文件主要源自Unix操作系统常用的COFF文件（Commom Object File Format，通用目标文件格式）规范。为保证MS-DOS和windows的兼容性，PE文件格式保留了MS-DOS程序的MZ头和MS-DOS stub。描述PE格式以及COFF文件的主要文件是winnt.h文件。 当PE文件通过Windows加载器被装入内存后，内存中的版本被称作模块(Module)。映射文件的起始地址被称为模块句柄（hModule），可以通过模块句柄访问内存中的其他数据结构。这个初始内存地址也称为基地址（ImageBase）。在32位Windows系统中可直接调用GetModuleHandle函数以取得指向DLL的指针，通过指针访问该DLL Module的内容。基地址的值是由PE文件本身设定。默认设置中，用VC++建立的EXE文件基地址是0040 0000h，DLL文件基地址是1000 0000h。 文件虚拟地址（Relative Virtual Address，简称RVA）是内存中的一个简单的相对与PE文件装入地址（即基地址）的偏移位置，是一个相对地址（偏移量）。实际的内存地址被称为虚拟地址（VA）。虚拟地址（VA）=基地址（ImageBase）+相对虚拟地址（RVA） 待更]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>PE文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows逆向基础]]></title>
    <url>%2F2017%2Fwindows_reverse%2F</url>
    <content type="text"><![CDATA[ASCII与UNICODE字符集 ASCII（美国信息交换标准码）7位编码，共128个代码，最通用的单字节编码，主要用于显示现代英语和其他西欧语言。如：“good”的ASCII编码：67h 6fh 6fh 64h Unicode是ASCII的扩展，Windows中，用两个字节（16位）对其进行编码，也称宽字节集（Widechars）。高位填充0。如：“good”的Unicode编码：67 00 6f 00 6f 00 64 00 （左低右高） Windows APIWindows 提供了应用程序可利用的丰富的函数调用，这些函数采用动态链接库(即DLL)的形式实现。三个主要的动态链接库：kernel32.dll、user32.dll、gdi32.dll，分别提供操作系统核心功能服务、用户接口、图形设备接口。 API常见函数MessageBox在user32.dll用户模块中，创建和显示信息框。123456int MessageBox( HWND hWnd, //父窗口句柄 LPCTSTR IpTest, //消息框文本地址（内容） LPCTSTR IpCation, //消息框标题地址 UNIT uType //消息框样式); 根据用户单击了的按钮返回一个整数值。ANSI版是MessageBoxA，Unicode版是MessageBoxW。 句柄Windows程序中，用来标识应用程序中的不同对象和同类中的不同的实例，如：一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。应用程序能够通过句柄访问相应的对象的信息，但句柄不是指针，程序不能利用句柄来直接阅读文件中的信息。句柄是Windows用来标志应用程序中建立的或是使用的唯一整数，Windows大量使用了句柄来标识对象。 GetDlgItemText在user32.dll用户模块中，获取对话框文本。123456Unit GetDlgItemText( HWND hDlg, //对话框句柄 int nlDDlgItem, //控件标识（ID号） LPCTSTR IpString, //文本缓冲区指针 int nMaxCount //字符缓冲区的长度); 执行成功返回缓冲区字符个数，失败返回0ANSI版是GetDlgItemTexA，Unicode版是GetDlgItemTexW。 Windows消息机制Windows是一个消息（Message）驱动的系统。Windows消息提供应用程序与应用程序之间、应用程序与Windows操作系统之间进行通信的手段。应用程序想要实现的功能由消息来触发，并且靠对消息的相应和处理来完成功能。Windows中，有两种消息队列：系统队列、应用程序消息队列。一个事件的发生，到达处理它的窗口函数，必须经过如下过程：]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编基础]]></title>
    <url>%2F2017%2FAssembly-Language%2F</url>
    <content type="text"><![CDATA[机器语言、机器指令、目标程序机器指令：操作码和操作数两部分构成，CPU能直接识别并遵照执行的指令。机器语言：二进制编码的机器指令的集合及一组使用机器指令的规则。是CPU能直接识别的唯一语言。目标程序：是指用机器语言描述的程序。 寄存器80x86中，常见寄存器（32位）有16个，包括4个数据寄存器、2个变址寄存器、2个指针寄存器、6个段寄存器、1个指令寄存器、1个标志寄存器。 寄存器分类如下（FS、GS未列出）： 数据寄存器EAX/EBX/ECX/EDX作用：存放程序运行中间数据，其中ECX常用做计数器特点：可分割存取（EAX—AX—AL and AH） 变址寄存器ESI(源地址)/EDI(目的地址)作用：存放存储单元段内偏移量，用于寻址 指针寄存器EBP(栈底)/ESP(栈顶)作用：EBP是基地址指针寄存器，可以直接访问栈中数据，ESP指向堆栈栈顶 段寄存器CS/DS/ES/SS/FS/GS说明：32位CPU中，段寄存器作用根据工作方式不同而不同，在保护模式下，段寄存器中存放的不再是段值，而是称为“选择子(Selector)”的某个值CS：代码段寄存器，用于存放应用程序代码所在的段的基址DS：数据段寄存器，存放数据段的段基址ES：附加段寄存器，存放程序使用的附加段基址SS：堆栈段寄存器，存放栈段的段基址FS：标志段寄存器，windows下，用于处理程序异常GS：全局段寄存器，和附加段类似表示方法：段值：偏移计算方法：物理地址 = 段值×16 + 偏移示例：用16进制表示的逻辑地址1234：3456H所对应的存储单元的物理地址为15796H。 指令寄存器指令寄存器：EIP，存放下次要执行的指令的地址 标志寄存器PSW16位，包含9个标志位，主要用于反映处理器的状态和运算结果的某些特征。9个标志位分为两组：运算结果标志位：OF、SF、ZF、AF、PF、CF状态控制标志位：DF、IF、TF各标志位含义 基本指令 指令 示例 含义 特殊说明 MOV MOV EAX,ECX EAX=ECX ADD ADD EAX,ECX EAX+=ECX SUB SUB EAX,ECX EAX-=ECX INC INC EAX EAX++ DEC DEC EAX EAX- - LEA LEA EAX,[ECX+4] EAX=ECX+4 效率比MOV高 CMP CMP EAX,ECX if(EAX==ECX) ZF=1else ZF=0 比较两个值设置0标志位 AND AND EAX,ECX 按位相与，结果送到EAX TEST TEST EAX,EAX if(EAX==0) ZF=1else ZF=0 与AND类似，但结果不送回，只影响标志位常用于测试寄存器是否为空 JZ(JE) JZ 02001000 if(ZF==1)GOTO 02001000 JNZ(JNE) JNZ 02001000 if(ZF==0)GOTO 02001000 JMP JMP 02001000 GOTO 02001000 CALL CALL abc 调用abc PUSH PUSH 000000001 000000001入栈 POP POP EAX 出栈并将获取值存入EAX 寻址方式8086共7种寻址方式： 立即寻址 直接寻址 寄存器寻址 寄存器间接寻址 寄存器相对寻址 基址加变址寻址 相对基址加变址寻址 立即寻址立即寻址方式是指操作数就包含在指令中，它作为指令的一部分，跟在操作码后存放在代码段。这种操作数称为立即数。立即寻址方式主要用于给寄存器或存储单元赋初值的场合。示例：MOV AX, 1234H 直接寻址直接寻址方式是指操作数在存储器中，指令直接包含有操作数的有效地址。操作数一般存放在数据段，所以操作数的地址由DS加上指令中直接给出的16位偏移得到。直接寻址方式用于处理单个存储器变量的情况。它可以实现在64K字节的段内寻找操作数。直接寻址的操作数通常是程序使用的变量。示例：MOV AX,[1234H] (DS为5000H) 寄存器寻址寄存器寻址方式是指操作数在CPU内部的寄存器中，指令中指定寄存器号。如立即寻址方式示例中指令“MOV AX, 1234H”目的操作数采用寄存器寻址。寄存器寻址中16位操作数的寄存器可以有AX、BX、CX、DX、SI、DI、SP和BP等；对于8位操作数，寄存器可以是AL、AH、BL、BH、CL、CH、DL和DH。由于操作数在寄存器中，不需要通过访问存储器来取得操作数，所以采用这种寻址方式的指令执行速度较快。 寄存器间接寻址寄存器间接寻址方式是指操作数在存储器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。如果有效地址在SI、DI和BX中，则以DS段寄存器的内容为段值；如果有效地址在BP中，则以SS段寄存器的内容为段值。注意与寄存器寻址方式的区别，例如指令“MOV [SI],AX”和“MOV SI,AX”的区别。示例：MOV AX,[SI] (DS为5000H,SI为1234H) 寄存器相对寻址寄存器相对寻址方式是指操作数在存储器中，操作数的有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、DI)内容加上指令中给定的8位或16位位移量之和。示例：MOV AX,[DI+1223H] (DS为5000H,DI为3678H) 基址加变址寻址方式基址加变址寻址方式是指操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到。示例：MOV AX,[BX+DI] (DS为5000H,BX为1223H,DI为54H) 相对基址加变址寻址方式相对基址加变址寻址方式是指操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或者16位位移量相加得到。示例：MOV AX,[BX+DI-2] (DS为5000H,BX为1223H,DI为54H) 汇编代码的调试debug命令：1234567debug 1.exe-r，查看、改变寄存器内容-d，查看内存中的内容-e，改写内存中的内容-u，将内存中的机器指令翻译成汇编指令-t， 执行一条机器指令-p，执行int指令]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法03-贪心算法]]></title>
    <url>%2F2017%2Fs03%2F</url>
    <content type="text"><![CDATA[活动安排写出活动安排问题的贪心算法。输入：先输入活动的个数n，然后依次输入每个活动的开始时间si及结束时间fi。如：时间输入格式为：8：30输入为830。注意：所有值都不能随机生成！！！输出：活动的选择向量，即0，1的集合。如： 1 0 1 0 1或（1，0，1，0，1）示例：输入：9 800 1030 900 1130 700 1100 1130 1400 1200 1330 1300 1530 1500 1600 1430 1600 1600 1800输出：1 0 0 0 1 0 1 0 1 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct active&#123; int id,s,f;&#125;;bool cmp(const active &amp;a,const active &amp;b)&#123; return a.f&lt;b.f;&#125;void GreedySelector(int n,active act[],bool a[])&#123; a[act[0].id]=true; int j=0; for(int i=1;i&lt;n;i++) &#123; if(act[i].s&gt;=act[j].f) &#123;a[act[i].id]=true;j=i;&#125; else a[act[i].id]=false; &#125;&#125;int main()&#123; int n; active act[105]; bool a[105]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;act[i].s&gt;&gt;act[i].f; act[i].id=i; &#125; sort(act,act+n,cmp); GreedySelector(n,act,a); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 一般背包写出一般背包问题的贪心算法。输入：先输入物品的个数n，再输入背包的容量c，然后依次输入物品的重量wi，最后依次输入物品的价值vi。注意：所有值都不能随机生成！！！输出：物品的选择向量xi，0=&lt;xi=&lt;1。示例：输入：3 20 18 15 10 25 24 15输出：0.0 1.0 0.5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct good&#123; int id; float w,v,r;&#125;;bool cmp(const good &amp;a,const good &amp;b)&#123; return a.r&gt;b.r;&#125;void fun(float c,float x[],good a[],int n)&#123; int i; for(int i=0;i&lt;n;i++) x[a[i].id]=0; for(i=0;i&lt;n;i++) &#123; if(a[i].w&gt;c) break; x[a[i].id]=1; c=c-a[i].w; &#125; if(i&lt;n) x[a[i].id]=c/a[i].w;&#125;int main()&#123; good a[105]; float x[105]; int n; float c; cin&gt;&gt;n&gt;&gt;c; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i].w; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i].v; a[i].id=i; a[i].r=a[i].v/a[i].w; &#125; sort(a,a+n,cmp); fun(c,x,a,n); for(int i=0;i&lt;n;i++) printf("%.1f ",int(x[i]*10)/10.0);&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法02-动态规划]]></title>
    <url>%2F2017%2Fs02%2F</url>
    <content type="text"><![CDATA[菲波拉契数列写出菲波拉契数列自底向上的非递归动态规划算法或自顶向下的递归动态规划算法（备忘录方法）。输入：输入一个数字。输出：输出为Fibonacci数列的值。示例：输入：5 ，输出：8 Fibonacci数列可以递归地定义为： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;long b[105]=&#123;0&#125;;//备忘录//自底向上的非递归算法int fun(long a[],int n)&#123; int f0,f1,f2; f0=f1=1; if(n==0||n==1) return 1; for(int i=2;i&lt;=n;i++) &#123; f2=f0+f1; f0=f1; f1=f2; &#125; return f2;&#125;//自顶向下备忘录int fun2(int n)&#123; if(b[n]!=0) return b[n]; if(n==0||n==1) b[n]=1; if(n&gt;1) b[n]=fun2(n-1)+fun2(n-2); return b[n];&#125;int main()&#123; int n; long a[105]; cin&gt;&gt;n; cout&lt;&lt;fun(a,n); //cout&lt;&lt;fun2(n); return 0;&#125; 矩阵连乘写出矩阵连乘的自底向上非递归的动态规划算法或自顶向下递归的动态规划算法（备忘录方法）。输入：先输入矩阵连乘的个数n，然后依次手动输入（不能随机生成！）矩阵的维数pi（数字）。注意，6个矩阵，需输7个维数值。输出：矩阵连乘的次序，如：((A1(A2A3))((A4A5A6))。示例：输入：6 30 35 15 5 10 20 25，输出：((A1(A2A3))((A4A5)A6)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;iostream&gt;using namespace std;//自底向上非递归void MatrixChain(int *p,int n,int **m,int **s)&#123; //m[][]最小乘次数 //s[][]最小乘数时的断开点 for(int i=1;i&lt;=n;i++) m[i][i]=0; //单一矩阵的最小乘次都置为0 for(int r=2;r&lt;=n;r++) //r为连乘矩阵的个数 &#123; for(int i=1;i&lt;=n-r+1;i++) //i表示连乘矩阵中的第一个 &#123; int j=i+r-1; //j表示连乘矩阵中的最后一个 //取第一个可取位置，即断开位置为i m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; //循环取k的可取位置 for(int k=i+1;k&lt;j;k++) &#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j]) &#123; m[i][j]=t; s[i][j]=k; &#125; &#125; &#125; &#125;&#125;//构造最优解void Traceback(int i,int j,int **s)&#123; if(i==j) cout&lt;&lt;"A"&lt;&lt;i; else if(i+1==j) //两个矩阵，加括号输出 cout&lt;&lt;"(A"&lt;&lt;i&lt;&lt;"A"&lt;&lt;j&lt;&lt;")"; else &#123; cout&lt;&lt;"("; Traceback(i,s[i][j],s); Traceback(s[i][j]+1,j,s); cout&lt;&lt;")"; &#125;&#125;int main()&#123; int n,*p,**m,**s; cin&gt;&gt;n; //p,m,s初始化 p=new int[n+1]; m=new int*[n]; for(int i=1;i&lt;=n;i++) m[i]=new int[n]; s=new int*[n]; for(int i=1;i&lt;=n;i++) s[i]=new int[n]; for(int i=0;i&lt;n+1;i++) cin&gt;&gt;p[i]; MatrixChain(p,n,m,s); //Look(1,n); //备忘录算法 //Recur(0,n); //直接递归算法 Traceback(1,n,(int**)s); return 0;&#125;//==============我是分隔符==============#include &lt;iostream&gt;using namespace std;//备忘录和直接递归#define N 100int n,m[N][N],s[N][N],p[N+1];//矩阵连乘的最优数乘次数为m[1][n]//备忘录计算最优值（自顶向下递归的动态规划算法）int Look(int i,int j)&#123; if(m[i][j]&gt;0) return m[i][j]; if(i==j) return 0; int u=Look(i,i)+Look(i+1,j)+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++) &#123; int t=Look(i,k)+Look(k+1,j)+p[i-1]*p[k]*p[j]; //递归 if (t&lt;u) &#123; u=t; //从k处断开，分别求得每次的数乘次数 s[i][j]=k; //返回t,k中较小的值，并记录断点处k &#125; &#125; m[i][j]=u; return u;&#125;//直接递归计算最优值int Recur(int i, int j)&#123; if(i==j) return 0; int u=Recur(i,i)+Recur(i+1,j)+p[i-1]*p[i]*p[j]; //递归 s[i][j] = i; for(int k=i+1;k&lt;j;k++) &#123; int t=Recur(i,k)+Recur(k+1,j)+p[i-1]*p[k]*p[j]; //从k处断开，分别求得每次的数乘次数 if (t&lt;u) //返回t,k中较小的值，并记录断点处k &#123; u=t; s[i][j]=k; &#125; &#125; return u;&#125;//输出矩阵结合方式，加括号输出void Traceback(int i,int j)&#123; if(i==j) //只有一个矩阵，直接输出 cout&lt;&lt;"A"&lt;&lt;i; else if(i+1==j) //两个矩阵，加括号输出 cout&lt;&lt;"(A"&lt;&lt;i&lt;&lt;"A"&lt;&lt;j&lt;&lt;")"; else &#123; cout&lt;&lt;"("; Traceback(i,s[i][j]); //递归，从最得到最优解的地方s[i][j]处断开 Traceback(s[i][j]+1,j); cout&lt;&lt;")"; &#125;&#125;int main()&#123; cin&gt;&gt;n; //输入矩阵个数 for(int i=0;i&lt;=n;i++) //输入第一个矩阵行数和第一个到第n个矩阵的列数 cin&gt;&gt;p[i]; Look(1,n); //备忘录算法 //Recur(0,n); //直接递归算法 Traceback(1,n);//输出最优计算次序&#125; 0-1背包写出0-1背包问题的自底向上非递归的动态规划算法。输入：首先输入物品的个数n，然后输入背包的容量c，再依次输入每个物品的重量wi，最后依次输入每个物品的价值vi。注意：所有值都不能随机生成！！！输出：物品的选择向量。如：(1,0,0,1,1)等。示例：输入：4 5 2 1 3 2 12 10 20 15输出：1 1 0 1或（1,1,0,1） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;using namespace std;void knapsack(int v[],int w[],int c,int n,int **m)&#123; int jmax=min(w[n]-1,c); //找出背包容量和最后一个物品重量的最小值 //初始化m[n][j] for(int j=0;j&lt;=jmax;j++) m[n][j]=0; for(int j=w[n];j&lt;=c;j++) m[n][j]=v[n]; //wi&gt;j时，m[i][j]=m[i+1][j] for(int i=n-1;i&gt;=0;i--) &#123; jmax=min(w[i]-1,c); for(int j=0;j&lt;=jmax;j++) m[i][j]=m[i+1][j]; for(int j=w[i];j&lt;=c;j++) m[i][j]=max(m[i+1][j],m[i+1][j-w[i]]+v[i]); //其他做选择 &#125; m[1][c]=m[2][c]; if (c&gt;=w[1]) //只剩下第一个物品时，若剩余背包容积大于w1时，要进行选择 m[1][c]=max(m[1][c],m[2][c-w[1]]+v[1]);&#125;//构造最优解void traceback(int **m,int w[],int c,int n,int x[])&#123; for (int i=0;i&lt;n;i++) if(m[i][c]==m[i+1][c]) x[i]=0; else &#123; x[i]=1; c -= w[i]; &#125; x[n]=(m[n][c])?1:0;&#125;int main()&#123; int v[105]=&#123;0&#125;,w[105]=&#123;0&#125;,x[100]=&#123;0&#125;; int c,n; cin&gt;&gt;n&gt;&gt;c; int **m = new int *[c + 1]; for(int i=0;i&lt;n;i++) cin&gt;&gt;w[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i]; for(int i=0;i&lt;n;i++) m[i]=new int[c+1]; knapsack(v,w,c,n-1,m); traceback(m,w,c,n-1,x); for(int i=0;i&lt;n;i++) cout&lt;&lt;x[i]&lt;&lt;" "; return 0;&#125; 最优二叉搜索树写出最优二叉搜索树的自底向上非递归的动态规划算法。输入：首先输入结点的个数n，再依次输入搜索成功的概率bi，最后依次输入搜索失败的概率aj。注意：所有值都不能随机生成，且只输入整数（概率×100）！！！输出：最优二叉树的结构。示例：输入：5 15 10 5 10 20 5 10 5 5 5 10，输出：S2是根S2的左孩子是S1S2的右孩子是S5S5是根S5的左孩子是S4S4是根S4的左孩子是S3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;using namespace std;//自底向上非递归void OBST(int *a, int *b, int n, int **m, int **s, int **w)&#123; //初始化，构造没有内部节点时的情况 for (int i = 0; i &lt;= n; i++) &#123; w[i + 1][i] = a[i]; m[i + 1][i] = 0; &#125; for (int r = 0; r&lt;n; r++) for (int i = 1; i &lt;= n - r; i++) &#123; int j = i + r; //构造T[i][j] 填写w[i][j],m[i][j],s[i][j] //首选i作为根，其左子树为空，右子树为节点 w[i][j] = w[i][j - 1] + a[j] + b[j]; m[i][j] = m[i + 1][j]; s[i][j] = i; //不选i作为根，设k为其根，则k=i+1，……j //左子树为节点：i,i+1……k-1,右子树为节点：k+1,k+2,……j for (int k = i + 1; k &lt;= j; k++) &#123; int t = m[i][k - 1] + m[k + 1][j]; if (t&lt;m[i][j]) &#123; m[i][j] = t; s[i][j] = k; //根节点元素 &#125; &#125; m[i][j] += w[i][j]; &#125;&#125;//构造最优解void fun(int i, int j, int **s)&#123; if (j&gt;i) &#123; int root = s[i][j]; //根节点 cout &lt;&lt; "s" &lt;&lt; root &lt;&lt; "是根" &lt;&lt; endl; if (s[i][root - 1]&gt;0) cout &lt;&lt; "s" &lt;&lt; root &lt;&lt; "的左孩子是s" &lt;&lt; s[i][root - 1] &lt;&lt; endl; if (s[root + 1][j]&gt;0) cout &lt;&lt; "s" &lt;&lt; root &lt;&lt; "的右孩子是s" &lt;&lt; s[root + 1][j] &lt;&lt; endl; fun(i, root - 1, s); fun(root + 1, j, s); &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; int *a = new int[n + 1]; //成功概率 int *b = new int[n+1]; //失败概率 int **m = new int *[n + 2]; int **w = new int *[n + 2]; int **s = new int *[n + 2]; //最佳节点 for (int i = 0; i &lt; n + 2; i++) &#123; m[i] = new int[n + 2]; w[i] = new int[n + 2]; s[i] = new int[n + 2]; &#125; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt;= n; i++) cin &gt;&gt; a[i]; OBST(a, b, n, m, s, w); fun(1, n, s); //最优解&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法01-分治法]]></title>
    <url>%2F2017%2Fs01%2F</url>
    <content type="text"><![CDATA[Ackerman函数的递归实现算法输入：输入两个数字，先输入n，后输入m。输出：Ackerman函数计算后的值。示例：输入：4 2，输出：16 Ackerman函数A(n，m)定义如下：有两个独立的整型变量m、n： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int Ackerman(int n,int m)&#123; if(n==1&amp;&amp;m==0) return 2; else if(n==0&amp;&amp;m&gt;=0) return 1; else if(n&gt;=2&amp;&amp;m==0) return n+2; else if(n&gt;=1&amp;&amp;m&gt;=1) return Ackerman(Ackerman(n-1,m),m-1);&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;Ackerman(n,m)&lt;&lt;endl; return 0;&#125; 全排列的递归实现算法输入：先输入要求输入的字符的个数，后依次输入（或随机生成）每个字符（不能仅仅是数字）。输出：全排列的结果。示例：输入：3 / * 2，输出：/ * 2 / 2 * * / 2 * 2 / 2 * / 2 / * R的全排列可归纳递归定义如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;void Swap(T &amp;a,T &amp;b)&#123; T t=a;a=b;b=t;&#125;template&lt;class T&gt;void Perm(T a[],int k,int m)&#123; if(k==m) &#123; for(int i=0;i&lt;=m;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; &#125; else for(int i=k;i&lt;=m;i++) &#123; Swap(a[k],a[i]); Perm(a,k+1,m); Swap(a[k],a[i]); &#125;&#125;int main()&#123; int n; char a[105]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; Perm(a,0,n-1); return 0;&#125; 整数划分的递归实现算法输入：输入整数划分的整数（只输入一次，即n==m）。输出：输入整数的划分个数值。示例：输入：7，输出：15 q(n,m)的如下递归关系定义如下：正整数n的划分数p(n)=q(n,n)。12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int q(int n,int m)&#123; if((n&lt;1)||(m&lt;1)) return 0; if((n==1)||(m==1)) return 1; if(n&lt;m) return q(n,n); if(n==m) return q(n,m-1)+1; return q(n,m-1)+q(n-m,m);&#125;int main()&#123; int x; cin&gt;&gt;x; cout&lt;&lt;q(x,x)&lt;&lt;endl; return 0;&#125; 二分搜索的递归实现算法输入：先输入进行二分搜索元素的个数，然后按大小依次输入（或随机生成，然后排序）每个数字，最后输入要求搜索的元素。输出：要求搜索元素的下标（下标从0开始！）。示例：输入：6 1 5 5 9 6 9 6，输出3 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int BinarySearch(int a[],int low,int high,int key)&#123; if (low&lt;=high) &#123; int mid = (low+high)/2; if(key == a[mid]) return mid; else if(key&lt;a[mid]) return BinarySearch(a,low,mid-1,key); else if(key&gt;a[mid]) return BinarySearch(a,mid+1,high,key); &#125; else return -1;&#125;int main()&#123; int a[105],n,x; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); cin&gt;&gt;x; cout&lt;&lt;BinarySearch(a,0,n-1,x)&lt;&lt;endl; return 0;&#125; 合并排序的递归实现算法输入：先输入进行合并排序元素的个数，然后依次随机输入（或随机生成）每个数字。输出：元素排序后的结果，数字之间不加任何标识符。示例：输入：8 11 1 2 4 8 6 15 8，输出：1 2 4 6 8 8 11 15 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int cnt=105;void Merge(int c[],int d[],int left,int mid,int right)&#123; int i=left,j=mid+1,k=left; while((i&lt;=mid)&amp;&amp;(j&lt;=right)) &#123; if(c[i]&lt;=c[j]) d[k++]=c[i++]; else d[k++]=c[j++]; &#125; if(i&gt;mid) for(int q=j;q&lt;=right;q++) d[k++]=c[q]; else for(int q=i;q&lt;=mid;q++) d[k++]=c[q];&#125;void Copy(int a[],int b[],int left,int right)&#123; for(int i=left;i&lt;=right;i++) a[i]=b[i];&#125;void MergeSort(int a[],int left,int right)&#123; int b[cnt]; if(left&lt;right) //至少有2个元素 &#123; int mid=(left+right)/2; //取中点 MergeSort(a,left,mid); MergeSort(a,mid+1,right); Merge(a,b,left,mid,right); //合并两个排好序的数组段到一个新的数组b中 Copy(a,b,left,right); //合并后的b再复制回数组a中 &#125;&#125;int main()&#123; int n,a[cnt]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; MergeSort(a,0,n-1); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 快速排序的递归实现算法输入：先输入进行合并排序元素的个数，然后依次随机输入（或随机生成）每个数字。输出：元素排序后的结果。示例：输入：8 9 1 2 4 8 6 15 8，输出：1 2 4 6 8 8 9 15 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;int Partition(T a[],int p,int r)&#123; int i=p,j=r+1; T x=a[p]; while(1) &#123; while(a[++i]&lt;x&amp;&amp;i&lt;r); while(a[--j]&gt;x); if(i&gt;=j) break; swap(a[i],a[j]); &#125; a[p]=a[j]; a[j]=x; return j;&#125;template &lt;class T&gt;void QuickSort(T a[],int p,int r)&#123; if(p&lt;r) &#123; int q=Partition(a,p,r); QuickSort(a,p,q-1); QuickSort(a,q+1,r); &#125;&#125;int main()&#123; int a[105],n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; QuickSort(a,0,n-1); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC-2017-writeup]]></title>
    <url>%2F2017%2FISCC-2017-writeup%2F</url>
    <content type="text"><![CDATA[BasicWheel Cipher（50）身为二战时期的密码专家，你截获了通信员身上的一段密文、密钥序列和加密列表。你能看懂吗？123456789101112131415ZWAXJGDLUBVIQHKYPNTCRMOSFEKPBELNACZDTRXMJQOYHGVSFUWIBDMAIZVRNSJUWFHTEQGYXPLOCKRPLNDVHGFCUKTEBSXQYIZMJWAOIHFRLABEUOTSGJVDKCPMNZQWXYAMKGHIWPNYCJBFZDRUSLOQXVETGWTHSPYBXIZULVKMRAFDCEONJQNOZUTWDCVRJLXKISEFAPMYGHBQXPLTDSRFHENYVUBMCQWAOIKZGJUDNAJFBOWTGVRSCZQKELMXYIHPMNBVCXZQWERTPOIUYALSKDJFHGLVNCMXZPQOWEIURYTASBKJDFHGJZQAWSXCDERFVBGTYHNUMKILOP密钥为：2，3，7，5，13,12,9，1，8，10，4，11，6密文为：NFQKSEVOQOFNP 其实就是Jefferson disk（杰弗逊圆盘）解密方法：密钥就是转盘的位置，根据密钥排序，轮盘第一轮对应给出的密文。123456789101112132: &lt; N ACZDTRXMJQOYHGVS F UWIKPBEL &lt;3: &lt; F HTEQGYXPLOCKBDMA I ZVRNSJUW &lt;7: &lt; Q GWTHSPYBXIZULVKM R AFDCEONJ&lt;5: &lt; K CPMNZQWXYIHFRLAB E UOTSGJVD &lt;13： S XCDERFVBGTYHNUMK I LOPJZQAW &lt;12： E IURYTASBKJDFHGLV N CMXZPQOW &lt;9: &lt; V UBMCQWAOIKZGJXPL T DSRFHENY &lt;1: &lt; O SFEZWAXJGDLUBVIQ H KYPNTCRM &lt;8: &lt; Q NOZUTWDCVRJLXKIS E FAPMYGHB&lt;10: &lt;O WTGVRSCZQKELMXYI H PUDNAJFB &lt;4: &lt; F CUKTEBSXQYIZMJWA O RPLNDVHG &lt;11： N BVCXZQWERTPOIUYA L SKDJFHGM &lt;6: &lt; P NYCJBFZDRUSLOQXV E TAMKGHIW &lt; 得到flag：FIREINTHEHOLE 告诉你个秘密（100）简单加密12636A56355279427363446C4A49454A7154534230526D684356445A31614342354E326C4B4946467A5769426961453067 十六禁止，先转字符：cjV5RyBscDlJIEJqTSB0RmhCVDZ1aCB5N2lKIFFzWiBiaE0g4的整数倍，base64解码：r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM低头看键盘：tongyuan 神秘图片（100）小明最近参加一个叫共济会的社团，社长一天神秘失踪，在社长电脑桌面上同学们发现一张奇怪的照片，为找到社长，社员们正在努力解密这张照片，可是一直找不到答案，你们发现神秘蛛丝马迹吗? 拿到图，先binwalk，foremost修复得到一张新图，好熟悉，想起了当年玩的刺客信条。 共济会密码（猪圈密码）解出：goodluck 你猜猜（100）我们刚刚拦截了，敌军的文件传输获取一份机密文件，请君速速破解。给了个txt文本：1504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000 504B0304，zip，十六进制保存为zip后，发现加密，而且不是伪加密，ziperello爆破：123456，解压得flag。 附：JPEG (jpg)，文件头：FFD8FFPNG (png)，文件头：89504E47GIF (gif)，文件头：47494638TIFF (tif)，文件头：49492A00Windows Bitmap (bmp)，文件头：424DCAD (dwg)，文件头：41433130Adobe Photoshop (psd)，文件头：38425053Rich Text Format (rtf)，文件头：7B5C727466XML (xml)，文件头：3C3F786D6CHTML (html)，文件头：68746D6C3EEmail [thorough only] (eml)，文件头：44656C69766572792D646174653AOutlook Express (dbx)，文件头：CFAD12FEC5FD746FOutlook (pst)，文件头：2142444EMS Word/Excel (xls.or.doc)，文件头：D0CF11E0MS Access (mdb)，文件头：5374616E64617264204AWordPerfect (wpd)，文件头：FF575043Postscript (eps.or.ps)，文件头：252150532D41646F6265Adobe Acrobat (pdf)，文件头：255044462D312EQuicken (qdf)，文件头：AC9EBD8FWindows Password (pwl)，文件头：E3828596ZIP Archive (zip)，文件头：504B0304RAR Archive (rar)，文件头：52617221Wave (wav)，文件头：57415645AVI (avi)，文件头：41564920Real Audio (ram)，文件头：2E7261FDReal Media (rm)，文件头：2E524D46MPEG (mpg)，文件头：000001BAMPEG (mpg)，文件头：000001B3Quicktime (mov)，文件头：6D6F6F76Windows Media (asf)，文件头：3026B2758E66CF11MIDI (mid)，文件头：4D546864 公邮密码（100）小明的U盘中毒了。病毒把小明的文档压缩并加密。现在小明忘了公邮密码，然而记录密码的文档却被病毒压缩并加密，你能帮助小明解开吗？一个zip加密文件，爆破，得base64加密的flag，解密即可。 说我作弊，需要证据 （100）X老师怀疑一些调皮的学生在一次自动化计算机测试中作弊，他使用抓包工具捕获到了Alice和Bob的通信流量。狡猾的Alice和Bob同学好像使用某些加密方式隐藏通信内容，使得X老师无法破解它，也许你有办法帮助X老师。X老师知道Alice的RSA密钥为(n, e) = (0x53a121a11e36d7a84dde3f5d73cf, 0x10001) (192.168.0.13),Bob的RSA密钥为(n, e) =(0x99122e61dc7bede74711185598c7, 0x10001) (192.168.0.37) 给了个pcapng包，追踪TCP流，得到一些base64编码的字符串。 解码：12345678import base64fo = open("out.txt", "w")with open('tcp.txt') as ft: for line in ft: decoded = base64.b64decode(line) fo.write(decoded+"\n")fo.close() 123456SEQ = 13; DATA = 0x3b04b26a0adada2f67326bb0c5d6L; SIG = 0x2e5ab24f9dc21df406a87de0b3b4L;SEQ = 0; DATA = 0x7492f4ec9001202dcb569df468b4L; SIG = 0xc9107666b1cc040a4fc2e89e3e7L;SEQ = 5; DATA = 0x94d97e04f52c2d6f42f9aacbf0b5L; SIG = 0x1e3b6d4eaf11582e85ead4bf90a9L;SEQ = 4; DATA = 0x2c29150f1e311ef09bc9f06735acL; SIG = 0x1665fb2da761c4de89f27ac80cbL;SEQ = 18; DATA = 0x181901c059de3b0f2d4840ab3aebL; SIG = 0x1b8bdf9468f81ce33a0da2a8bfbeL;...... 可得到SEQ（序列），DATA，SIG（签名）。分析完pcapng包，再来看题中给出的RSA密钥：Alice：(n, e) = (0x53a121a11e36d7a84dde3f5d73cf, 0x10001)Bob：(n, e) =(0x99122e61dc7bede74711185598c7, 0x10001)可见n并不够大，可以分解出p和q，转换十进制后，利用FactorDB。12345678910Alice: n = p * q = 0x53a121a11e36d7a84dde3f5d73cf = 1696206139052948924304948333474767 = 38456719616722997 * 44106885765559411Bob: n = p * q = 0x99122e61dc7bede74711185598c7 = 3104649130901425335933838103517383 = 49662237675630289 * 62515288803124247 下面就可以利用pycrypto解出密文了，注意签名与数据匹配的数据包才被是有效数据。12345678910111213141516171819202122232425262728293031323334353637from Crypto.PublicKey import RSAimport gmpy# Alicen1 = long(1696206139052948924304948333474767)e = long(65537)# Bobn2 = long(3104649130901425335933838103517383)# 分解n得到的p和qp1 = 38456719616722997q1 = 44106885765559411p2 = 49662237675630289q2 = 62515288803124247# 求出解密指数dphi1 = (p1-1)*(q1-1)phi2 = (p2-1)*(q2-1)d1 = long(gmpy.invert(e, phi1))d2 = long(gmpy.invert(e, phi2))# 构建RSArsa1 = RSA.construct( (n1, e, d1) )rsa2 = RSA.construct( (n2, e, d2) )# 利用pcapfile读取转换格式后的pcap包from pcapfile import savefilecf = savefile.load_savefile(open("new.pcap"))output = &#123;&#125;for p in cf.packets: pack = str(p.packet)[136:].decode('hex').decode('base64') if 'DATA' in pack: seq = int(pack.split(';')[0].split(' ')[2]) data = pack[16:].split(';')[0][:-1] sig = long(pack.split(';')[2].split(' = ')[1], 16) m = long(data, 16) decrypted = rsa2.decrypt(m) sigcheck = rsa1.sign(decrypted, '')[0] val = str(hex(decrypted)).strip('0x').rstrip('L').zfill(2).decode('hex') if sig == sigcheck: output[seq] = valprint ''.join(output.values()) 该脚本来源@Hohokiflag{n0th1ng_t0_533_h3r3_m0v3_0n}nothing to see here move on，哈哈，果然是调皮的学生。 PHP_encrypt_1（150）大黑阔在某数据库中提取到了管理员的密码，但是密码是加密的，本要放弃的黑阔突然发现加密竟然是可逆的，网页上的脚本被黑阔提取出来了，你能够帮助黑阔解密吗？黑阔感激不尽加密数据：fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=附件是index.php123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; 根据给出的加密数据和index.php，逆向得：12345678910111213141516171819202122232425&lt;?php $data = &apos;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&apos;; $data = base64_decode($data); $str =&apos;&apos;; $key = md5(&apos;ISCC&apos;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; if(ord($data[$i])&lt;ord($char[$i]))&#123; $str .= chr(ord($data[$i])+128-ord($char[$i])); &#125;else &#123; $str .= chr(ord($data[$i])-ord($char[$i])); &#125; &#125; echo $str;?&gt; 二维码（150）这是一个二维码binwalk得到加密的zip，爆破解压得：C8-E7-D8-E8-E5-88_handshake.cap和破解记录.txt，破解记录里写着：前四位是ISCC 后四位由大写字母和数字构成。简单，crunch制作字典，跑一下就出来了。 WebWeb签到题，来和我换flag啊！（100）Ps：比赛过程中严禁和其他队伍互换flag！！！http://139.129.108.53:3190/web-02/打开后提示“you give me a f1ag，I will give you a flag too”(记不清了，大致这个意思)源代码中一个文本框，一个隐藏文本框，post提交f1ag后，得到提示，再要一个FLAG，ok，提交后，http头部得到flag。 WelcomeToMySQL（150）Welcome to MySQL! SQL inject?http://139.129.108.53:8081/web-01/打开后发现是文件上传，又根据提示SQL注入，很明显上传一句话。尝试了几种上传绕过，发现php5可以，菜刀连接后，在base.php（源码中也有提示）中，找到数据库的相关信息1234567&lt;?php $servername="localhost"; $username="iscc2017"; $password="iscc2017"; $db="flag"; $tb="flag";?&gt; 连接数据库，查到flag。 where is your flag （150）美国大黑阔Jack来窃取小明的flag，看上去确实很简单http://139.129.108.53:6980/web-08/宽字节注入，构造payload后得flag 我们一起来日站（150）老司机发挥所长，利用平时拿站的技巧来解题吧http://139.129.108.53:5090/web-04/根据rebots.txt找到后台登陆地址admin.php万能密码&#39; or &#39;1&#39;=&#39;1直接得flag。 自相矛盾（150）打破常规，毁你三观！http://139.129.108.53:8083/web-09/php弱类型，原题改了个字符串，构造payload：1http://139.129.108.53:8083/web-09/index.php?iscc=&#123;%22bar1%22:%222017e%22,%22bar2%22:[[1],1,2,3,0]&#125;&amp;cat[0]=00isccctf2017&amp;cat[1][]=1111&amp;dog=%00 I have a jpg,i upload a txt.（200）小明发现，php将上传的jpg文件流写入一个txt中，再重命名后缀为jpg还可以正常读取，于是写了一段上传代码，会不会有什么漏洞呢？http://139.129.108.53:3366/web-03 Misc眼见非实（100）附件是docx，改名zip后解压，从/word/document.xml中得flag。 就在其中（150）啊。我好像捕获到了什么不得了的东西。123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXgIBAAKBgQD0UN0A+70iM0VCJ1ni0n/U1BRj0u8yMWH4Qi+xTbjHgbE7wOukOaO+2PyQXiqIzZnf5jCkJuVDYjALGcKrZM4OCQBBd85B/LTc36XZ7JVfX5kGy5tIR3tquuPIVKNdAsHlSqh9S7YSS39RdnSa5rOUyGhrLzxwzzM9IO4e+QQ+CQIDAQABAoGADiaw5mGubtCxbkeBOVYf+V/fXnjVSf76QbrzsD1kOooUjfV6sKR2C5Pd7S7HH+1owENBBgEKvoBtb/cqA2tvU9vQ4l5TMBJcHv6LEcb9WPpnMxPV2GNjO+DTPGPyXnu1UZlZjwx+NaF5rESoSSVS2ZaaIixBs4RWRXk+lHEbTFECQQD6Rp6jMweRgPHOpR3mgIK83zL+kzqYM5isIPv3DIC5JQN2kXqK73IDQCFVlfXnr9lAAVRzLDsAXLqvle/o6yQLAkEA+edY+GERlLuD1t2k9Js0Dc7EwnLcxoFUE60ivj8Gf9jzLskGHxsv0IV6J5OHwPh54kAxAnqCjSqNRAWGNzr+uwJBALYEjDUm1LdGrxXZ0jAkgHC6Z0zsaK3uwHdXGcinqCp+t9EQpq3KzQF+L4AeKxRQONEq5m9I2LQ/vGocwrmD4dcCQQDbrTyOinWz8upAFPKOe2hUwvA/pkzgyosoCMhDyI9kD0gmVlvlODbd7Jem9o8dWM97zcXHUf41LbSkmN6U6m1FAkEAqmZbr35bPfkeoiikwNl6OVQytg12TZjw2vIbvfubf9Rvti8Lh/tbrmhZroiz8/l3aAZmugI1NBcbeZR0gz8ggg==-----END RSA PRIVATE KEY----- 给了个私钥和pcapng包，binwalk提取出一个压缩包，解压得一个加密的key.txt，把私钥保存为private.key，利用openssl解密即可。openssl rsautl -decrypt -in key.txt -inkey private.key -out key_flag.txt 待更]]></content>
      <categories>
        <category>ISCC</category>
      </categories>
      <tags>
        <tag>ISCC</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Metasploit]]></title>
    <url>%2F2017%2Facquaintance-metasploit%2F</url>
    <content type="text"><![CDATA[渗透测试通过模拟恶意攻击者的技术和方法，挫败目标系统安全控制措施，取得访问控制权，并发现具有业务影响后安全隐患的一种安全测试与评估方式。 分类 黑盒测试：模拟一个对客户组织一无所知的攻击者，进行渗透攻击。 白盒测试：攻击者拥有客户组织所有知识的情况下，进行渗透攻击。 黑盒测试（Block-box Testing）也称外部测试（External Testing），从一个远程网络位置来评估目标网络基础设施，完全模拟真实网络中的攻击者，所以比较费时费力，同时需要渗透测试者具备较高的技术能力。 白盒测试（Write-box Testing）也称内部测试（Internal Tesing），可以先了解到目标环境的所有内部与底知识，以最小的代价发现和验证系统中最严重的安全漏洞。如果实施到位，比黑盒测试消除更多目标环境中漏洞与弱点。但白盒测试最大问题在于无法有效的测试客户组织的应急响应程序，也无法判断他们安全防护计划对监测特定攻击的效率。 灰盒测试（Grey-box Testing）以上两种方式的组合，渗透者能根据目标系统所掌握的有限知识与信息，来选择评估整体安全性的最佳途径。测试中，也需要从外部逐步渗透进入目标网络，但他所拥有的目标网络底层拓扑与架构有助于更好的决策攻击途径与方法。 规范测试的流程 前期交互阶段确定渗透测试的范围、目标、限制条件以及服务合同细节。 情报搜集阶段获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。方法：公开来源信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。 威胁建模阶段针对获取的信息进行威胁建模与攻击规划。目标：从大量的信息情报中理清头绪，确定出最可行的攻击通道。 漏洞分析阶段考虑该如何取得目标系统的访问控制权。操作：通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。可以针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘。 渗透攻击阶段利用所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。 后渗透攻击阶段渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。 报告阶段一份凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程、造成业务影响后果的攻击途径以及站在防御者的角度帮助他们分析安全防御体系中的薄弱环节、存在的问题和修补升级技术方案的报告。 Metasploit体系框架 基础库文件源码在根目录下的libraries目录中，包括Rex、framework-core、framework-base三部分。 Rex：整个Metasploit框架所依赖的最基础的一些组件，如：包装的网络套接字、网络应用协议客户端与服务端实现、日志子系统、渗透攻击支持例程、PostgreSQL及MySQL数据库支持等。 framework-core库负责实现所有与各种类型的上层模块及插件的交互接口。 framework-base库扩展了framework-core，提供更加简单的包装例程，并为处理框架各个方面的功能提供一些功能类，用于支持用户接口与功能程序调用框架本身功能及框架继承模块。 模块按用途分为：辅助模块（Aux）、渗透攻击模块（Exploits）、后渗透攻击模块（Post）、攻击载荷模块（Payloads）、空指令模块（Nops）和编译器模块（Encoders）。 插件扩充框架功能，或者组装已有功能构成高级特性的组件。还可集成现有的一些外部安全工具，如Nessus、OpenVAS漏洞扫描器等，为用户接口提供一些新的功能命令、记录所有的网络记录或提供创新的渗透测试功能。 接口msfconsole控制台终端、msfcli命令行、msfgui图形化界面、armitage图形化界面及msfapi远程调用接口等 功能程序除了框架主功能之外，还提供一系列可直接运行的功能程序，如msfpayload、msfencode和msfvenom可将攻击载荷封装为可执行文件、C语言、JavaScript语言等，并进行各种类型的编码。msf*scan系列提供在PE、ELF等各种类型文件中搜索特定指令的功能，帮助定位指令地址。 模块详解辅助模块（Aux）帮助渗透测试之前得到目标系统丰富的情报信息，从而更具目标性的精准攻击 渗透攻击模块（Exploits）发现漏洞或配置弱点进行攻击，以植入和运行攻击载荷，从而获得访问权。其按照漏洞所在位置分为主动渗透攻击和被动渗透攻击。 主动渗透攻击漏洞位于网络服务端软件与服务承载的上层应用程序之中。服务端通常开启一些监听端口等待客户端连接，针对它们的渗透攻击可以主动发出。 被动渗透攻击漏洞位于客户端软件中，对于客户端软件的安全漏洞，渗透者无法主动的将数据从远程输入到客户端软件中，因此采用被动渗透攻击。 利用网络欺骗、劫持等各种技术，欺骗目标打开恶意内容的服务器、邮件附件等，从而触发客户端软件的安全漏洞。 被动渗透可绕过防火强等网络边界防护措施。 最常见的两类被动渗透：浏览器软件漏洞攻击、文件格式类漏洞攻击。 攻击载荷模块（Payloads）攻击载荷：渗透攻击成功后促使目标系统执行一段植入代码。通常作用为打开目标系统上的控制会话连接。该模块分为3类：独立（Singles），传输器（Stager），传输体（Stage）。独立攻击载荷。 独立攻击载荷是完全自包含的，可直接独立地植入目标系统进行执行。 在一些特殊的渗透攻击场景中，可能会对攻击载荷的大小、运行条件有所限制，利用传输器和传输体配对分阶段植入的技术，由渗透攻击模块首先植入代码精悍短小且非常可靠的传输器载荷，然后在运行传输器载荷时进一步下载传输体载荷并执行。 空指令模块（NOP）对程序运行状态不会造成任何实质影响的空操作或无关操作指令。如空操作，x86 CPU体系构架平台上的操作码是0x90。 在渗透攻击构造数据缓冲区时，在真正要执行的Shellcode之前添加一段空指令区，当触发渗透攻击后跳转执行Shellcode时，有较大的安全着陆区，从而避免受到内存地址随机化、返回地址计算偏差等原因造成的Shellcode执行失败。 编译器模块（Encoders）攻击载荷模块（Payloads）与空指令模块（NOP）组装完成一个指令序列后，进行编码（Encoding）。 编译器模块的使命： 确保渗透过程中，攻击载荷不会出现难以加载的“坏字符”，如：0x00空字节，字符串操作函数中输入字符串中的空字节，会将后面内容截断，攻击载荷无法完整运行；网络输入使用明文协议，那么攻击载荷的内容都是可打印字符。 对攻击载荷进行免杀，逃避反病毒软件、IDS入侵检测系统和IPS入侵防御系统的检测和阻断。 注意：编码后，载荷体积增大，而每个渗透攻击模块能植入的邪恶缓冲区大小受漏洞触发条件限制（通常在渗透攻击模块的Space字段中指明），所以自动编码会找不到合适的编码器（编码后大小溢出），“No encoders encoded the buffer successfully”。此时，就要选择一个传输器和传输体配对构成的攻击载荷，以短小精悍的传输器避免编码后超出空间限制，再运行传输器载荷就不受空间大小约束了。 后渗透攻击模块（Post）v4版本中的新模块，主要在取得目标控制权后进行的各种攻击，如获取敏感信息、进一步拓展、实施跳板攻击等。其中最强大的是Meterperter模块。 Metasploit的使用接口 msfgui图形化管理界面 msfconsole控制台终端 msfcli命令行程序控制台终端的优势 访问框架中每一项功能，并能直接执行外部shell命令和第三方（Nmap等）。 更新及时，最稳定的Metasploit用户接口。 输入help xxx显示该命令的参数列表。 msfcli命令行程序为脚本自动化处理及与其他命令行工具互操作而设计的一种用户接口。相对于msf终端，弱点在于支持的功能特性少以及不支持MSF终端中的高级自动化渗透测试特性。]]></content>
      <categories>
        <category>metasploit</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RIP协议]]></title>
    <url>%2F2017%2FRIP%2F</url>
    <content type="text"><![CDATA[RIP协议RIP是一种基于距离矢量（distance-vector）的路由协议，以路由跳数(hop)作为计数单位的路由协议。适合用于比较小型的网络环境。 使用距离矢量来决定最优路径 跳数（hop count）：一个报文从本节点到目的节点中途经的中转次数，也就是一个包到达目标所必须经过的路由器的数目。 下一跳（next hop）：本网上的报文欲通过本网络节点到达目的节点，如不能直接送达，则本节点应把此报文送到某个中转站点，此中转站点称为下一跳。 跳（hop） ：报文转发的中转过程。 RIP特点原理和配置方法均简单，但有时不能准确地选择最优路径，收敛的时间也较长。 最多支持的跳数为15 ，跳数16表示不可达 跳数最小即为最优路由，跳数相同则为等代价路由 使用UDP 520端口交换路由信息 周期性更新，路由更新为完整的路由表 路由信息每经过一个路由器，跳数加1 使用多个时钟以保证路由的有效性与及时性 RIP工作过程和计时器工作过程 路由器初始的路由表中只有自己的直连路由，路由器A的更新周期首先到达（更新计时器：30s），路由器B收到A发出的路由更新，将1.0.0.0加入路由表，跳数为1。随后，路由器B的更新周期到达，路由器A和C收到B发出的路由更新。接着，路由器C到达更新周期，路由器B收到路由更新，刷新路由表，并在更新周期到来时发送新的路由更新。随着这个过程的不断重复，所有路由器都学习到了全部的路由——收敛完毕。 计时器 更新计时器30s（为了防止同时更新，叠加一个随机变量，一般为5s之内） 无效计时器180s，6倍更新时间内未收到更新，该路由被标记为16跳（不可达） 刷新计时器120s，无效路由在刷新计时器时间内仍未被更新，则被删除 思维导图 路由更新原则 直连路由的可信度最高。不会被更新。 本路由表已有的路由表项，当下一跳不同时，只有度量值减小才更新该路由表项。 对本路由表已有的路由表项，当下一跳相同时，不论度量值增大还是减少，都更新该路由表项。 路由环路路由毒化（更新规则3可能会导致路由毒化，从而形成路由环路）使用无穷大的度量（16跳）传播关于路由失效的坏消息 。 防止路由环路 水平分割路由器记住每一条路由信息的来源，并且不在收到这条信息的端口上再次发送它。这是保证不产生路由环路的最基本措施。 触发更新在改变一条路由度量时立即广播一条更新消息，而不管30秒更新计时器还剩多少时间 毒性逆转当路由器学习到一条毒化路由（度量值为16）时，对这条路由忽略水平分割的规则，并通告毒化的路由。 C失去网段4.0.0.0/8，立即发送一个触发的部分更新，仅包含变化的信息，即4.0.0.0/8的毒化路由。B相应这个更新，修改自己的路由表，并立即会送（触发）包含4.0.0.0/8、度量值为16的更新，这就是毒性逆转。到C的下一个更新周期，它会通过所有路由，包括4.0.0.0/8的毒化路由；同样，B到达下一个更新周期时，也是如此。C通告的毒化路由不被认为时毒性逆转路由，因为它本来就应当通告这条路由；而B通告的毒化路由则被认为时毒性逆转路由，因为它把这条路由又通告给力C，这条失效路由原本就是从那里学习到的。 抑制计数器水平分割在环形拓扑（即存在冗余链路构成的环路）中水平分割不能很好的预防计数到无穷大的问题。B先收到4.0.0.0/8的毒化路由的部分更新，修改度量值为16，然后可能会收到C发出的周期性更新，里面声明到达4.0.0.0/8的度量值为2，结果再把度量值更新为2，下一跳为路由器C。 此时，C收到A的触发更新，度量值改16，但在C到达下一个更新周期时，B向A发送一个周期更新，度量值改3，之后C的周期性更新才到达，B更改度量值为16。 这样的过程不断循环，最终还是导致了计数到无穷大。 这时需要另一个防止路由环路的方法，抑制及时器（一般是180s）。一条路由信息失效后，便处于抑制状态，在抑制时间内，失效的路由不接受任何更新信息（除非这条信息是从原始通告这条路由的路由器来的），以确保每台路由器都学习到这个信息。抑制计时器减少了路由的浮动，增加了网络的稳定性。 RIPv1 &amp; RIPv2RIPv1 使用广播的方式发送路由更新 路由更新信息中不携带子网掩码，为有类路由协议 RIP报文大小限制是512字节，最多可以携带25条路由信息 RIPv2 RIPv2发送更新报文的方式为组播，组播地址为224.0.0.9 路由信息中加入了子网掩码，无类的路由协议 支持认证 RIPv1和RIPv2比较 特性 RIPV1 RIPV2 采用跳数为度量值 是 是 15是最大的有效度量值，16为无穷大 是 是 默认30s更新周期 是 是 周期性更新时发送全部路由信息 是 是 拓扑改变时发送只针对变化的触发更新 是 是 使用路由毒化、水平分割、毒性逆转 是 是 使用抑制计时器 是 是 发送更新的方式 广播 组播 使用UDP 520端口发送报文 是 是 更新中携带子网掩码，支持VLSM 否 是 支持认证 否 是 配置RIP常用命令 创建RIP进程Router(config)# router rip 定义关联网络Router(config-router)# network network-number关联网络有两层意思： RIP 只对外通告关联网络的路由信息 RIP 只向关联网络所属接口通告路由信息 network 需要有类网络号（无子网掩码），如果使用子网号或IP地址，路由器会自动修改为ABC三类网络号。 定义RIP版本Router(config-router)# version {1|2}默认1 关闭RIPv2自动汇总Router(config-router)# no auto-summary路由自动汇总：当子网路由穿越有类网络边界时，将自动汇总成有类网络路由。RIPv2 缺省情况下将进行路由自动汇聚，RIPv1 不支持该功能。 调整RIP时钟Router(config-router)# timers basci update invalid flush默认更新30s，无效时间180s，刷新120s。调整可能会加快路由协议的收敛时间以及故障恢复时间。注意：同一网络上的设备，RIP时钟值一定要一致。 关闭水平分割Router(config-if)# no ip split-horizon 示例 1234RouterA(config)#router ripRouterA(config-router)#network 1.0.0.0RouterA(config-router)#network 2.0.0.0RouterA(config-router)#end 配置单播更新和被动接口 RIP被动接口：RIP路由器的某个端口仅仅学习RIP路由，并不进行RIP路由通告(非RIP请求仍会相应)Router(config-router)#passive-interface {default | interface-type interface-num} RIP报文单播更新 ：RIP路由信息需要通过非广播网络传输，或需要限制一个接口通告广播式的路由更新报文Router(config-router)# neighbor ip-address 示例：实现A发出的更新报文只能被B接受，而不被C接受。1234RouterA(config)#router ripRouterA(config-router)#passive-interface fastEthernet 0/0RouterA(config-router)#neighbor 4.0.0.2RouterA(config-router)#end debug 命令进行排错 debug命令让路由器执行以下： 监视内部过程（例如RIP发送和接收的更新） 当某些进程发生一些事件后，产生日志信息 持续产生日志信息，直到用no debug命令关闭 Debug命令可用于观察RIP的内部工作过程，以便发现存在的问题。调试排错结束后，应当关闭debug。no debug ip ripno debug all 小结 更新计时器、无效计时器和刷新计时器RIP协议中，路由接口将周期性地发送全部路由更新，更新计时器（Update Timer）为30s；成功建立一条RIP路由条目后，加上一个180s（6倍的更新时间）的无效计时器（InvalidTimer），180s后未收到针对该路由的更新，则把该路由的度量值标记为16跳，表示不可达，但并不从路由表中删除。标记后，RIP路由立即启动刷新计时器（Flush Timer，也称为清除计时器），120s，超时后，删除。 计数到无穷大的情况存在路由环路（逻辑环路或者物理环路）,导致路由器互相之间不断发送针对同一条失效路由的错误更新，每发一次，top+1，直到无穷大。 防止路由环路的技术 路由毒化：当一条路径信息变为无效之后，路由器并不立即将它从路由表中删除，而是用 16，即不可达的度量值将它广播出去。 水平分割：路由器将记住每一条路由信息的来源，并且不在收到这条信息的端口上再次发送它。这是保证不产生路由循环的最基本措施。 毒性逆转：当路由器收到一条毒化路由后，立即将这条毒化路由以触发更新的方式通告出去，并不再遵循水平分割的原则，也就是同样会通告给初始发送这条路由的路由器。 触发更新：当路由表发生变化时，更新报文立即广播给相邻的所有路由器，而不是等待30 秒的更新周期。这样，网络拓扑的变化会最快地在网络上传播开，减少了路由循环产生的可能性。 抑制计时：一条路由信息无效之后，一段时间内这条路由都处于抑制状态，即在一定时间内不再接收关于同一目的地址的路由更新。 如果， 路由器从一个网段上得知一条路径失效，然后，立即在另一个网段上得知这个路由有效。这个有效的信息往往是不正确的，抑制计时避免了这个问题，而且，当一条链路频繁起停时，抑制计时减少了路由的浮动，增加了网络的稳定性。 RIPv1 和 和 V2 的区别上表总结的有 network命令作用定义关联网络，关联网络有两层意思：RIP 只对外通告关联网络的路由信息；RIP 只向关联网络所属接口通告路由信息。即：network 命令告诉路由器哪个接口开始使用 RIP，然后从这个接口发送路由更新，通告这个接口直连的网络，并从这个接口监听从其他路由器发来的 RIP 更新。]]></content>
      <categories>
        <category>路由与交换</category>
      </categories>
      <tags>
        <tag>路由</tag>
        <tag>RIP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由技术]]></title>
    <url>%2F2017%2FRouting-technology%2F</url>
    <content type="text"><![CDATA[路由概念指导IP报文发送的路径信息。 选路路由器中保存着一张路由表，表中每条路由项都致命数据到某个子网应通过路由器的哪个物理接口发送出去。 路由选择表中保存的信息路由选择表中的每一个表项至少要包括目标地址和下一跳路由器的地址， 或表明目标地址是直接相连的。 路由器功能 网络互联：主要用于互联局域网和广域网 数据处理：分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等。 网络管理：配置管理、性能管理、容错管理、流量控制等。 接口 Console：控制台口，初始化配置 AUX：异步接口，主要用于远程配置，也可用于拨号连接，还可通过收发器与MODEM进行连接，支持硬件流控制。 RJ-45接口：最常见的双绞线以太网接口。 RJ-45，根据接口的通信速率不同，TJ-45接口又可分为10Base-T（RJ-45）接口、100Base-TX（RJ-45）、100Base-T3类等。 SIC模块：4接口100Base-T快速以太网交换接口卡（SIC-4ESW）。1接口通道化E1接口卡（SIC-1CE1）。1接口非通道化E1接口卡（SIC-1E1-F）。1接口高速同步串口接口卡（SIC-1HS）。1接口高速异步串口接口卡（SIC-1A）。8接口高速异步串口接口卡（SIC-8A）。1接口ISDN基本速率U接口卡（SIC-1B-U）。1接口ISDN基本速率S/T接口卡（SIC-1B-S/T）。2接口FXS语音接口卡（SIC-2FXS）。2接口FXO语音接口卡（SIC-2FXO）。 路由的访问方式 带外管理（Console口） Telnet Web SNMP管理工作站 静态路由、默认路由、浮动路由 静态路由网络管理员手工配置的路由信息 默认静态路由路由表中未直接列出目标网络的路由选择项，用于在不明确的情况下指示数据帧下一跳的方向。 浮动静态路由浮动静态路由是到达目标地址的备用路由，它的管理距离被设得更高，这样只有当别的优先级高的路由均不可用时，它才被启用。 路由协议 路由协议通过共享路由选择信息的机制来支持被动路由协议。 路由协议作用维护路由信息，建立路由表，决定最佳路径。 路由选择协议通俗的说，路由选择协议就是路由器之间所讲的一种语言，用来共享网络目标地址的信息。 所有的路由协议都围绕着一个算法构建的，因此对于所有路由选择协议来说，共有的几个问题是路径决策、度量、收敛和负载均衡 路径决策根据路由表中的信息，选择一条最佳的路径，将数据转发出去。 度量路由的度量值，也叫路由代价或路由距离，用来决定到达一个目的的最佳路径，最佳路径所使用的度量值类型定义。 收敛使所有路由选择表都达到一致状态的过程。 收敛时间一级路由器所花费用来完成路由信息交换的时间。 一个网络的收敛速度越快，说明路由选择协议越好。 动态路由通过路由信息的交换生成并维护转发引擎所需的路由表。当网络拓扑结构改变时动态路由协议可以自动更新路由表，并负责决定数据传输最佳路径。 动态路由协议按运行的区域范围划分： 内部网关协议（Interior Gateway Protocol，IGP）：同一自制系统内部交换路由信息。 外部网关协议（Exterior Gateway Protocol，EGP）：不同自制系统间交换路由信息。 IGP内根据路由选择协议算法不同划分如下： 距离矢量（DiStance Vector） 链路状态（Link-state） 混合算法（Hybird） 1234567891011graph LRA[动态路由协议] --- B[IGP]A --- C[EGP]B --- D[距离矢量路由选择协议]B --- E[链路状态路由选择协议]B --- F[混合算法]D --- G[RIP]D --- H[IGRP,cisco私有协议]E --- I[OSPF]E --- J[IS-IS]F --- K[EIGRP,cisco私有协议] RIP路由协议OSPF路由协议 动态与静态的区别静态路由：无开销，配置简单，需要人工维护，适合简单拓扑结构的网络；动态路由协议：开销大，配置复杂，无需人工维护，适合复杂拓扑结构的网络 有类路由协议与无类路由协议有类路由协议有类的路由不会识别子网的信息,如宣告10.0.1.0/24 172.16.1.0/22 192.168.1.64/28 路由表中只会识别A类10.0.0.0/8,B类172.16.0.0/16 C类192.168.1.0/24。 使用协议：RIPV1 IGRP（cisco私有协议）有类的路由协议只会传送网络前缀（网络地址），但是不会包含子网掩码。当它传送更新时，它首先检查直接连接的网络是否和发送更新的网络属于同一个大一点的子网，如果是的，那么它会继续检查它们的子网掩码是否相等，如果不等，那么更新信息会被丢弃而不会被广播。 无类路由协议无类的路由协议不会根据A B C类来识别,根据子网掩码的长度来区分网段,所以说无类的路由协议都可以不支持路由自动汇总。 使用协议：RIPV2、EIGRP（cisco私有协议）、OSPF、IS-IS等。路由控制包里面除了IP地址，还必须包含一个掩码与其匹配。掩码的作用是划分出网络ID和主机ID，这样的划分更灵活多变。 特点 是否支持变长子网掩码（VLSM） 是否支持不连续的子网。 在路由器宣告时是否带有子网掩码。 有类：不支持；无类：支持。]]></content>
      <categories>
        <category>路由与交换</category>
      </categories>
      <tags>
        <tag>路由</tag>
        <tag>静态路由</tag>
        <tag>动态路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类]]></title>
    <url>%2F2017%2Fclass%2F</url>
    <content type="text"><![CDATA[类 类是对象共性的抽象 是对象的模板 是客观对象在人脑中的主观反应，人对对象的一种认知 类是主观的认知，对象是客观存在的 属性属性：实例变量（定义的位置：类中）特点： 有默认值：数值：各种零 布尔类型：false 对象类型：null 作用范围：至少是全类内部（位置灵活） 可以和局部变量发生命名冲突，冲突的时候局部变量优先 方法 方法的声明：代表对象能做什么 方法的实现：代表怎么做方法的声明构成：修饰符 返回值类型 方法名 （参数列表） 抛出的异常 以上5个部分顺序严格，不能交换 一个方法可以没有修饰符 一个方法的修饰符可以又多个，修饰符没有顺序要求 方法重载方法重载overload 方法覆盖：override允许定义多个同名的方法，参数表不同（是面向对象中特有的性质） 参数列表不同 方法参数的个数 方法参数的类型不同 方法参数的顺序不同 形参类型相同，名称不同不算重载 形参类型相同，顺序不同不算重载调用方法的时候通过参数列表不同来区分 挑选的过程：编译器在编译的时候根据参数列表，选择一个合适的方法方法重载又称之为：编译时多态原则：就近向上匹配（避免混淆） 方法重载的作用一个对象的同类方法，由于参数列表的不同，所造成的差异，对用户屏蔽System.out.println(字符串，数字，字符，布尔类型); 构造方法 没有返回值类型 方法名必须和类名相同 不允许手工调用，在对象构造的过程中自动调用一次如果一个类没有构造方法，系统会默认添加一个无参的构造方法如果一个类有构造方法，系统不会添加默认构造方法（手动补充一个无参的构造方法） 构造方法中的参数称之为：构造参数 对象的创建过程 分配空间，将所有的实例变量赋予默认值 初始化属性：将所有的实例变量初始化（第二次赋值） 调用构造方法：实例变量将被第三次赋值 构造方法常用来赋值 如何创建一个对象关键字：new构造对象：Student s1=new Student();Student s2=new Student(构造参数);查看属性：变量名.属性名查看方法：变量名.方法名（参数） 引用数据分类：简单类型，对象类型变量分类：简单变量，对象变量（引用）变量按照类型划分：简单变量：存的是值对象变量：存对象的地址 java中参数的传递规则：简单类型传数据（值）对象类型传递的是地址，引用，多个变量指向是同一个对象 thisthis 表示的是一个引用，指向当前对象 当实例变量和局部变量命名冲突的时候，用this来区分实例变量和局部变量 常用语构造方法中 参与构造方法中的赋值（在有参构造方法中给属性赋值） 调用本类中的其他构造方法（this（构造参数））构造方法中，只能调用一次其他构造方法，并且必须是构造方法中的第一句]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2017%2FObject-Oriented%2F</url>
    <content type="text"><![CDATA[面向对象 面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术[1] 发展到一定阶段后的产物。 ——百度百科 核心：实现了面向对象的核心思想 编程思想：需求==》建立思路==》目标代码 面向过程的编程思想哥德巴赫猜想： 让用户输入一个数 1).是不是大于6 2).是不是偶数 3).是不是数 对输入的数拆分 分别验证是不是质数 自顶向下逐步求精将一个程序打散成n多个小程序，再将程序进一步细化，直到整理出最终代码为止 独立过程哥德巴赫猜想：n=a+b;判断a和b的过程，是独立的，相互之间互不影响 函数是对抽取出来的独立的过程的封装 淘宝：1.登陆浏览器2.登陆3.验证用户合法性4.浏览商品5.添加购物车6.下订单7.填写收货地址。。。。。。不适用于多过程的复杂需求 第一个面向对象的编程语言：SmallTalkC语言==》C++加入了面向对象的思想面向对象的革命：Java（纯面向对象的语言） 对象万物皆对象：一切客观存在的事物唯物主义哲学思想例如：显示屏，桌椅板凳，错误（客观存在） 对象 1.有什么：属性 2.能干什么：方法 例如： 电脑： 有什么：显示器，鼠标，键盘，主机。。。 能做什么：上网，打游戏，学习。。。除了属性和方法之外没有我们需要关注的东西。 对象的属性 对象的属性可能又是一个对象 对象的方法 对象的方法的使用者，一定也是一个对象，（这个对象可能是别的对象，也可能是自己） 客观世界是由对象组成 小对象组成大对象（小对象作为大对象的属性而存在） 对象的方法彼此间相互调用 如何建立解题思路 例如：校外实训：郑州==》北京 找对象 有交通运输的方法（小黄车，摩拜单车，摩的，汽车，高铁，飞机） 找方法 调用交通工具的运输方法 解决客观问题的方法 把解决问题所需要的对象准备好 考虑对象之间如何配合，完成需求 小结 面向过程的编程思想：自顶向下，逐步求精（适合于解决简单问题） 面向对象的编程思想：找到合适的对象是第一位，需要什么方法是第二位 面向对象在计算机领域中的使用计算机需求，来源于客观世界把客观世界的需求，用计算机来实现 例如：京东：需求：在人类社会中，有人买东西，有人卖东西解决：利用了计算机网络，解决人和人之间的交易行为（没有计算，这样的需求依旧存在） QQ：需求：人与人之间有交流的需求解决：利用计算机解决用计算机解决问题：用面向对象的思想解决，和现实世界高度统一（生活中怎么解决这个问题，用计算就怎么解决） 计算机中的对象 在JVM中一块连续的存储空间（数据，代表生活中的对象）例如：学生管理系统： 人工：建立档案册，记录学生信息（管理的对象：学生，有血有肉的人） 计算机：建立档案册，记录学生信息（管理的对象：计算机在存储空间中表示的学生，其属性是需要的属性） 小结面向对象的思想为解决生活中的问题提供了思路，应对复杂的需求一个系统，越接近生活，越是合理（生活是最合理的） 各司其职，对象应该保持简单性 弱耦合性，对象和对象之间的联系，尽量弱化 可重用性，创建对象下一次可以拿来直接用 可扩展性，在原有的功能基础之上曾加新功能 oop面向对象的编程思想Object Oriented Programming 面向对象的语法：编译通过 面向对象的思想：要按照以上4点纲领 面向对象的三大特性封装，继承，多态（三大基石） 封装 定义封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 封装把对象的所有组成部分组合在一起，定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。 特点对象会有明确的边界，保护对象中的属性‐‐‐‐数据隐藏封装的粒度（不宜过大，也不宜过小）public 公开的，不受边界的控制private 私有的，只能在本类中使用，无法突破边界（提供对应的get/set方法）好处：提供约束，设置只读性方法私有：private 返回值类型 方法名（参数列表）方法公开：声明公开，实现隐藏（在声明不变的情况下，如果实现改变，对架构的影响最小） 继承父类‐‐子类（有继承关系） 父类把子类的共性抽取出来关键字：extendsclass 子类 extends 父类{} 特点 子类可以继承父类中的方法和属性 可扩展性（子类，重用父类中的方法） 本质Animal‐‐Dog创建过程：先创建父类对象，后创建子类对象，父类对象作为子类对象的的一部分访问修饰符：从严到宽private 私有的 本类内部（不能被继承）default 默认的 本类内部+同包可以访问+同包子类（可能被继承）protected 受保护的 同包+不同包子类public 公开的 全能访问 构造方法不能被继承 方法覆盖子类用特殊的方法实现，替换了父类中的一般方法实现语法要求： 返回类型，方法名，参数列表和父类相同（参数列表变化，就是重载） 访问修饰符：相同，或者更宽 不能抛出比父类更多的异常 对象构造的过程 分配空间：本类和父类一并分配空间，所有的属性被赋予默认值 递归的构造父类对象（初始化分类的属性，调用父类的构造方法） 初始化属性 调用构造方法 super 在构造方法中指定调用父类的哪一个构造方法 必须在构造方法的第一个语句 如果一个构造方法的第一句，不指定this也不指定super 系统默认添加super（）； 表示父类对象，区分父类被遮盖的属性，或者调用父类被覆盖的方法 小结系统默认添加：构造方法第一行：super（）；没有写构造方法：公开的无参构造每个程序：import java.lang.*;super常常用来把构造参数传递给父类 JAVA继承的分类继承分为单继承和多重继承。单继承是指一个子类最多只能有一个父类。多继承是一个子类可以有二个以上的父类。由于多继承会带来二义性，在实际应用中应尽量使用单继承。Java语言中的类只支持单继承，而接口支持多继承。Java中多继承的功能是通过接口（interface）来间接实现的。 一个类最多只能有一个直接父类，这点和C++不同！ 多态编译时多态（方法重载） 运行时多态（引用多态） 子类对象可以看成是父类对象（继承关系合理） 父类引用指向子类对象 多态规则： 对象类型不变 只能调用引用类型中所声明的方法 发生了方法覆盖，调用覆盖后的方法 引用之间的传递 子类对象的引用可以直接赋值给父类引用 父类引用给子类引用赋值，需要强制类型转换 在强制类型转换之前要用instanceof 判断，避免类型转换异常引用 instanceof 类名 （表示：引用是否和类名相互兼容） 多态作用将多个对象统一看做是同一个父类对象，屏蔽子类之间的差异，增加程序的灵活性和通用性。 多态的方法 方法声明中的形参可以用父类引用来表示，实参用子类对象来传输 用父类作为返回值类型]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle存储管理2]]></title>
    <url>%2F2017%2FOracle-store-management-2%2F</url>
    <content type="text"><![CDATA[Oracle存储管理1表空间管理 回滚段管理回滚段来实现未提交数据或因系统故障导致实例崩溃时进行回滚操作，每一个表空间需要创建回滚段，各个表空间对回滚段实现各自的管理 查看回滚段信息使用视图DBA_SEGMENTS可以查看当前数据库中所有段的信息。回滚段的类型（SEGMENT_TYPE）值为ROLLBACK。123COL 回滚段名 FOR A20SELECT SEGMENT_NAME 回滚段名, TABLESPACE_NAME 所在表空间, BYTES 大小FROM DBA_SEGMENTS WHERE SEGMENT_TYPE='ROLLBACK'; 查看回滚段的当前工作情况 ：1234COL NAME FOR A12SELECT s.USN, n.NAME, s.EXTENTS, s.RSSIZE, s.STATUS FROM V$ROLLSTAT s, V$ROLLNAME nWHERE s.USN=n.USN; 查看和设置回滚段的管理模式 Oracle数据库可以自动管理回滚段，也可以由用户来手动管理。 使用初始化参数UNDO_MANAGEMENT可以设置管理回滚段的方式。 查看UNDO_MANAGEMENT参数的值：SHOW PARAMETER UNDO_MANAGEMENT 将回滚段管理方式设置为手动管理：ALTER SYSTEM SET UNDO_MANAGEMENT=MANUAL SCOPE=SPFILE;SCOPE=SPFILE表示对初始化参数的修改应用于SPFILE，需要重新启动数据库实例才能生效。 创建回滚段123CREATE [PUBLIC] ROLLBACK SEGMENT 回滚段名称 TABLESPACE所属表空间名称STORAGE 存储选项 示例：为表空间OrclTBS01创建回滚段OrclRs0112345CREATE ROLLBACK SEGMENT OrclRs01TABLESPACE UndoTBS1STORAGE (INITIAL 5M NEXT 2M MAXEXTENTS UNLIMITED); 修改回滚段的属性 修改回滚段的在线状态ALTER ROLLBACK SEGMENT 回滚段名称 回滚段状态状态：ONLINE（联机）和OFFLINE（脱机），新建回滚段的状态为ONLINE。 手动收缩回滚段如果在创建回滚段时指定的初始大小（INITIAL参数）过大，可以手动收缩回滚段的大小。ALTER ROLLBACK SEGMENT 回滚段名称 SHRINK TO 回滚段的初始大小示例：回滚段OrclRs01的大小收缩为1MB1ALTER ROLLBACK SEGMENT OrclRs01 SHRINK TO 1M; 删除回滚段 需要先将回滚段设置为脱机状态。ALTER ROLLBACK SEGMENT 回滚段名 OFFLINE; 示例：12ALTER ROLLBACK SEGMENT OrclRs01 OFFLINE;DROP ROLLBACK SEGMENT OrclRs01; 数据库文件管理（待整理）]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>回滚段</tag>
        <tag>数据库文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle存储管理1]]></title>
    <url>%2F2017%2FOracle-store-management-1%2F</url>
    <content type="text"><![CDATA[表空间介绍数据库可划分为若干的逻辑存储单元，这些单元被称为表空间。 表空间的分类 数据库、表空间和数据文件的关系 每个表空间由一个或多个数据文件组成。数据文件用于在物理上存储表空间中所有逻辑结构的数据。 表空间中数据文件的大小之和就是表空间的存储容量（图中系统表空间存储容量为2MB，用户表空间的存储容量为4MB）。 数据库中表空间的存储容量之和就是数据库的存储容量。 预配置的数据库中的表空间 SYSTEM：包含数据目录表和其它管理数据 SYSAUX：是 SYSTEM 表空间的辅助表空间 TEMP：包含仅在会话期间存在的临时数据 UNDOTBS1：包含还原段 USERS：非系统用户创建的所有对象的默认表空间 EXAMPLE：包含示例方案 统计表空间的使用情况 DBA_DATA_FILES，用于查询所有数据文件的信息。 DBA_FREE_SPACE，用于查询表空间的空闲区间信息。 DBA_TABLESPACES，用于查询所有表空间的信息。 1.统计所有表空间的总空间大小123SELECT tablespace_name AS 表空间名,SUM(bytes)FROM DBA_DATA_FILESGROUP BY tablespace_name; 2.统计所有表空间的空闲空间大小123SELECT a.tablespace_name, NVL(SUM(b.bytes),0) bytes FROM DBA_DATA_FILES a, DBA_FREE_SPACE b WHERE a.tablespace_name = b.tablespace_name (+) AND a.file_id = b.file_id (+) GROUP BY a.tablespace_name; 创建表空间语法格式12345678CREATE [BIGFILE|SMALLFILE|UNDO|TEMPORARY] TABLESPACE &lt;表空间名&gt; DATAFILE |TEMPFILE‘数据文件名称和位置’ SIZE &lt;大小&gt; [REUSE] [EXTENT MANAGEMENT LOCAL|DICTIONARY] [AUTOALLOCATE|UNIFORM SIZE &lt;大小&gt;] [SEGMENT SPACE MANAGEMENT AUTO|MANUAL] [BLOCKSIZE &lt;大小&gt; ] 参数说明 DATAFILE子句：用于定义表空间中包含的数据文件。 MININUM EXTENT子句：用于指定表空间中包含的区间的最小值。 BLOCKSIZE子句：用于指定一个不标准的数据块的大小。 logging子句：指定表空间上所有用户的日志属性。 FORCE LOGGING：指定表空间进入强制日志模式，此时系统将记录表空间上对象的所有变化（不包含临时段的变化）。 DEFAULT 存储子句：用于指定缺省的存储信息。 online|offline参数：指定表空间的在线状态。online指定表空间在创建后立即生效；offline指定表空间在创建后无效。 PERMANENT|TEMPORARY参数指定表空间的类型，是永久表空间还是临时表空间。永久表空间中保存永久对象，临时表空间中保存会话生命周期中存在的临时对象。 区间管理子句：指定表空间如何管理区间。使用local选项指定本地管理表空间，使用autoallocate选项表示由表空间自动分配区间，用户不能指定区间的大小。 段管理子句指定表空间如何管理段，通常使用SEGMENT SPACE MANAGEMENT AUTO子句指定自动管理段。 REUSE 如果file 已经存在，并且在创建时指定了file size，那么就重用原文件，并应用新的size，如果没有指定file size，则保留原有的大小。 如果file 不存在，oracle 将忽略该参数。 如果Oracle使用了已经存在的file，那么之前file里的数据将全部丢失。 示例本地管理表空间【例1】在CREATE TABLESPACE语句中使用EXTENT MANAGEMENT LOCAL子句，可以创建一个本地管理表空间1234CREATE TABLESPACE OrclTBS01 DATAFILE 'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf' SIZE 50M EXTENT MANAGEMENT LOCAL AUTOALLOCATE; 【例2】创建表空间OrclTBS02时，指定其统一区间大小为128KB1234CREATE TABLESPACE OrclTBS02 DATAFILE 'C:\app\Administrator\oradata\orcl\OrclTBS02.dbf' SIZE 30M EXTENT MANAGEMENT LOCAL UNIFORM SIZE 128K; 大文件表空间【例】在CREATE TABLESPACE语句中使用BIGFILE关键词可以创建大文件表空间12CREATE BIGFILE TABLESPACE bigtbs DATAFILE 'C:\app\Administrator\oradata\orcl\bigtbs.dbf' SIZE 1G; 临时表空间【例】创建临时表空间tmptbs123456CREATE TEMPORARY TABLESPACE tmptbs TEMPFILE 'C:\app\Administrator\oradata\orcl\tmptbs.dbf' SIZE 20M REUSE EXTENT MANAGEMENT LOCAL UNIFORM SIZE 16K; 段和数据块管理进行插入、更新和删除操作时，段中的数据块的空间会发生变化，块的状态也会发生变化。 两种方法进行块管理： 手动管理（Manual Segment Space Management）Oracle使用自由列表（Free List）管理段中的块，自由列表列出允许进行插入操作的数据块 自动管理（Automatic Segment Space Management，ASSM）自动管理使用位图来管理数据快。当块发生变化时，Oracle会更新位图，以反映这个块是否允许INSERT操作。位图使Oracle自动管理自由空间。 定义段空间管理方式SEGMENT SPACE MANAGEMENT【例】创建自动段管理方式的表空间MyTBS01：1234CREATE TABLESPACE MyTBS01 DATAFILE 'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf' SIZE 30M EXTENT MANAGEMENT LOCAL AUTOALLOCATE SEGMENT SPACE MANAGEMENT AUTO; 【例】创建手动段管理方式的表空间MyTBS01：1234CREATE TABLESPACE MyTBS01 DATAFILE 'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf' SIZE 30M EXTENT MANAGEMENT LOCAL AUTOALLOCATE SEGMENT SPACE MANAGEMENT MANUAL; 数据块是Oracle数据库的最小存储单元，在初始化参数DB_BLOCK_SIZE中定义了标准数据块的大小。在创建表空间时，如果不特殊指定，将使用DB_BLOCK_SIZE中定义的数据作为数据块的大小。 【例】可以在CREATE TABLESPACE语句中使用BLOCKSIZE子句指定非标准数据块的大小：12345CREATE TABLESPACE OrclTBS01 DATAFILE 'C:\app\Administrator\oradata\orcl\OrclTBS01.dbf' SIZE 30M EXTENT MANAGEMENT LOCAL AUTOALLOCATE BLOCKSIZE 8K;新创建的表空间数据块大小为8K。 撤销表空间撤销记录可以用于完成如下功能： 当执行ROLLBACK命令时，完成回滚操作。 恢复数据库。 使用闪回查询分析以前时间点的数据。 使用闪回技术从逻辑破坏中恢复数据。初始化参数UNDO_TABLESPACE设置默认的撤销表空间。【例】使用CREATE UNDO TABLESPACE语句创建撤销表空间：123CREATE UNDO TABLESPACE undotbs01 DATAFILE 'C:\app\Administrator\oradata\orcl\undotbs01.dbf' SIZE 2M REUSE;表空间已创建。 设置和修改表空间属性语法1234567ALTER TABLESPACE &lt;表空间名&gt;RENAME TO|ADD DATAFILE|ADD TEMPFILE|OFFLINE|ONLINE|READ ONLY|READ WRITE|RESIZE … 重命名表空间ALTER TABLESPACE …RENAME TO …【例】将表空间OrclTBS02修改为OrclTBS03，可以使用下面的语句：12ALTER TABLESPACE OrclTBS02 RENAME TO OrclTBS03;表空间已更改。 扩展本地管理表空间【例】在ALTER TABLESPACE语句中使用ADD DATAFILE子句，可以在本地管理表空间中增加数据文件123ALTER TABLESPACE OrclTBS01 ADD DATAFILE 'C:\app\Administrator\oradata\orcl\OrclTBS011.dbf' SIZE 10M;表空间已更改。 更改大文件表空间大小【例】修改大文件表空间bigtbs的数据文件大小为4GB123ALTER TABLESPACE bigtbs RESIZE 4G;表空间已更改。 扩展临时表空间【例】在临时表空间tmptbs中添加临时文件，tmptbs01.dbf，文件大小为20MB：123ALTER TABLESPACE tmptbs ADD TEMPFILE 'C:\app\Administrator\oradata\orcl\tmptbs01.dbf' SIZE 20M;表空间已更改。 设置联机和脱机如下情况可将表空间设置为脱机状态： 将数据库的一部分设置为不可访问，而其他部分可以访问。 执行脱机表空间备份。 在升级或维护应用程序时，将应用程序及其使用的表临时设置为不可访问。 重命名或重新分配表空间。 语法ALTER TABLESPACE…OFFLINE设置表空间为脱机状态ALTER TABLESPACE…ONLINE设置表空间为联机状态。 【例】将表空间OrclTBS01设置为脱机状态TABLESPACE OrclTBS01 OFFLINE;```123此时无法查看表空间状态，会出现错误ORA-01542:表空间’OrclTBS01’脱机，无法在其中分配空间。【例】将表空间OrclTBS01设置为联机状态```ALTER TABLESPACE OrclTBS01 ONLINE; 设置只读表空间语法ALTER TABLESPACE…READ ONLY 只读状态。ALTER TABLESPACE…READ WRITE 可读写状态。【例】将表空间OrclTBS01设置为只读表空间ALTER TABLESPACE OrclTBS01 READ ONLY;```12【例】将表空间OrclTBS01设置为可读写状态：```sql ALTER TABLESPACE OrclTBS01 READ WRITE; 删除表空间DROP TABLESPACE 删除表空间。【例】删除空的表空间OrclTBS01：123DROP TABLESPACE OrclTBS01;表空间已删除。//删除非空表空间 INCLUDING CONTENTS子句可以在删除表空间的同时删除其中的段，例如：12DROP TABLESPACE OrclTBS01 INCLUDING CONTENTS;//该语句只会从数据字典中删除表空间信息，相关的数据文件依然在磁盘上。 INCLUDING CONTENTS AND DATAFILES 子句可以在删除表空间的同时，删除包含的段和数据文件：12DROP TABLESPACE OrclTBS03 INCLUDING CONTENTS AND DATAFILES;//删除操作系统级的文件 Oracle存储管理2 回滚段管理 数据库文件管理回滚段管理 &amp; 数据库文件管理]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>表空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle实例维护]]></title>
    <url>%2F2017%2FOracle-management%2F</url>
    <content type="text"><![CDATA[启动 数据库实例状态 已启动（NOMOUNT）。只读取初始化参数文件、初始化SGA和启动后台进程，创建并启动实例，但不装载数据库。 已装载（MOUNT）。读取初始化参数文件、初始化SGA和启动后台进程，创建并启动实例。并且根据初始化参数control_files的值，找到并打开控制文件，找出数据库的物理结构信息装载数据库，但不打开数据库。 打开（OPEN）。读取初始化参数文件、初始化SGA和启动后台进程，创建并启动实例。并且根据初始化参数control_files的值，找到并打开控制文件，找出数据库的物理结构信息装载数据库，打开各种数据库文件，处于联机状态。 关闭（CLOSE）。将Oracle实例从允许用户访问数据库的状态转变为休止状态。关闭操作首先终止用户访问数据库所需的进程，然后释放计算机中供Oracle运行使用的那部分内存。 命令 选项 含义 startup nomount 创建启动例程 mount 创建例程，并装载数据库 open 创建例程，装载数据库并打开 特殊 force 正常方式启动不了时，用force restrict 以open状态启动数据库的受限模式 pfile 以pfile文件来启动 实例的关闭有以下几种方式：正常关闭；立即关闭；事务处理关闭；中止关闭。 命令 选项 含义 shutdown normal 等待所有连接都断开才关闭 transactional 等所有未提交事务完成关闭 immediate 回滚未提交事务，关闭 abort 不回滚未提交事务，关闭]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlplus的使用方法]]></title>
    <url>%2F2017%2FSqlplus-instructions%2F</url>
    <content type="text"><![CDATA[SQL*PLUS作用 输入SQL命令，对SQL*Plus环境进行配置； 输入、编辑、存储、读取和运行SQL命令和PL/SQL块； 与终端用户进行交互式的操作； 将查询结果输出到报表表格中，设置表格格式和计算公式； 启动和关闭数据库； 连接数据库； 定义变量； 捕捉PL/SQL程序的错误； 列出表的列定义； 执行数据库管理。 SQL*PLUS命令运行SQL*PLUSsqlplus [username]/[password][@server][AS SYSDBA|AS SYSOPER]其中username用于指定数据库用户名，password用于指定用户口令，server用于指定网络服务名，AS SYSDBA表示以SYSDBA特权登录， AS SYSOPER表示以SYSOPER特权登录。当连接到本地数据库时，不需要提供网络服务名。 三种命令类型可以在SQL*PLUS的命令提示符下，输入三种类型的命令： SQL命令：用于操作数据库中的信息 PL/SQL块：用于操作数据库中的信息 SQLPLUS命令：用于编辑、保存、运行SQL命令、PL/SQL块、格式化查询结果、自定义SQLPLUS环境等。 常用SQL*PLUS命令LIST显示SQL*Plus缓冲区中的一行或多行命令123sql&gt; list 1* select name,created from v$databasesql&gt; SAVE保存sql脚本123sql&gt; save c:/select.sql已创建 file C:/select.sqlsql&gt; edit编辑已输入的指令，保存后输入run或 / 执行。 当执行SQL命令和PL/SQL块时，会将命令暂时存放到SQL缓冲区中（在输入另一个命令之前一直存放在SQL缓冲区中）。编辑器只有在SQL缓冲区中有内容时才能启动。 运行命令 命令行方式 SQL缓冲区方式 脚本执行方式 命令行方式 1.运行SQL语句：输入完SQL语句之后，输入分号(;),或在新的一行输入前斜线（/），按回车键即可。 1sql&gt; select * from course; 2.运行PL/SQL块:输入完PL/SQL块之后，在新的一行输入前斜线（/），按回车键即可。 12345678sql&gt; SET SERVEROUTPUT ONsql&gt; BEGIN 2 DBMS_OUTPUT.PUT_LINE('Hello Oracle!') 3 END; 4 /Hello Oracle!PL/SQL 过程已成功完成。 SQL缓冲区方式 SQL缓冲区保留了最后运行的命令。为了以缓冲区方式运行SQL命令或PL/SQL 块，可以使用RUN命令、/命令或菜单命令进行操作。 1.RUN命令 显示并运行当前存储在SQL缓冲区中的SQL语句或PL/SQL块，显示运行结果，并使SQL缓冲区中的最后一行成为当前行。 2./命令 只运行当前存储在SQL缓冲区中的SQL命令或PL/SQL块，显示运行结果，而不显示SQL缓冲区中的SQL命令或PL/SQL块，也不会将SQL缓冲区中的最后一行成为当前行。 3.小结 run显示要执行的代码，/ 不显示过程，两者都显示执行结果。 脚本执行方式有两种运行脚本文件的方式：START命令或@命令。 1.START命令START filename[.ext][arg1,arg2,arg3…]filename表示要运行的脚本文件。SQL*PLUS就使用默认的脚本文件扩展名，通常为.sql。[arg1,arg2,arg3…]表示希望传递给脚本文件的参数。脚本文件中的替换参数必须使用这样的格式声明：&amp;1，&amp;2，&amp;3等。 例:脚本文件c:\test.sql的内容如下：Select ename,sal from emp where deptno=&amp;1 and sal&gt;&2;使用start命令：start c:\test.sql 20 2000 2.@命令功能与START命令类似，可以执行脚本。 连接命令CONNECT建立连接，DISCONNECT断开连接。CONN[ECT]命令先断开前一个连接，然后建立新的连接：CONN[ECT] [username]/[password]@[hoststring] [as sysdba|sysoper]主机字符串省略时，表示连接本地默认数据库。 以system用户连接之后，如果要查看scott方案中的对象，就要在对象前使用”scott.”作为前缀，否则提示不能访问。但如果以用户scott的身份连接数据库实例后,再访问该方案中的对象时,就不再需要前缀。 DISC[ONNECT]会断开连接，但不会退出SQL*PLUS。 交互式命令使SQL命令适应不同的具体条件，与用户交互。交互式命令一般被保存在脚本文件中，以进一步提高脚本文件的可重用性。 替换变量在变量名称前加一个&amp;。可实现define定义替换变量，避免在运行命令或脚本文件时出现反复提示、反复输入的麻烦。12define a = CLERKselect ename from emp where deptno=20 and job='&amp;a'; 可以直接使用define查看当前SQL*PLUS变量中保留的替换变量的情况。使用undefine a可以清除定义的替换变量。 与用户交互可以使用PROMPT命令、PAUSE命令、ACCEPT命令与用户进行通信。 PROMPT命令用于输出提示信息，以便于使用户了解脚本文件的功能和运行情况。 PAUSE命令用于暂停脚本文件的运行。 ACCEPT命令可以让用户指定替换变量的类型（如CHAR,NUMBER,DATE等），用PROMPT选项指定提示信息，用HIDE选项隐藏输入，以便于用户输入替换变量。 例： 123456789 accept pwd prompt '请输入密码：' hidepromptprompt 显示XX部门XX工种员工姓名prompt =========================prompt 按&lt;ENTER&gt;键继续pauseaccept a number prompt '请输入部门：'accept b char prompt '请输入工种:'select ename from scott.emp where deptno=&amp;a and job='&amp;b';]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>sqlplus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的Oracle服务及其作用]]></title>
    <url>%2F2017%2FOracle-services%2F</url>
    <content type="text"><![CDATA[常用的Oracle服务及其作用Oracle ORCL VSS Writer ServiceOracle卷映射拷贝写入服务，VSS（Volume Shadow copy Service）能够让存储基础设备（比如磁盘、阵列等）创建高保真的时间点映像，即映射拷贝（Shadow Copy）。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统性能。 OracleDBConsoleorclOracle数据库控制台服务，orcl是Oracle例程标识，默认的例程为orcl。在运行Oracle Enterprise Manager 11g时，需要启动此服务。OracleJobSchedulerORCL。Oracle作业调度进行，ORCL是Oracle例程标识。此服务被默认设置为禁用。 OracleOraDb11g_home1TNSListener监听器服务，服务只有在数据库需要远程访问时才需要。此服务被默认设置为自动启动。 OracleServiceORCL数据库服务，这个服务会自动地启动和停止数据库。ORCL是Oracle例程标识。此服务被默认设置为自动启动。 不同服务之间的关系首先启动Oracle&lt;ORACLE_HOME_NAME&gt;TNSListener服务，然后再启动其它服务；如果不启动Oracle&lt;ORACLE_HOME_NAME&gt;TNSListener，则可以使用SQL*Plus，但不能使用OEM;OracleDBConsole&lt;sid&gt;依赖于OracleService&lt;SID&gt;，所以必须先启动OracleService&lt;SID&gt;，之后才能启动OracleDBConsole&lt;sid&gt;，关闭OracleService&lt;SID&gt;之前，应该先关闭OracleDBConsole&lt;sid&gt;。 小结OracleServiceOrcl是实例的服务，需要开启才能打开例程。OracleOraDB11g_home1TNSListener，是监听服务，在OracleServiceOrcl服务开启下，例程是存在的，但无法监听，无法连接到例程。OracleDBConsoleOrcl服务是控制台服务，EM控制台的开关，关闭后无法使用EM，但可以使用SQL Plus连接数据库。 SQL*PLUS的使用方法sqlplus [username]/[password][@server][AS SYSDBA|AS SYSOPER]其中username用于指定数据库用户名，password用于指定用户口令，server用于指定网络服务名，AS SYSDBA表示以SYSDBA特权登录， AS SYSOPER表示以SYSOPER特权登录。当连接到本地数据库时，不需要提供网络服务名。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Oracle]]></title>
    <url>%2F2017%2FOracle-basic%2F</url>
    <content type="text"><![CDATA[基本概念数据库(Database,DB)数据库管理系统(DataBase Management System,DBMS)数据库管理员(DataBase Administrator,DBA)数据库系统(DataBase System,DBS)关系型数据库(Relationship DataBase,RDB)关系型数据库管理系统(RDBMS)SQL语言（Structured Query Language） 数据库(Database, DB)数据库是长期保存在计算机存储设备上的、有组织或按一定格式存放的、可以共享的数据集合。简单地说，就是存放数据的仓库，或者说是存储在一起的相关数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度和较高的数据独立性，并可以为各种用户共享。数据库是由数据库管理系统来管理的。 数据库管理系统(DataBase System,DBS)DBMS是建立在操作系统的基础上，对物理数据库进行统一管理和控制的软件，是位于用户和操作系统之间的一层数据管理软件。用户对数据库提出的访问请求是由DBMS来处理的。在DBMS中还提供了许多对数据库进行操作的使用程序。 DBMS使得能够方便的完成以下操作： 建立和维护数据库 定义数据 操作数据 保证数据的安全性、完整性 多用户实现数据的共享 发生故障之后进行数据恢复 数据库系统(DataBase System, DBS)数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员和用户构成。应当指出的是，数据库的建立、使用和维护等工作只靠一个DBMS远远不够，还要有专门的人员来完成，这些人被称为数据库管理员(DBA)。 数据库管理员(DataBase Administrator, DBA)负责整个数据库系统的建立、维护和协调的专门人员，是掌握数据库全局并进行数据库设计和管理的骨干人员。 数据管理历程 人工阶段数据不保存数据由应用程序管理数据不能共享数据不具有独立性，随其逻辑结构和物理结构而改变 文件管理阶段数据以文件形式长期存在数据由文件系统管理数据共享性差、独立性差 数据库管理阶段有利于实现数据共享数据面向应用，而非面向程序 关系模型关系模型是在逻辑模型的基础上建立的适用于具体数据库实现的一种数据模型。关系模型是目前最重要的一种数据模型。它是实体、属性、关系在数据库中的具体体现。为了将逻辑模型转换为关系模型，需要将实体映射为数据库表，将属性映射为数据库列，将关系映射为数据库表的主键或外键。 在用户的观点下，关系模型中数据的逻辑结构是一张二维表，由行和列组成。 基本术语 关系：整个二维表 关系名：表格名称 元组：行数据（记录） 属性：列数据（字段/分量） 属性名：列名称（字段名） 主键：唯一确定元组的属性组（关键字） 域：属性的取值范围 关系模式：对关系的描述，表示为：关系名（属性列表）如：学生（学号，姓名，性别，系别，年龄，籍贯） 关系的约束域完整性约束实体完整性约束参照完整性约束 关系型数据库 关系型数据库是建立在关系模型基础上的数据库。它由一些相关的表和其他数据库对象组成。 这个定义包含几层含义：第一：建立在关系模型基础上；第二，信息被存放在表（二维表)中；第三，表之间是相互关联的；第四，除了表之外，还有其他数据库对象，如索引、视图、存储过程等。 当前流行的大型关系型数据库： Oracle、IBM DB2、SQL Server、SyBase、Informix等。 关系型数据库采用结构化查询语言（SQL）作为客户端程序与数据库服务器间沟通的桥梁——客户端发送SQL指令到服务器端，服务器端执行相关的指令并返回其查询的结果。 Oracle 与 SQL Server 比较 比较 Oracle SQL Server 所支持操作系统 UNIX、LINUX、SUN SOLARIS、WINDOWS WINDOWS 数据吞吐量 面对大中型应用，最大可管理170TG左右 面对中小型应用，一般30-40G左右 多语言支持 不按照语言划分版本，共支持100多种语言 分为各种语言的版本，每种版本只支持一种语言，语言支持的数目不多 Oracle 11g 体系结构数据库的体系结构可以按照逻辑结构和物理结构来划分 : 数据库物理结构 Oracle将数据库按照规定的结构划分为不同级别的逻辑单元。这里指的逻辑单元包括表、视图等常见的数据库组件。 逻辑结构和物理结构是分离的，对物理结构的管理可以不影响对逻辑存储结构的访问。 物理结构由构成数据库的操作系统文件所决定。 每个Oracle数据库都由3种类型的文件组成：数据文件、日志文件、控制文件。 数据文件Oracle数据库有一个或多个物理的数据文件。数据库的数据文件包含全部数据库数据。逻辑数据物理地存储在数据文件中。数据文件有下列特征： 一个数据文件仅与一个数据库联系。 当数据库容量越界时，数据文件能够自动扩展。 一个或多个数据文件组成一个表空间。 日志文件每个数据库有两个或多个日志文件组，日志文件组用于收集数据库日志。日志的主要功能是记录对数据所作的修改，所以对数据库作的全部修改记录在日志中。 控制文件每个Oracle数据库有一个控制文件，记录数据库的物理结构。（类似Windows注册表的作用）控制文件包含数据库名、数据库数据文件和日志文件的名字、位置和数据库建立日期等信息。 数据库逻辑结构数据库由表空间或者说由方案组成。Oracle 数据库的逻辑结构包括数据块（data block）、区间（extent）、段（segment）和表空间（tablespace）等。数据库由若干个表空间组成，表空间由表组成，表由段组成，段由区间组成，区间则由数据块组成。 表，视图，索引，簇 表：数据库中最常用的数据存储单元，它包括所有用户可以访问的数据。 视图：虚拟的表，它在物理上并不存在。视图可以把表或其他视图的数据按照一定的条件组合起来，所以也可以把它看成是一个存储的查询。视图并不包含数据，它只是从基表中读取数据。 索引：与表相关联的可选结构。创建索引可以提高读取数据的效率。 簇：有些表共享公共的列，并经常被同时访问，为了提高数据存取的效率，把这些表在物理上存储在一起，得到的表的组合就是簇。与索引相似，簇并不影响应用程序的设计。用户和应用程序并不关心表是否是簇的一部分，因为无论表在不在簇中，访问表的SQL语句都是一样的。 数据块 数据块是Oracle管理数据库存储空间的最小数据存储单位。 一个数据块对应磁盘上一定数量的数据库空间，标准的数据块大小由初始参数DB_BLOCK_SIZE指定。 数据块既是逻辑单位，也是物理单位。 块的大小是操作系统块大小的整数倍。（以Win2K为例,操作系统块(OS block)的大小为4kb，所以Oracle Block的大小可以是4kb,8kb,16kb等等。） 公共的变长头：包含数据块的通用信息，如块地址和段类型等 表目录：包含在此块中有行数据的表的信息 行目录：包含此块中实际行数据的信息（包括在行数据区中每个行数据片的地址） 空闲空间：插入新行时需要存储空间，更新行数据时也可能造成存储空间的增加，这些存储空间都需要从空闲空间中分配 行数据：包含表或索引数据。行数据的存储可以跨越数据块 区间 区间是数据库存储空间中分配的一个逻辑单元，由一组相邻的数据块组成，它是Oracle分配磁盘空间的最小单位。 ，在创建段时，它所包含的区间数量只能为MINEXTENTS。随着段中数据的增加，区间数量也可以不断增加，但不能超过MAXEXTENTS中定义的数量，否则会出现错误。 段段是由一组区间组成。 段类型 说明 数据段 每个不在簇中的表都有一个数据段。表中的所有数据都存储在数据段的区间中。每个簇都有一个数据段。簇中每个表的数据都存储在簇的数据段中 索引段 每个索引都有一个索引段，存储所有的索引数据 临时段 当执行SQL语句需要临时工作区时，Oracle将创建临时段。执行完毕后，临时段的区间将被系统回收，以备需要时分配使用 回滚段 如果当前系统处于自动重做管理模式，则数据库服务器使用表空间来管理重做空间。这是Oracle公司推荐使用的模式。但是，如果使用手动重做管理模式，则数据库管理员需要创建一个或多个回滚段，用于临时存储重做信息。回滚段中的信息将在数据库恢复过程中使用到 表空间 数据库可以划分为若干的逻辑存储单元，这些存储单元被称为表空间。 每个数据库都至少有一个系统表空间（称为SYSTEM表空间）。 在创建表时，需要定义保存表的表空间。 表空间 说明 系统表空间（SYSTEM Tablespace） Oracle数据库必须具备的部分。用于存放表空间名称、表空间所包含的数据文件等管理数据库自身所需要的信息 辅助表空间（SYSAUX Tablespace） 系统表空间的辅助表空间，很多数据库组件把系统表空间作为存储数据的默认位置 撤消表空间（Undo Tablespace） 用于事务的回滚和撤销的表空间 临时表空间（Temporary Tablespace） 用于存储数据库的临时表 用户表空间（Users Tablespace） 用于存储用户的私有数据 大文件表空间（Bigfile Tablespaces） Oracle 10g提供的一种新的表空间，它只能包含一个大文件，但文件大小可以达到4G个数据块 数据库、表空间和数据文件的关系 每个表空间由一个或多个数据文件组成。数据文件用于在物理上存储表空间中所有逻辑结构的数据。 表空间中数据文件的大小之和就是表空间的存储容量。 数据库中表空间的存储容量之和就是数据库的存储容量。 方案 方案是一组数据库对象的集合。在创建用户的时候，会同时生成一个与用户同名的方案，此方案归同名用户所有。 方案对象直接处理数据库数据的逻辑结构，例如表（table）、视图（view）、索引（index）和簇（Clusters）等。 表空间和方案之间的关系 同一方案中的对象可以存储在不同的表空间中 表空间可以存储不同方案中的对象 逻辑和物理结构关系 数据库例程（Oracle Instance） 当用户连接到数据库，使用数据库时，实际上连接到该数据库的例程，通过例程来连接、使用数据库。 例程是用户和数据库之间的一个中间层。 例程和数据库的区别：数据库主要只用于存储数据的物理结构，总是实际存在的例程是由操作系统的内存结构和一系列的进程组成，可以启动和关闭 每个运行的Oracle数据库都对应一个Oracle例程（Instance），也可以称为实例。 一台计算机上可以创建多个Oracle数据库，一个数据库上可以有多个例程。 例程的组成例程（INSTANCE）是存取和控制数据库的软件机制，它由系统全局区（System Global Area，简称SGA）和进程组成。 内部存储结构 系统全局区（System Global Area，SGA） 程序全局区（Program Global Area，PGA） 系统全局区(SGA)SGA是ORACLE系统为实例分配的一组共享缓冲存储区，用于存放数据库数据和控制信息，以实现对数据库数据的管理和操作。 每个例程都只有一个SGA.它是不同用户进程与服务进程进行通信的中心,数据库的各种操作主要在SGA中进行。创建例程时,Oracle为SGA分配内存；终止例程时,释放SGA所占用的内存。 数据库缓冲区：保存最近从数据文件中读取的数据块； 重做日志缓冲区：用于存储重做记录； SQL共享池：最近执行的SQL语句、PL/SQL程序和数据字典信息,是对SQL语句和PL/SQL程序进行语法分析、编译、执行的内存区； Java池：为Java命令提供语法分析； 大池：DBA配置的可选内存区域，用于分配大量的内存； 数据词典缓冲区：保存数据库对象的信息，如帐号、数据文件名、段名、表说明和权限等； 程序全局区(PGA)PGA是在用户进程连接到数据库，并创建一个对应的会话时，由oracle为服务进程分配的，专门用于当前用户会话的内存区。这个内存区是非共享的，只有服务进程本身才能访问它自己的PGA。包含Oracle进程数据和控制信息的内存区域。 PGA是非共享的，而SGA是共享的。PGA大小由操作系统决定，并且分配后保持不变；会话终止时，自动释放PGA所占的内存。 进程结构进程是操作系统中的一个概念，是一个可以独立调用的活动，用于完成指定的任务。 进程与程序的区别是： 进程是动态创建的，完成后销毁；程序是静态的实体，可以复制、编辑。进程强调执行过程，程序仅仅是指令的有序集合。进程在内存中，程序在外存中。 用户进程运行应用程序或Oracle工具。当用户运行一个应用程序时，就建立一个用户进程。 服务器进程用于处理连接到数据库例程的用户进程的请求。 主要完成以下工作：分析并运行应用程序中的SQL语句；如果需要的数据块不在SGA中，则把它从数据文件中读取到SGA的共享数据库缓冲区中；返回应用程序需要的结果； 后台进程为了实现系统的最佳性能，并协调多个用户，在多进程Oracle系统中使用的一些附加进程，多由操作系统自动创建。 主要的后台进程有： DBWn：数据库写进程 LGWR：日志写进程 CKPT：检查点写进程 SMON：系统监控进程 PMON：进程监控进程 ARCn：归档进程 RECO：恢复进程 LCKn：封锁进程 Oracle数据库用户类型 数据库管理员 安全官员 网络管理员 应用程序开发员 应用程序管理员 数据库用户 数据库管理员 安装和升级Oracle数据库服务器和其他应用工具。 分配系统存储空间，并计划数据库系统未来需要的存储空间。 当应用程序开发员设计完成一个应用程序之后，为其创建主要的数据库存储结构，例如表空间。 根据应用程序开发员的设计创建主要的数据库对象，例如表、视图和索引。 根据应用程序开发员提供的信息修改数据库结构。 管理用户，维护系统安全。 确保对Oracle的使用符合Oracle的许可协议。 控制和监视用户对数据库的访问。 监视和优化数据库的行为。 做好备份和恢复数据库的计划。 维护磁带中归档的数据。 备份和恢复数据库。 在必要时联系Oracle公司获取技术支持。 安全管理员安全官员可以管理用户、控制和监视用户对数据库的访问，以及维护数据库的安全。如果拥有单独的安全官员，则DBA就不需要关注这些问题。 网络管理员网络管理员可以管理Oracle的网络产品。 应用程序开发员 设计和开发数据库应用程序。 为应用程序设计数据库结构。 估算应用程序需要的数据库存储空间。 定义应用程序需要对数据库结构所进行的修改。 将上述信息提供给数据库管理员。 在开发过程中对应用程序进行调整。 在开发过程中对应用程序的安全性进行检测。 应用程序管理员应用程序管理员可以对指定的应用程序进行管理，每个应用程序都可以有自己的管理员。 数据库用户数据库用户通过应用程序与数据库打交道。数据库用户最常用的权限如下： 在权限的范围内添加、修改和删除数据。 从数据库中生成统计报表。 默认数据库管理员用户数据库管理员可以拥有两种类型的用户: 操作系统账户 Oracle数据库账户 数据库管理员的操作系统账户。为了完成许多数据库管理任务，数据库管理员必须能够执行操作系统命令，因此数据库管理员需要拥有一个操作系统账户用于访问操作系统。 数据库管理员的用户名。在创建Oracle数据库时，如下两个用户被自动创建：SYS，默认密码为CHANGE_ON_INSTALL。SYSTEM，默认密码为MANAGER。 sys和system用户区别 最重要的区别，存储的数据的重要性不同sys所有oracle的数据字典的基表和视图都存放在sys用户中，这些基表和视图对于oracle的运行是至关重要的，由数据库自己维护，任何用户都不能手动更改。sys用户拥有sysdba，sysoper等角色或权限，是oracle权限最高的用户。system用户用于存放次一级的内部数据，如oracle的一些特性或工具的管理信息。system用户拥有sysdba角色权限。 其次的区别，权限的不同system用户只能用normal身份登陆em，除非你对它授予了sysdba的系统权限或者syspoer系统权限。 sys用户具有“SYSDBA”或者“SYSOPER”系统权限，登陆em也只能用这两个身份，不能用normal。以sys用户登陆Oracle，执行select * from V_$PWFILE_USERS;可查询到具有sysdba权限的用户。 SYSDBA与SYSOPER权限的区别 SYSDBA SYSOPER startup startup shutdown shutdown alter database Open/mount/backup alter database Open/mount/backup 改变字符集 create database drop database create spfile create spfile alter database archivelog alter database archivelog alter database recover alter database recover 拥有restricted session权限 拥有restricted session权限 对应的方案是SYS 对应的方案是PUBLIC]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
</search>
